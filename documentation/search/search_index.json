{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"SAGE-X Development Wiki","text":"<p>Welcome to the SAGE-X Development Documentation!</p> <p>SAGE-X (Self-programming Agent Generation Engine: Next Generation) is an AI agent framework built on top of Google ADK.</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Introduction - Project overview and features</li> <li>Getting Started - Quick start guide</li> <li>Architecture - System architecture overview</li> <li>Core Concepts - Core concepts explained</li> </ul>"},{"location":"#documentation-index","title":"Documentation Index","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Introduction - What is SAGE-X?</li> <li>Getting Started - Environment setup and installation</li> <li>Project Structure - Project structure overview</li> </ul>"},{"location":"#entry-points","title":"Entry Points","text":"<ul> <li>Entry Points - Overview of entry points</li> <li>Aigise Web Entry - Interactive web UI workflow</li> <li>Evaluation Entry - Batch evaluation workflow</li> <li>RL Integration - RL framework integration for agent training</li> </ul>"},{"location":"#core-topics","title":"Core Topics","text":"<ul> <li>Architecture - Architecture design</li> <li>Core Components - Core components explained</li> <li>Core Concepts - Core concepts (Sessions, Agents, Sandboxes)</li> </ul>"},{"location":"#development-guides","title":"Development Guides","text":"<ul> <li>Development Guides - Development guide overview</li> <li>Adding Tools - How to add new tools</li> <li>Adding Sandboxes - How to add new sandboxes</li> <li>Adding Evaluations - How to add evaluation benchmarks</li> </ul>"},{"location":"#practices","title":"Practices","text":"<ul> <li>Best Practices - Best practices</li> <li>Common Patterns - Common code patterns</li> <li>Testing Debugging - Testing and debugging</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Troubleshooting - Troubleshooting guide</li> <li>Contributing - Contributing guidelines</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Session-based resource management with isolation</li> <li>\u2705 Multi-sandbox support (Docker, Kubernetes)</li> <li>\u2705 Security tool integration (Joern, CodeQL, GDB, Neo4j)</li> <li>\u2705 Dynamic tool loading</li> <li>\u2705 Evaluation framework</li> </ul>"},{"location":"#getting-started_1","title":"Getting Started","text":"<p>If you're new to SAGE-X, we recommend reading in this order:</p> <ol> <li>Introduction - Learn about the project</li> <li>Getting Started - Set up your environment</li> <li>Core Concepts - Understand core concepts</li> <li>Development Guides - Start developing</li> </ol> <p>Check the GitHub repository for the latest code</p>"},{"location":"Adding-Evaluations/","title":"Adding a New Evaluation Benchmark","text":""},{"location":"Adding-Evaluations/#overview","title":"Overview","text":"<p>Evaluations are used to benchmark agent performance on specific tasks.</p>"},{"location":"Adding-Evaluations/#steps","title":"Steps","text":"<ol> <li>Create evaluation module in <code>src/aigise/evaluations/</code></li> <li>Implement evaluation interface</li> <li>Add configuration template</li> <li>Add sample data handling</li> </ol>"},{"location":"Adding-Evaluations/#evaluation-structure","title":"Evaluation Structure","text":"<pre><code># src/aigise/evaluations/my_benchmark/my_evaluation.py\nfrom aigise.evaluations import EvaluationTask\n\nclass MyEvaluation:\n    async def run_evaluation(self, tasks):\n        # Evaluation logic\n        pass\n</code></pre>"},{"location":"Adding-Evaluations/#configuration","title":"Configuration","text":"<p>Create config template in <code>src/aigise/evaluations/configs/</code>:</p> <pre><code># my_benchmark_config.toml\ntask_name = \"my_benchmark\"\n# ... evaluation-specific config\n</code></pre>"},{"location":"Adding-Evaluations/#data-handling","title":"Data Handling","text":"<ul> <li>Load benchmark data</li> <li>Run agents on tasks</li> <li>Collect results</li> <li>Generate metrics</li> </ul>"},{"location":"Adding-Evaluations/#see-also","title":"See Also","text":"<ul> <li>Development Guides - Other development guides</li> <li>Testing Debugging - Testing evaluations</li> </ul>"},{"location":"Adding-Sandboxes/","title":"Adding a New Sandbox Type","text":""},{"location":"Adding-Sandboxes/#overview","title":"Overview","text":"<p>Sandboxes provide isolated execution environments. You can add custom sandbox types with specific initialization logic.</p>"},{"location":"Adding-Sandboxes/#steps","title":"Steps","text":"<ol> <li>Create initializer in <code>src/aigise/sandbox/initializers/</code></li> <li>Implement <code>SandboxInitializer</code> interface</li> <li>Add configuration in <code>config_dataclass.py</code></li> <li>Update default config template</li> </ol>"},{"location":"Adding-Sandboxes/#example","title":"Example","text":"<pre><code># src/aigise/sandbox/initializers/my_sandbox.py\nfrom .base import SandboxInitializer\n\nclass MySandboxInitializer(SandboxInitializer):\n    async def async_initialize(self) -&gt; None:\n        # Initialize sandbox-specific resources\n        # Access session via self if needed\n        pass\n</code></pre>"},{"location":"Adding-Sandboxes/#configuration","title":"Configuration","text":"<p>Add sandbox configuration in TOML:</p> <pre><code>[sandbox.sandboxes.my_sandbox]\nimage = \"my_image:tag\"\n# ... other config options\n</code></pre>"},{"location":"Adding-Sandboxes/#initialization-flow","title":"Initialization Flow","text":"<ol> <li>Sandbox container is created</li> <li><code>async_initialize()</code> is called</li> <li>Resources are set up</li> <li>Sandbox is ready for use</li> </ol>"},{"location":"Adding-Sandboxes/#see-also","title":"See Also","text":"<ul> <li>Core Components - Sandbox system details</li> <li>Core Concepts - Sandbox lifecycle</li> <li>Development Guides - Other development guides</li> </ul>"},{"location":"Adding-Tools/","title":"Adding a New Tool","text":""},{"location":"Adding-Tools/#overview","title":"Overview","text":"<p>In AIgiSE, tools are implemented as Agent Skills (bash scripts) or MCP toolsets (Model Context Protocol), rather than Python functions. This design allows tools to be executed directly in sandbox containers via bash commands, providing better isolation and flexibility.</p>"},{"location":"Adding-Tools/#tool-types","title":"Tool Types","text":""},{"location":"Adding-Tools/#1-agent-skills-bash-scripts","title":"1. Agent Skills (Bash Scripts)","text":"<p>Agent Skills are bash scripts organized in a structured directory format with metadata. They are automatically discovered and loaded by the framework.</p>"},{"location":"Adding-Tools/#2-mcp-toolsets","title":"2. MCP Toolsets","text":"<p>MCP (Model Context Protocol) toolsets provide integration with external services or tools running in separate containers, typically accessed via SSE (Server-Sent Events) connections.</p>"},{"location":"Adding-Tools/#creating-an-agent-skill","title":"Creating an Agent Skill","text":""},{"location":"Adding-Tools/#directory-structure","title":"Directory Structure","text":"<p>Create a skill directory under <code>src/aigise/bash_tools/</code>:</p> <pre><code>src/aigise/bash_tools/\n\u2514\u2500\u2500 category/\n    \u2514\u2500\u2500 tool-name/\n        \u251c\u2500\u2500 SKILL.md          # Tool metadata and documentation\n        \u2514\u2500\u2500 scripts/\n            \u2514\u2500\u2500 tool_script.sh # The actual bash script\n</code></pre> <p>Example structure: <pre><code>src/aigise/bash_tools/\n\u2514\u2500\u2500 retrieval/\n    \u2514\u2500\u2500 grep/\n        \u251c\u2500\u2500 SKILL.md\n        \u2514\u2500\u2500 scripts/\n            \u2514\u2500\u2500 grep.sh\n</code></pre></p>"},{"location":"Adding-Tools/#skillmd-format","title":"SKILL.md Format","text":"<p>The <code>SKILL.md</code> file contains YAML frontmatter and markdown documentation:</p> <pre><code>---\nname: tool-name\ndescription: Brief description of what the tool does\n---\n\n# Tool Name\n\nDetailed description of the tool's functionality.\n\n## Usage\n\n```bash\nscripts/tool_script.sh arg1 arg2 --option value\n</code></pre>"},{"location":"Adding-Tools/#parameters","title":"Parameters","text":""},{"location":"Adding-Tools/#param1-required-positional-position-0","title":"param1 (required, positional position 0)","text":"<p>Type: <code>str</code></p> <p>Description of the parameter.</p>"},{"location":"Adding-Tools/#param2-optional-positional-position-1","title":"param2 (optional, positional position 1)","text":"<p>Type: <code>int</code></p> <p>Description of the parameter.</p>"},{"location":"Adding-Tools/#-option-optional-named-parameter","title":"--option (optional, named parameter)","text":"<p>Type: <code>str</code></p> <p>Description of the option.</p>"},{"location":"Adding-Tools/#-flag-optional-flag","title":"--flag (optional, flag)","text":"<p>Type: <code>bool</code> (default: <code>false</code>)</p> <p>Description of the flag.</p>"},{"location":"Adding-Tools/#return-value","title":"Return Value","text":"<p>Returns a JSON object with results:</p> <pre><code>{\n  \"success\": true,\n  \"result\": \"...\"\n}\n</code></pre>"},{"location":"Adding-Tools/#requires-sandbox","title":"Requires Sandbox","text":"<p>main</p>"},{"location":"Adding-Tools/#timeout","title":"Timeout","text":"<p>Default timeout: 60 seconds <pre><code>### Parameter Types\n\n- **Positional parameters**: Specified with `positional position N` in the parameter description\n- **Named parameters**: Use `--param_name value` format\n- **Boolean flags**: Use `--flag` (no value needed)\n\n### Bash Script Implementation\n\nThe bash script should:\n\n1. Accept command-line arguments (positional and named)\n2. Return JSON output for structured results\n3. Use proper exit codes (0 for success, non-zero for errors)\n\n**Example script:**\n\n```bash\n#!/bin/bash\n\n# tool_script.sh - Tool description\n# Usage: ./tool_script.sh param1 param2 --option value\n\nif [ -z \"$1\" ]; then\n    echo '{\"error\": \"Missing required parameter\"}'\n    exit 1\nfi\n\nPARAM1=\"$1\"\nPARAM2=\"${2:-default}\"\n\n# Process --option if provided\nOPTION=\"\"\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --option)\n            OPTION=\"$2\"\n            shift 2\n            ;;\n        *)\n            shift\n            ;;\n    esac\ndone\n\n# Tool logic here\nRESULT=$(some_command \"$PARAM1\" \"$PARAM2\")\n\n# Return JSON\necho \"{\\\"success\\\": true, \\\"result\\\": \\\"$RESULT\\\"}\"\n</code></pre></p>"},{"location":"Adding-Tools/#sandbox-requirements","title":"Sandbox Requirements","text":"<p>Specify required sandbox types in the <code>## Requires Sandbox</code> section:</p> <pre><code>## Requires Sandbox\n\nmain\n</code></pre> <p>Or for multiple sandboxes:</p> <pre><code>## Requires Sandbox\n\nmain, fuzz\n</code></pre>"},{"location":"Adding-Tools/#automatic-discovery","title":"Automatic Discovery","text":"<p>Tools are automatically discovered from: - <code>src/aigise/bash_tools/</code> (built-in tools) - <code>~/.local/plugins/aigise/tools/</code> (user plugins)</p> <p>The framework scans these directories for <code>SKILL.md</code> files and loads them automatically.</p>"},{"location":"Adding-Tools/#creating-an-mcp-toolset","title":"Creating an MCP Toolset","text":"<p>MCP toolsets are created via Python functions that return <code>MCPToolset</code> instances:</p> <pre><code># src/aigise/toolbox/category/get_toolset.py\nfrom google.adk.tools.mcp_tool.mcp_toolset import MCPToolset, SseConnectionParams\nfrom aigise.toolbox.decorators import requires_sandbox, safe_tool_execution\nfrom aigise.utils.agent_utils import get_mcp_url_from_session_id\n\n@safe_tool_execution\n@requires_sandbox(\"gdb_mcp\")\ndef get_toolset(aigise_session_id: str) -&gt; MCPToolset:\n    \"\"\"Create MCPToolset with GDB MCP server running in Docker container.\n\n    Args:\n        aigise_session_id: Shared session ID for session-based management\n\n    Returns:\n        MCPToolset connected to GDB MCP server\n    \"\"\"\n    url = get_mcp_url_from_session_id(\"gdb_mcp\", aigise_session_id)\n    mcp_toolset = MCPToolset(connection_params=SseConnectionParams(url=url))\n    return mcp_toolset\n</code></pre> <p>The function should: - Use <code>@safe_tool_execution</code> decorator - Use <code>@requires_sandbox</code> to specify required sandbox types - Return an <code>MCPToolset</code> instance - Be registered in the agent's tools list</p>"},{"location":"Adding-Tools/#tool-registration","title":"Tool Registration","text":""},{"location":"Adding-Tools/#for-agent-skills","title":"For Agent Skills","text":"<p>Agent Skills are automatically discovered and registered. No manual registration needed.</p>"},{"location":"Adding-Tools/#for-mcp-toolsets","title":"For MCP Toolsets","text":"<p>Add the toolset getter function to your agent's tools:</p> <pre><code>from aigise.toolbox.category.get_toolset import get_toolset\n\nagent = AigiseAgent(\n    name=\"my_agent\",\n    tools=[get_toolset, ...],  # Add the getter function\n    ...\n)\n</code></pre>"},{"location":"Adding-Tools/#best-practices","title":"Best Practices","text":"<ol> <li>Use bash scripts for container operations: Prefer bash scripts for tools that interact with sandbox containers</li> <li>Return JSON: Always return structured JSON from bash scripts for easy parsing</li> <li>Document thoroughly: Include clear parameter descriptions and usage examples in <code>SKILL.md</code></li> <li>Handle errors gracefully: Use proper exit codes and error messages</li> <li>Specify sandbox requirements: Always document which sandboxes are required</li> <li>Use MCP for external services: Use MCP toolsets for tools that run in separate containers or services</li> </ol>"},{"location":"Adding-Tools/#see-also","title":"See Also","text":"<ul> <li>Common Patterns - Tool development patterns</li> <li>Best Practices - Best practices for tools</li> <li>Core Concepts - Understanding tools in context</li> </ul>"},{"location":"Aigise-Web-Entry/","title":"aigise web - Interactive Development Entry Point","text":"<p>The <code>aigise web</code> command starts an interactive web UI for developing and debugging agents.</p>"},{"location":"Aigise-Web-Entry/#cli-commands","title":"CLI Commands","text":""},{"location":"Aigise-Web-Entry/#aigise-web","title":"aigise web","text":"<p>Starts an interactive web UI for agent development and debugging.</p> <pre><code>uv run aigise web \\\n  --config /path/to/config.toml \\\n  --agent /path/to/agent_dir \\\n  --port 8000 \\\n  --neo4j_logging  # optional\n</code></pre>"},{"location":"Aigise-Web-Entry/#aigise-dependency-check","title":"aigise dependency-check","text":"<p>Checks if external dependencies are properly installed.</p> <pre><code>uv run aigise dependency-check\n</code></pre> <p>This command verifies: - CodeQL: Required for CodeQL static analysis features - Docker: Required for native Docker sandbox backend - kubectl: Required for Kubernetes sandbox backend</p> <p>All dependencies are optional unless you plan to use the corresponding features. The command will show: - \u2713 Green checkmarks for available dependencies - \u26a0 Yellow warnings for missing optional dependencies - \u2717 Red errors for missing required dependencies (if any)</p> <p>Example Output:</p> <pre><code>Checking AIgiSE dependencies...\n\nChecking CodeQL...\n  \u2713 CodeQL binary found at /path/to/codeql\n\nChecking Docker...\n  \u2713 Docker daemon is running and accessible\n\nChecking kubectl...\n  \u26a0 kubectl command not found in PATH. Install kubectl to use Kubernetes backend.\n    Note: Only required when using Kubernetes sandbox backend\n\n============================================================\n\u26a0 Some dependencies missing (2/3 available)\n\nNote: Missing dependencies are optional unless you plan to use\nthe corresponding features.\n============================================================\n</code></pre>"},{"location":"Aigise-Web-Entry/#step-by-step-workflow","title":"Step-by-Step Workflow","text":""},{"location":"Aigise-Web-Entry/#step-1-command-parsing-and-validation","title":"Step 1: Command Parsing and Validation","text":"<ol> <li>CLI parses command-line arguments</li> <li>Validates that <code>config_path</code> exists and is a file</li> <li>Validates that <code>agent_dir</code> exists and is a directory</li> <li>Sets up logging based on <code>--log_level</code> option</li> </ol>"},{"location":"Aigise-Web-Entry/#step-2-optional-neo4j-logging-setup","title":"Step 2: Optional Neo4j Logging Setup","text":"<p>If <code>--neo4j_logging</code> flag is provided: 1. Imports <code>enable_neo4j_logging</code> from <code>aigise.features.agent_history_tracker</code> 2. Enables Neo4j logging via monkey patches 3. This allows event logging to Neo4j for analysis</p>"},{"location":"Aigise-Web-Entry/#step-3-environment-preparation-_prepare_environment_async","title":"Step 3: Environment Preparation (<code>_prepare_environment_async</code>)","text":"<p>This is the core setup phase that creates the SAGE-X session and initializes all resources.</p>"},{"location":"Aigise-Web-Entry/#31-create-session-id","title":"3.1 Create Session ID","text":"<ul> <li>Generates a unique UUID for the session</li> <li>Format: <code>str(uuid.uuid4())</code></li> <li>Example: <code>\"550e8400-e29b-41d4-a716-446655440000\"</code></li> </ul>"},{"location":"Aigise-Web-Entry/#32-create-aigisesession","title":"3.2 Create AigiseSession","text":"<p><pre><code>aigise_session = get_aigise_session(\n    aigise_session_id=session_id,\n    config_path=config_path\n)\n</code></pre> - Loads TOML configuration file - Expands template variables (e.g., <code>${VAR_NAME}</code>) - Creates <code>AigiseSession</code> instance with all managers:   - <code>config</code>: Configuration manager   - <code>agents</code>: DynamicAgentManager   - <code>sandboxes</code>: AigiseSandboxManager   - <code>neo4j</code>: AigiseNeo4jClientManager   - <code>ensemble</code>: AigiseEnsembleManager</p>"},{"location":"Aigise-Web-Entry/#33-load-agent-and-collect-dependencies","title":"3.3 Load Agent and Collect Dependencies","text":"<p><pre><code>mk_agent = _load_mk_agent_from_dir(agent_dir)\ndummy_agent = mk_agent(aigise_session_id=session_id)\nsandbox_dependencies = collect_sandbox_dependencies(dummy_agent)\n</code></pre> - Dynamically imports <code>agent.py</code> from the agent directory - Extracts the <code>mk_agent</code> function - Creates a dummy agent instance to analyze dependencies - Collects which sandbox types the agent requires (e.g., <code>{\"main\", \"joern\", \"neo4j\"}</code>)</p>"},{"location":"Aigise-Web-Entry/#34-prune-unused-sandboxes","title":"3.4 Prune Unused Sandboxes","text":"<ul> <li>Compares required sandboxes with configured sandboxes</li> <li>Removes sandbox configurations that are not needed</li> <li>Example: If agent only needs <code>{\"main\", \"joern\"}</code>, removes <code>gdb_mcp</code>, <code>pdb_mcp</code>, etc.</li> <li>This optimizes startup time by not launching unnecessary containers</li> </ul>"},{"location":"Aigise-Web-Entry/#35-initialize-shared-volumes","title":"3.5 Initialize Shared Volumes","text":"<p><pre><code>aigise_session.sandboxes.initialize_shared_volumes()\n</code></pre> - Creates Docker volumes for shared data:   - <code>scripts_volume</code>: Read-only scripts and tools   - <code>data_volume</code>: Read-write data directory - Configures volume mounts for all sandbox containers - Volumes are shared across all sandboxes in the session</p>"},{"location":"Aigise-Web-Entry/#36-launch-sandbox-containers","title":"3.6 Launch Sandbox Containers","text":"<p><pre><code>await aigise_session.sandboxes.launch_all_sandboxes()\n</code></pre> For each required sandbox type: 1. Gets sandbox configuration from <code>session.config.sandbox.sandboxes[sandbox_type]</code> 2. Creates Docker container (or connects to existing one) 3. Sets up network, volumes, environment variables 4. Starts the container 5. Stores sandbox instance in <code>session.sandboxes._sandboxes[sandbox_type]</code></p>"},{"location":"Aigise-Web-Entry/#37-initialize-sandboxes","title":"3.7 Initialize Sandboxes","text":"<p><pre><code>await aigise_session.sandboxes.initialize_all_sandboxes(continue_on_error=True)\n</code></pre> For each sandbox: 1. Finds the appropriate initializer (e.g., <code>JoernInitializer</code>, <code>FuzzInitializer</code>) 2. Calls <code>async_initialize()</code> method:    - Installs tools and dependencies    - Sets up environment    - Prepares resources    - Example: Joern initializer runs CPG generation scripts 3. Marks sandbox as ready 4. Continues even if one sandbox fails (due to <code>continue_on_error=True</code>)</p>"},{"location":"Aigise-Web-Entry/#step-4-load-agent","title":"Step 4: Load Agent","text":"<pre><code>mk_agent = _load_mk_agent_from_dir(agent_dir)\nroot_agent = mk_agent(aigise_session_id=session_id)\n</code></pre> <ol> <li>Imports agent module again (ensuring latest code)</li> <li>Calls <code>mk_agent()</code> with the session ID</li> <li>Agent constructor:</li> <li>Gets session via <code>get_aigise_session(session_id)</code></li> <li>Loads dynamic tools from filesystem (if using <code>AigiseAgent</code>)</li> <li>Sets up tool combos, sub-agents, etc.</li> <li>Returns configured agent instance</li> </ol>"},{"location":"Aigise-Web-Entry/#step-5-load-plugins","title":"Step 5: Load Plugins","text":"<pre><code>enabled_plugins = aigise_session.config.plugins.enabled or []\nplugins = load_plugins(enabled_plugins)\n</code></pre> <ol> <li>Reads plugin list from configuration</li> <li>Loads plugin classes dynamically</li> <li>Instantiates plugin objects</li> <li>Returns list of plugin instances</li> </ol>"},{"location":"Aigise-Web-Entry/#step-6-create-adk-services","title":"Step 6: Create ADK Services","text":"<pre><code>session_service = AigiseInMemorySessionService()\nartifact_service = InMemoryArtifactService()\nmemory_service = InMemoryMemoryService()\ncredential_service = InMemoryCredentialService()\neval_sets_manager = LocalEvalSetsManager(agents_dir=agents_dir_parent)\neval_set_results_manager = LocalEvalSetResultsManager(agents_dir=agents_dir_parent)\n</code></pre> <ul> <li>Creates in-memory services for ADK integration</li> <li><code>AigiseInMemorySessionService</code> bridges ADK sessions with SAGE-X sessions</li> <li>Other services are standard ADK in-memory implementations</li> </ul>"},{"location":"Aigise-Web-Entry/#step-7-determine-app-name","title":"Step 7: Determine App Name","text":"<pre><code>app_name = os.path.basename(os.path.dirname(agent_dir.rstrip(os.sep)))\n</code></pre> <ul> <li>Extracts parent directory name as app name</li> <li>Example: <code>/path/to/examples/agents/my_agent</code> \u2192 <code>app_name = \"agents\"</code></li> </ul>"},{"location":"Aigise-Web-Entry/#step-8-create-web-server","title":"Step 8: Create Web Server","text":"<pre><code>web_server = AigiseWebServer(\n    app_name=app_name,\n    root_agent=root_agent,\n    fixed_session_id=session_id,\n    session_service=session_service,\n    artifact_service=artifact_service,\n    memory_service=memory_service,\n    credential_service=credential_service,\n    eval_sets_manager=eval_sets_manager,\n    eval_set_results_manager=eval_set_results_manager,\n    plugins=plugins,\n)\n</code></pre> <ul> <li>Creates <code>AigiseWebServer</code> instance</li> <li>Configures all services and agent</li> <li>Sets up FastAPI endpoints for:</li> <li>Agent execution (<code>/run</code>)</li> <li>Server-Sent Events (<code>/events</code>)</li> <li>Live streaming (<code>/live</code>)</li> <li>Session management</li> <li>Artifact access</li> <li>Dev UI static files</li> </ul>"},{"location":"Aigise-Web-Entry/#step-9-pre-create-adk-session","title":"Step 9: Pre-create ADK Session","text":"<pre><code>await session_service.create_session(\n    app_name=web_server.app_name,\n    user_id=\"user\",\n    state={\"aigise_session_id\": session_id},\n    session_id=session_id,\n)\n</code></pre> <ul> <li>Creates ADK session that maps to SAGE-X session</li> <li>Stores <code>aigise_session_id</code> in session state</li> <li>This allows ADK Runner to find the SAGE-X session</li> </ul>"},{"location":"Aigise-Web-Entry/#step-10-create-fastapi-app","title":"Step 10: Create FastAPI App","text":"<pre><code>app = web_server.get_fast_api_app(allow_origins=None, enable_dev_ui=True)\n</code></pre> <ul> <li>Generates FastAPI application with all routes</li> <li>Enables CORS middleware</li> <li>Mounts static files for Dev UI</li> <li>Sets up WebSocket endpoints</li> </ul>"},{"location":"Aigise-Web-Entry/#step-11-start-uvicorn-server","title":"Step 11: Start Uvicorn Server","text":"<pre><code>config = uvicorn.Config(app, host=host, port=port, reload=reload, log_level=log_level.lower())\nserver = uvicorn.Server(config)\nserver.run()\n</code></pre> <ul> <li>Configures Uvicorn ASGI server</li> <li>Starts server on specified host/port</li> <li>If <code>reload=True</code>, watches for code changes and restarts</li> <li>Server runs until interrupted (Ctrl+C)</li> </ul>"},{"location":"Aigise-Web-Entry/#user-interaction-flow","title":"User Interaction Flow","text":"<p>Once the server is running:</p> <ol> <li>User opens browser to <code>http://localhost:8000</code></li> <li>Dev UI loads and connects to backend</li> <li>User types a message in the chat interface</li> <li>Frontend sends POST request to <code>/run</code> endpoint</li> <li>Web server creates ADK Runner with the agent</li> <li>Runner executes agent with user message</li> <li>Events are streamed back via Server-Sent Events</li> <li>Frontend displays agent responses in real-time</li> <li>User can continue conversation or start new session</li> </ol>"},{"location":"Aigise-Web-Entry/#key-differences-from-evaluation","title":"Key Differences from Evaluation","text":"<ul> <li>Single session: One SAGE-X session for the entire web server</li> <li>Interactive: User can send multiple messages</li> <li>Real-time: Events streamed as they happen</li> <li>Development-focused: Hot reload, debugging tools, Dev UI</li> <li>Long-lived: Server runs until manually stopped</li> </ul>"},{"location":"Aigise-Web-Entry/#cleanup","title":"Cleanup","text":"<p>When server stops (Ctrl+C): 1. Signal handler calls <code>cleanup_all_sessions()</code> 2. All sandbox containers are stopped 3. Shared volumes are cleaned up (if configured) 4. Session registry is cleared</p>"},{"location":"Aigise-Web-Entry/#related-topics","title":"Related Topics","text":"<ul> <li>Core Concepts - Understanding sessions and sandboxes</li> <li>Development Guides - How to develop agents</li> <li>Testing Debugging - Debugging with web UI</li> </ul>"},{"location":"Architecture/","title":"Architecture Overview","text":""},{"location":"Architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Session Isolation: Each session has its own resources (sandboxes, configs, agents)</li> <li>No Global Singletons: All resources are session-bound</li> <li>Composability: Build complex agents from simple components</li> <li>Tool Integration: Seamless integration with security analysis tools</li> <li>Extensibility: Easy to add new tools, sandboxes, and agents</li> </ol>"},{"location":"Architecture/#component-relationships","title":"Component Relationships","text":"<ul> <li>AigiseSession is the central manager that coordinates all resources</li> <li>AigiseAgent extends ADK agents with self-programming capabilities</li> <li>Sandboxes provide isolated execution environments</li> <li>Configuration is TOML-based with template variables</li> <li>Tools are dynamically loaded and session-aware</li> </ul>"},{"location":"Architecture/#see-also","title":"See Also","text":"<ul> <li>Core Components - Detailed component descriptions</li> <li>Core Concepts - Core concepts explained</li> <li>Project Structure - Code organization</li> </ul>"},{"location":"Best-Practices/","title":"Best Practices","text":""},{"location":"Best-Practices/#session-management","title":"Session Management","text":"<ul> <li>\u2705 Always use <code>get_aigise_session()</code> instead of creating sessions directly</li> <li>\u2705 Clean up sessions when done: <code>cleanup_aigise_session(session_id)</code></li> <li>\u2705 Use unique session IDs for different runs</li> </ul>"},{"location":"Best-Practices/#agent-development","title":"Agent Development","text":"<ul> <li>\u2705 Keep agents focused on single responsibilities</li> <li>\u2705 Use sub-agents for complex workflows</li> <li>\u2705 Leverage tool combos for related tool groups</li> <li>\u2705 Document tool parameters and return values</li> </ul>"},{"location":"Best-Practices/#tool-development","title":"Tool Development","text":""},{"location":"Best-Practices/#agent-skills-bash-scripts","title":"Agent Skills (Bash Scripts)","text":"<ul> <li>\u2705 Create structured directory with <code>SKILL.md</code> and <code>scripts/</code> subdirectory</li> <li>\u2705 Document all parameters in <code>SKILL.md</code> with types and descriptions</li> <li>\u2705 Specify sandbox requirements in <code>## Requires Sandbox</code> section</li> <li>\u2705 Return JSON output for structured results</li> <li>\u2705 Use proper exit codes (0 for success, non-zero for errors)</li> <li>\u2705 Handle errors gracefully with informative JSON error messages</li> <li>\u2705 Use positional and named parameters appropriately</li> <li>\u2705 Set appropriate timeout values</li> </ul>"},{"location":"Best-Practices/#mcp-toolsets","title":"MCP Toolsets","text":"<ul> <li>\u2705 Use <code>@safe_tool_execution</code> decorator</li> <li>\u2705 Use <code>@requires_sandbox</code> to specify required sandbox types</li> <li>\u2705 Return <code>MCPToolset</code> instances from getter functions</li> <li>\u2705 Document connection parameters and usage</li> </ul>"},{"location":"Best-Practices/#configuration","title":"Configuration","text":"<ul> <li>\u2705 Use template variables for environment-specific values</li> <li>\u2705 Document configuration options</li> <li>\u2705 Validate configuration in initialization</li> <li>\u2705 Provide sensible defaults</li> </ul>"},{"location":"Best-Practices/#code-organization","title":"Code Organization","text":"<ul> <li>\u2705 Follow existing module structure</li> <li>\u2705 Use relative imports in source code</li> <li>\u2705 Use absolute imports in tests</li> <li>\u2705 Add docstrings to public APIs</li> </ul>"},{"location":"Best-Practices/#see-also","title":"See Also","text":"<ul> <li>Common Patterns - Common code patterns</li> <li>Contributing - Contribution guidelines</li> </ul>"},{"location":"CHANGES/","title":"Documentation Changes","text":"<p>This file summarizes significant changes to the SAGE-X documentation.</p>"},{"location":"CHANGES/#latest-updates","title":"Latest Updates","text":""},{"location":"CHANGES/#introductionmd-enhanced-selling-points-and-design-philosophy","title":"Introduction.md - Enhanced Selling Points and Design Philosophy","text":"<p>Date: Current update</p> <p>Changes Made:</p> <ol> <li>Expanded AI-Written Tools Section:</li> <li>Added detailed explanation of tools as \"first-class system entities\"</li> <li>Clarified the distinction between traditional tools and SAGE-X's programmatic tools</li> <li> <p>Added design value propositions</p> </li> <li> <p>Enhanced Runtime Sub-Agents Section:</p> </li> <li>Added sub-agent positioning examples (Debugger, Retrieval, Fuzzer, Memory agents)</li> <li>Expanded on agent topology and dynamic graph concepts</li> <li> <p>Clarified agent ensemble capabilities</p> </li> <li> <p>Added System-Level Workflow Section (NEW - Planned Feature):</p> </li> <li>Rule-based execution model</li> <li>Graph-based scheduling</li> <li>Pub-sub event-driven coordination</li> <li> <p>Note: Feature is planned, placeholder documentation created</p> </li> <li> <p>Added Memory as Manageable System Resource Section (NEW - Planned Feature):</p> </li> <li>Layered memory model</li> <li>Graph-structured memory</li> <li>Memory agent concept</li> <li> <p>Note: Feature is planned, placeholder documentation created</p> </li> <li> <p>Enhanced Training Support Section:</p> </li> <li>Expanded Kubernetes-based rapid rollout details</li> <li>Enhanced integration details for AREL, VERL, and LLaMA Factory</li> <li> <p>Added rationale for why SAGE-X works well for training</p> </li> <li> <p>Enhanced Security-Focused Customization Section:</p> </li> <li>Renamed to \"Security-Focused System-Level Customization\"</li> <li>Added more detailed capabilities</li> <li> <p>Emphasized the system-level nature of customization</p> </li> <li> <p>Updated Key Features List:</p> </li> <li>Added planned features with notes</li> <li>Reorganized to match the selling points structure</li> </ol>"},{"location":"CHANGES/#new-files-created","title":"New Files Created","text":"<ol> <li>System-Workflow.md:</li> <li>Placeholder documentation for planned system-level workflow feature</li> <li>Includes planned features: rule-based execution, graph-based scheduling, pub-sub events</li> <li> <p>Status: Planned/Under Development</p> </li> <li> <p>Memory-System.md:</p> </li> <li>Placeholder documentation for planned memory system features</li> <li>Includes: layered memory, graph-structured memory, memory agent</li> <li> <p>Status: Planned/Under Development</p> </li> <li> <p>_Sidebar.md:</p> </li> <li>Updated to include links to new System-Workflow and Memory-System pages</li> </ol>"},{"location":"CHANGES/#previous-updates","title":"Previous Updates","text":""},{"location":"CHANGES/#project-name-change-aigise-sage-x","title":"Project Name Change: AIgiSE \u2192 SAGE-X","text":"<p>All documentation was updated to reflect the project name change from \"AIgiSE\" to \"SAGE-X\" (Self-programming Agent Generation Engine: Next Generation).</p> <p>Note: Code paths and package names remain as <code>aigise</code> for functional reasons.</p>"},{"location":"Common-Patterns/","title":"Common Patterns","text":""},{"location":"Common-Patterns/#pattern-agent-skill-bash-script-tool","title":"Pattern: Agent Skill (Bash Script Tool)","text":"<p>Agent Skills are bash scripts organized in a structured format with <code>SKILL.md</code> metadata:</p> <pre><code>src/aigise/bash_tools/\n\u2514\u2500\u2500 category/\n    \u2514\u2500\u2500 tool-name/\n        \u251c\u2500\u2500 SKILL.md\n        \u2514\u2500\u2500 scripts/\n            \u2514\u2500\u2500 tool_script.sh\n</code></pre> <p>SKILL.md example:</p> <pre><code>---\nname: my-tool\ndescription: Tool description\n---\n\n# My Tool\n\n## Parameters\n\n### input (required, positional position 0)\n\n**Type**: `str`\n\nInput parameter description.\n\n### --option (optional, named parameter)\n\n**Type**: `str`\n\nOption description.\n\n## Requires Sandbox\n\nmain\n\n## Timeout\n\n60 seconds\n</code></pre> <p>Bash script example:</p> <pre><code>#!/bin/bash\n\nINPUT=\"$1\"\nOPTION=\"\"\n\n# Parse named parameters\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --option)\n            OPTION=\"$2\"\n            shift 2\n            ;;\n        *)\n            shift\n            ;;\n    esac\ndone\n\n# Tool logic\nRESULT=$(process \"$INPUT\" \"$OPTION\")\n\n# Return JSON\necho \"{\\\"success\\\": true, \\\"result\\\": \\\"$RESULT\\\"}\"\n</code></pre>"},{"location":"Common-Patterns/#pattern-multi-sandbox-skill","title":"Pattern: Multi-Sandbox Skill","text":"<p>For tools that require multiple sandboxes, specify in <code>SKILL.md</code>:</p> <pre><code>## Requires Sandbox\n\nmain, joern\n</code></pre> <p>The framework automatically ensures both sandboxes are available before executing the tool.</p>"},{"location":"Common-Patterns/#pattern-mcp-toolset","title":"Pattern: MCP Toolset","text":"<p>MCP toolsets provide integration with external services:</p> <pre><code>from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset, SseConnectionParams\nfrom aigise.toolbox.decorators import requires_sandbox, safe_tool_execution\nfrom aigise.utils.agent_utils import get_mcp_url_from_session_id\n\n@safe_tool_execution\n@requires_sandbox(\"gdb_mcp\")\ndef get_gdb_toolset(aigise_session_id: str) -&gt; MCPToolset:\n    \"\"\"Create MCPToolset for GDB debugging.\"\"\"\n    url = get_mcp_url_from_session_id(\"gdb_mcp\", aigise_session_id)\n    return MCPToolset(connection_params=SseConnectionParams(url=url))\n</code></pre>"},{"location":"Common-Patterns/#pattern-dynamic-tool-discovery","title":"Pattern: Dynamic Tool Discovery","text":"<p>Tools are automatically discovered from: - <code>src/aigise/bash_tools/</code> (built-in tools) - <code>~/.local/plugins/aigise/tools/</code> (user plugins)</p> <p>The framework scans for <code>SKILL.md</code> files and loads them automatically. No manual registration needed.</p>"},{"location":"Common-Patterns/#pattern-agent-composition","title":"Pattern: Agent Composition","text":"<pre><code>def mk_agent(aigise_session_id: str) -&gt; AigiseAgent:\n    sub_agent = AigiseAgent(...)\n    sub_agent_tool = AgentTool(agent=sub_agent)\n\n    root_agent = AigiseAgent(\n        tools=[sub_agent_tool, ...],\n        sub_agents=[...]\n    )\n    return root_agent\n</code></pre>"},{"location":"Common-Patterns/#pattern-code-understanding-agent-with-memory-caching","title":"Pattern: Code Understanding Agent with Memory Caching","text":"<p>The Code Understanding Agent is a utility agent that caches question-answer pairs in Neo4j to avoid redundant computation. It can be used as a tool by other agents.</p> <p>Basic Usage:</p> <pre><code>from examples.agents.code_understanding_agent import create_code_understanding_agent_tool\nfrom google.adk.models import BaseLlm, Gemini\nfrom aigise.agents.aigise_agent import AigiseAgent\n\n# Create code understanding agent tool\ncode_tool = create_code_understanding_agent_tool(\n    model=Gemini(model=\"gemini-2.5-flash\"),\n    name=\"code_understanding_agent\",\n)\n\n# Use in another agent\norchestrator = AigiseAgent(\n    name=\"orchestrator\",\n    model=Gemini(model=\"gemini-2.5-flash\"),\n    tools=[code_tool, other_tools...],\n)\n</code></pre> <p>How It Works:</p> <ol> <li>Cache Lookup: Before answering a question, the agent first checks for semantically similar cached answers using <code>lookup_similar_answers</code></li> <li>Smart Reuse: If a highly similar answer exists (similarity &gt; 0.85), it reuses the cached answer directly</li> <li>Fresh Analysis: If no similar answer exists, it performs fresh code analysis using available tools</li> <li>Cache Storage: After generating a new answer, it stores it using <code>cache_qa_pair</code> for future use</li> </ol> <p>Available Tools:</p> <ul> <li><code>lookup_similar_answers</code>: Find semantically similar cached Q&amp;A pairs</li> <li><code>cache_qa_pair</code>: Store a new Q&amp;A pair in the cache</li> <li><code>list_cached_questions</code>: Browse cached questions</li> <li><code>get_cached_answer_by_id</code>: Retrieve full answer content by ID</li> <li>Code analysis tools: <code>search_function</code>, <code>grep_tool</code>, <code>list_functions_in_file</code>, etc.</li> </ul> <p>Benefits:</p> <ul> <li>Reduces redundant computation for repeated or similar questions</li> <li>Improves response time for cached queries</li> <li>Maintains context across multiple agent invocations</li> <li>Works seamlessly with Neo4j-based memory system</li> </ul> <p>See <code>examples/agents/code_understanding_agent/README.md</code> for more details.</p>"},{"location":"Common-Patterns/#see-also","title":"See Also","text":"<ul> <li>Best Practices - Best practices</li> <li>Development Guides - Development guides</li> <li>Core Concepts - Core concepts</li> </ul>"},{"location":"Configuration/","title":"Configuration Guide","text":"<p>This document describes the SAGE-X configuration system, including all configuration fields, their purposes, and how to write configuration files.</p>"},{"location":"Configuration/#overview","title":"Overview","text":"<p>SAGE-X uses TOML (Tom's Obvious, Minimal Language) format for configuration files. The configuration system supports:</p> <ul> <li>Template Variables: Use <code>${VAR_NAME}</code> syntax for reusable values</li> <li>Nested Sections: Organize related settings into logical groups</li> <li>Environment Variable Support: Template variables can reference environment variables</li> <li>Type Safety: Automatic conversion to Python dataclasses with type checking</li> </ul>"},{"location":"Configuration/#configuration-file-location","title":"Configuration File Location","text":"<p>Configuration files are loaded in the following order:</p> <ol> <li>Default Configuration: <code>src/aigise/templates/configs/default_config.toml</code> (used when no config is specified)</li> <li>Custom Configuration: Path specified via <code>config_path</code> parameter when creating <code>AigiseSession</code></li> </ol>"},{"location":"Configuration/#configuration-structure","title":"Configuration Structure","text":"<p>The configuration is organized into several main sections:</p> <pre><code># Top-level template variables (optional)\nVARIABLE_NAME = \"value\"\n\n# Root-level fields\ntask_name = \"my_task\"\nsrc_dir_in_sandbox = \"/shared/code\"\ndefault_host = \"127.0.0.1\"\nauto_cleanup = true\n\n# Section-based configuration\n[neo4j]\n# Neo4j database configuration\n\n[sandbox]\n# Sandbox configuration\n\n[llm]\n# LLM model configuration\n\n[history]\n# History and tool response configuration\n\n[plugins]\n# Plugin configuration\n\n[agent_ensemble]\n# Agent ensemble configuration\n\n[build]\n# Build and execution configuration\n\n[mcp]\n# Model Context Protocol services configuration\n</code></pre>"},{"location":"Configuration/#template-variables","title":"Template Variables","text":"<p>SAGE-X supports template variable expansion using <code>${VAR_NAME}</code> syntax.</p>"},{"location":"Configuration/#rules","title":"Rules:","text":"<ol> <li>Top-level UPPERCASE variables automatically become template variables</li> <li>Variables can be referenced anywhere using <code>${VAR_NAME}</code></li> <li>Variables are expanded recursively throughout the configuration</li> <li>Undefined variables cause an error at load time</li> </ol>"},{"location":"Configuration/#example","title":"Example:","text":"<pre><code># Define template variables (UPPERCASE)\nDEFAULT_IMAGE = \"ubuntu:20.04\"\nMAIN_MODEL = \"openai/gpt-4\"\nNEO4J_PASSWORD = \"mypassword123\"\n\n# Use template variables\n[sandbox.sandboxes.main]\nimage = \"${DEFAULT_IMAGE}\"\n\n[llm.model_configs.main]\nmodel_name = \"${MAIN_MODEL}\"\n\n[neo4j]\npassword = \"${NEO4J_PASSWORD}\"\n</code></pre>"},{"location":"Configuration/#configuration-sections","title":"Configuration Sections","text":""},{"location":"Configuration/#root-level-fields","title":"Root-Level Fields","text":"<p>These fields are defined at the top level of the configuration file:</p> Field Type Description Default <code>task_name</code> <code>string</code> Name identifier for the current task/session <code>None</code> <code>src_dir_in_sandbox</code> <code>string</code> Path to source code directory within sandbox containers <code>\"/shared/code\"</code> <code>agent_storage_path</code> <code>string</code> Path where dynamically created agents are stored <code>None</code> <code>default_host</code> <code>string</code> Default hostname for services (used by Neo4j and MCP services) <code>None</code> (falls back to <code>127.0.0.1</code>) <code>auto_cleanup</code> <code>boolean</code> Whether to automatically cleanup resources when session ends <code>true</code> <p>Example:</p> <pre><code>task_name = \"vulnerability_analysis\"\nsrc_dir_in_sandbox = \"/shared/code\"\nagent_storage_path = \"/tmp/agents\"\ndefault_host = \"localhost\"\nauto_cleanup = true\n</code></pre>"},{"location":"Configuration/#neo4j-configuration","title":"Neo4j Configuration","text":"<p>Configures the Neo4j graph database connection.</p> <p>Section: <code>[neo4j]</code></p> Field Type Description Default <code>user</code> <code>string</code> Neo4j username <code>None</code> <code>password</code> <code>string</code> Neo4j password <code>None</code> <code>bolt_port</code> <code>integer</code> Neo4j Bolt protocol port <code>7687</code> <code>neo4j_http_port</code> <code>integer</code> Neo4j HTTP port <code>7474</code> <p>Note: The <code>uri</code> property is dynamically constructed as <code>neo4j://{default_host}:{bolt_port}</code>. If <code>default_host</code> is not set, it defaults to <code>127.0.0.1</code>.</p> <p>Example:</p> <pre><code>[neo4j]\nuser = \"neo4j\"\npassword = \"callgraphn4j!\"\nbolt_port = 7687\nneo4j_http_port = 7474\n</code></pre>"},{"location":"Configuration/#sandbox-configuration","title":"Sandbox Configuration","text":"<p>Configures sandbox environments (Docker containers or Kubernetes pods).</p> <p>Section: <code>[sandbox]</code></p>"},{"location":"Configuration/#top-level-sandbox-settings","title":"Top-Level Sandbox Settings","text":"Field Type Description Default <code>default_image</code> <code>string</code> Default Docker image for sandboxes <code>None</code> <code>backend</code> <code>string</code> Sandbox backend type: <code>\"native\"</code> (Docker) or <code>\"k8s\"</code> (Kubernetes) <code>\"native\"</code> <code>project_relative_shared_data_path</code> <code>string</code> Path relative to project root for shared data (will be mounted as <code>/shared</code> in containers) <code>None</code> <code>absolute_shared_data_path</code> <code>string</code> Absolute path for shared data <code>None</code> <code>tolerations</code> <code>list[dict]</code> Kubernetes tolerations applied to all pods <code>None</code>"},{"location":"Configuration/#per-sandbox-configuration","title":"Per-Sandbox Configuration","text":"<p>Each sandbox type is configured under <code>[sandbox.sandboxes.&lt;sandbox_type&gt;]</code>:</p> <p>Common Sandbox Types: - <code>main</code>: Primary analysis sandbox - <code>joern</code>: Joern static analysis sandbox - <code>codeql</code>: CodeQL analysis sandbox - <code>neo4j</code>: Neo4j database container - <code>gdb_mcp</code>: GDB debugger MCP service - <code>pdb_mcp</code>: PDB debugger MCP service - <code>fuzz</code>: Fuzzing environment</p> <p>Container Configuration Fields:</p> Field Type Description Default <code>image</code> <code>string</code> Docker image name/tag <code>None</code> <code>container_id</code> <code>string</code> Connect to existing container (instead of creating new) <code>None</code> <code>timeout</code> <code>integer</code> Container operation timeout in seconds <code>300</code> <code>project_relative_dockerfile_path</code> <code>string</code> Path to Dockerfile relative to project root <code>None</code> <code>absolute_dockerfile_path</code> <code>string</code> Absolute path to Dockerfile <code>None</code> <code>command</code> <code>string</code> Override container command (empty string = use Dockerfile default, <code>None</code> = use <code>bash</code>) <code>None</code> <code>platform</code> <code>string</code> Platform architecture (e.g., <code>\"linux/amd64\"</code>) <code>None</code> <code>network</code> <code>string</code> Docker network name <code>None</code> <code>privileged</code> <code>boolean</code> Run container in privileged mode <code>false</code> <code>security_opt</code> <code>list[string]</code> Security options <code>[]</code> <code>cap_add</code> <code>list[string]</code> Additional capabilities <code>[]</code> <code>gpus</code> <code>string</code> GPU allocation (e.g., <code>\"all\"</code> or <code>\"device=GPU-UUID\"</code>) <code>None</code> <code>shm_size</code> <code>string</code> Shared memory size (e.g., <code>\"2g\"</code>) <code>None</code> <code>mem_limit</code> <code>string</code> Memory limit (e.g., <code>\"4g\"</code>) <code>None</code> <code>cpus</code> <code>string</code> CPU limit (e.g., <code>\"2\"</code>) <code>None</code> <code>user</code> <code>string</code> User to run as (e.g., <code>\"1000:1000\"</code>) <code>None</code> <code>working_dir</code> <code>string</code> Working directory in container <code>None</code> <p>Build Configuration:</p> Field Type Description <code>build_args</code> <code>dict[string, string]</code> Docker build arguments <code>using_cached</code> <code>boolean</code> Whether to use cached image (internal flag) <p>Environment, Volumes, and Ports:</p> Field Type Description <code>environment</code> <code>dict[string, any]</code> Environment variables <code>volumes</code> <code>list[string]</code> Volume mounts in format <code>\"/host:/container:ro\"</code> <code>mounts</code> <code>list[string]</code> Docker mount specifications <code>ports</code> <code>dict[string, int\\|string]</code> Port mappings in format <code>{\"port/tcp\" = host_port}</code> <code>docker_args</code> <code>list[string]</code> Raw arguments passed through to Docker CLI <p>Extra Configuration:</p> Field Type Description <code>extra</code> <code>dict[string, any]</code> Additional custom configuration (e.g., <code>initializer_timeout_sec</code>) <p>Kubernetes-Specific Fields:</p> Field Type Description <code>pod_name</code> <code>string</code> Connect to existing Pod instead of creating new <code>container_name</code> <code>string</code> Name of container within the Pod <p>Example:</p> <pre><code>[sandbox]\nbackend = \"native\"\nproject_relative_shared_data_path = \"data/my_project.tar.gz\"\n\n[sandbox.sandboxes.main]\nimage = \"ubuntu:20.04\"\nproject_relative_dockerfile_path = \"dockerfiles/main/Dockerfile\"\ntimeout = 300\n\n[sandbox.sandboxes.main.build_args]\nBASE_IMAGE = \"ubuntu:20.04\"\n\n[sandbox.sandboxes.main.environment]\nPYTHONPATH = \"/shared/code\"\n\n[sandbox.sandboxes.main.ports]\n\"8080/tcp\" = 8080\n\n[sandbox.sandboxes.main.extra]\ninitializer_timeout_sec = 1800\n\n[sandbox.sandboxes.joern]\nimage = \"aigise/joern\"\nproject_relative_dockerfile_path = \"dockerfiles/joern/Dockerfile\"\ncommand = \"\"\n\n[sandbox.sandboxes.joern.environment]\nJAVA_OPTS = \"-Xmx16G -Xms4G\"\n\n[sandbox.sandboxes.joern.ports]\n\"8081/tcp\" = 18087\n</code></pre>"},{"location":"Configuration/#llm-configuration","title":"LLM Configuration","text":"<p>Configures language models used by agents.</p> <p>Section: <code>[llm]</code></p> <p>Models are configured under <code>[llm.model_configs.&lt;model_name&gt;]</code>:</p> <p>Common Model Names: - <code>main</code>: Primary model for agent reasoning - <code>summarize</code>: Model for summarization and context compression - <code>flag_claims</code>: Model for flag claims processing</p> <p>Model Configuration Fields:</p> Field Type Description Default <code>model_name</code> <code>string</code> Model identifier (e.g., <code>\"openai/gpt-4\"</code>, <code>\"anthropic/claude-3\"</code>) Required <code>temperature</code> <code>float</code> Sampling temperature (0.0-2.0) <code>None</code> <code>max_tokens</code> <code>integer</code> Maximum tokens in response <code>None</code> <code>rpm</code> <code>integer</code> Rate limit: requests per minute <code>None</code> <code>tpm</code> <code>integer</code> Rate limit: tokens per minute <code>None</code> <p>Example:</p> <pre><code>[llm]\n\n[llm.model_configs.main]\nmodel_name = \"openai/gpt-4\"\ntemperature = 0.7\nmax_tokens = 4096\nrpm = 60\ntpm = 60000\n\n[llm.model_configs.summarize]\nmodel_name = \"openai/gpt-3.5-turbo\"\ntemperature = 0.3\nmax_tokens = 2048\nrpm = 30\ntpm = 30000\n</code></pre>"},{"location":"Configuration/#history-configuration","title":"History Configuration","text":"<p>Configures tool response handling and event history management.</p> <p>Section: <code>[history]</code></p> Field Type Description Default <code>max_tool_response_length</code> <code>integer</code> Maximum length of a single tool response before special handling <code>10000</code> <code>enable_quota_countdown</code> <code>boolean</code> Show remaining LLM call quota after each tool response <code>false</code> <p>Events Compaction Configuration:</p> <p>Section: <code>[history.events_compaction]</code></p> Field Type Description Default <code>max_history_summary_length</code> <code>integer</code> Character budget threshold for triggering compaction <code>100000</code> <code>compaction_percent</code> <code>integer</code> Percentage of history to compress (0-100) <code>50</code> <p>Example:</p> <pre><code>[history]\nmax_tool_response_length = 10000\nenable_quota_countdown = true\n\n[history.events_compaction]\nmax_history_summary_length = 100000\ncompaction_percent = 50\n</code></pre>"},{"location":"Configuration/#plugins-configuration","title":"Plugins Configuration","text":"<p>Configures which plugins are enabled.</p> <p>Section: <code>[plugins]</code></p> Field Type Description Default <code>enabled</code> <code>list[string]</code> List of enabled plugin names <code>[]</code> <p>Common Plugins: - <code>history_summarizer_plugin</code>: Summarizes long conversation history - <code>tool_response_summarizer_plugin</code>: Summarizes long tool responses - <code>quota_after_tool_plugin</code>: Shows quota countdown after tools</p> <p>Example:</p> <pre><code>[plugins]\nenabled = [\n    \"history_summarizer_plugin\",\n    \"tool_response_summarizer_plugin\",\n    \"quota_after_tool_plugin\",\n]\n</code></pre>"},{"location":"Configuration/#agent-ensemble-configuration","title":"Agent Ensemble Configuration","text":"<p>Configures multi-agent ensemble execution.</p> <p>Section: <code>[agent_ensemble]</code></p> Field Type Description Default <code>thread_safe_tools</code> <code>list[string]</code> List of tool names that are thread-safe (can be called in parallel) <code>[]</code> <code>available_models_for_ensemble</code> <code>list[string]</code> or <code>string</code> List of model names available for ensemble (can be comma-separated string) <code>[]</code> <p>Example:</p> <pre><code>[agent_ensemble]\nthread_safe_tools = [\"google_search\", \"read_file\"]\navailable_models_for_ensemble = [\"openai/gpt-4\", \"anthropic/claude-3\"]\n</code></pre> <p>Or as comma-separated string:</p> <pre><code>[agent_ensemble]\nthread_safe_tools = [\"google_search\", \"read_file\"]\navailable_models_for_ensemble = \"openai/gpt-4,anthropic/claude-3\"\n</code></pre>"},{"location":"Configuration/#build-configuration","title":"Build Configuration","text":"<p>Configures build and execution commands for target programs.</p> <p>Section: <code>[build]</code></p> Field Type Description Default <code>poc_dir</code> <code>string</code> Directory path for proof-of-concept code <code>None</code> <code>compile_command</code> <code>string</code> Command to compile the target program <code>None</code> <code>run_command</code> <code>string</code> Command to run the target program <code>None</code> <code>target_type</code> <code>string</code> Type of target (e.g., <code>\"default\"</code>, <code>\"binary\"</code>) <code>None</code> <code>target_binary</code> <code>string</code> Path to target binary <code>None</code> <p>Example:</p> <pre><code>[build]\npoc_dir = \"/tmp/poc\"\ncompile_command = \"gcc -o target target.c\"\nrun_command = \"./target\"\ntarget_type = \"binary\"\ntarget_binary = \"/tmp/poc/target\"\n</code></pre>"},{"location":"Configuration/#mcp-configuration","title":"MCP Configuration","text":"<p>Configures Model Context Protocol (MCP) services.</p> <p>Section: <code>[mcp]</code></p> <p>MCP services are configured under <code>[mcp.services.&lt;service_name&gt;]</code>:</p> <p>Common Service Names: - <code>gdb_mcp</code>: GDB debugger MCP service - <code>pdb_mcp</code>: PDB debugger MCP service</p> <p>MCP Service Configuration Fields:</p> Field Type Description <code>sse_port</code> <code>integer</code> Server-Sent Events (SSE) server port <code>sse_host</code> <code>string</code> SSE server host (if <code>None</code>, uses <code>default_host</code> from root config) <p>Note: The <code>sse_host</code> property dynamically uses <code>default_host</code> from the root configuration if not explicitly set.</p> <p>Example:</p> <pre><code>[mcp]\n\n[mcp.services.gdb_mcp]\nsse_port = 1111\n\n[mcp.services.pdb_mcp]\nsse_port = 1112\nsse_host = \"localhost\"  # Optional, defaults to root config's default_host\n</code></pre>"},{"location":"Configuration/#complete-example","title":"Complete Example","text":"<p>Here's a complete configuration file example:</p> <pre><code># Template Variables\nDEFAULT_IMAGE = \"ubuntu:20.04\"\nMAIN_MODEL = \"openai/gpt-4\"\nNEO4J_PASSWORD = \"secure_password\"\nTASK_NAME = \"security_analysis\"\n\n# Root Configuration\ntask_name = \"${TASK_NAME}\"\nsrc_dir_in_sandbox = \"/shared/code\"\ndefault_host = \"localhost\"\nauto_cleanup = true\n\n# Neo4j Configuration\n[neo4j]\nuser = \"neo4j\"\npassword = \"${NEO4J_PASSWORD}\"\nbolt_port = 7687\nneo4j_http_port = 7474\n\n# Sandbox Configuration\n[sandbox]\nbackend = \"native\"\nproject_relative_shared_data_path = \"data/project.tar.gz\"\n\n[sandbox.sandboxes.main]\nimage = \"${DEFAULT_IMAGE}\"\nproject_relative_dockerfile_path = \"dockerfiles/main/Dockerfile\"\ntimeout = 300\n\n[sandbox.sandboxes.main.environment]\nPYTHONPATH = \"/shared/code\"\n\n[sandbox.sandboxes.joern]\nimage = \"aigise/joern\"\nproject_relative_dockerfile_path = \"dockerfiles/joern/Dockerfile\"\ncommand = \"\"\n\n[sandbox.sandboxes.joern.ports]\n\"8081/tcp\" = 18087\n\n# LLM Configuration\n[llm]\n\n[llm.model_configs.main]\nmodel_name = \"${MAIN_MODEL}\"\ntemperature = 0.7\nmax_tokens = 4096\n\n[llm.model_configs.summarize]\nmodel_name = \"${MAIN_MODEL}\"\ntemperature = 0.3\nmax_tokens = 2048\n\n# History Configuration\n[history]\nmax_tool_response_length = 10000\nenable_quota_countdown = true\n\n[history.events_compaction]\nmax_history_summary_length = 100000\ncompaction_percent = 50\n\n# Plugins Configuration\n[plugins]\nenabled = [\n    \"history_summarizer_plugin\",\n    \"tool_response_summarizer_plugin\",\n]\n\n# Agent Ensemble Configuration\n[agent_ensemble]\nthread_safe_tools = [\"google_search\"]\navailable_models_for_ensemble = \"${MAIN_MODEL}\"\n\n# Build Configuration\n[build]\ncompile_command = \"make\"\nrun_command = \"./target\"\n\n# MCP Configuration\n[mcp]\n\n[mcp.services.gdb_mcp]\nsse_port = 1111\n</code></pre>"},{"location":"Configuration/#loading-configuration-in-code","title":"Loading Configuration in Code","text":""},{"location":"Configuration/#using-default-configuration","title":"Using Default Configuration","text":"<pre><code>from aigise.session import AigiseSession\n\n# Uses default config from src/aigise/templates/configs/default_config.toml\nsession = AigiseSession(aigise_session_id=\"my_session\")\n</code></pre>"},{"location":"Configuration/#using-custom-configuration","title":"Using Custom Configuration","text":"<pre><code>from aigise.session import AigiseSession\n\n# Load custom configuration file\nsession = AigiseSession(\n    aigise_session_id=\"my_session\",\n    config_path=\"/path/to/my_config.toml\"\n)\n</code></pre>"},{"location":"Configuration/#accessing-configuration","title":"Accessing Configuration","text":"<pre><code># Access configuration through session\nconfig = session.config\n\n# Access specific sections\nneo4j_config = config.neo4j\nsandbox_config = config.sandbox\nllm_config = config.llm\n\n# Access nested configurations\nmain_sandbox = config.get_sandbox_config(\"main\")\nmain_model = config.get_llm_config(\"main\")\n</code></pre>"},{"location":"Configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Use Template Variables: Define reusable values as UPPERCASE template variables at the top</li> <li>Organize by Section: Group related settings into logical sections</li> <li>Document Custom Fields: Add comments for non-standard or custom configuration</li> <li>Version Control: Keep configuration files in version control, but exclude sensitive values (passwords, API keys)</li> <li>Environment-Specific Configs: Create separate config files for development, testing, and production</li> <li>Validate Early: Test configuration files before deploying to catch errors early</li> </ol>"},{"location":"Configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Configuration/#template-variable-not-found","title":"Template Variable Not Found","text":"<p>If you see <code>KeyError: Template variable 'VAR_NAME' not found</code>, ensure: - The variable is defined as an UPPERCASE top-level variable - The variable name matches exactly (case-sensitive) - There are no typos in <code>${VAR_NAME}</code> references</p>"},{"location":"Configuration/#configuration-not-loading","title":"Configuration Not Loading","text":"<ul> <li>Verify the TOML file syntax is correct</li> <li>Check file path is correct (use absolute paths if relative paths don't work)</li> <li>Ensure all required fields are present (check error messages)</li> </ul>"},{"location":"Configuration/#dynamic-host-resolution","title":"Dynamic Host Resolution","text":"<p>If <code>default_host</code> is not set, services like Neo4j and MCP will default to <code>127.0.0.1</code>. Set <code>default_host</code> at the root level for Kubernetes deployments or remote services.</p>"},{"location":"Configuration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Getting Started - Initial setup guide</li> <li>Architecture - System architecture overview</li> <li>Core Concepts - Core concepts including sessions</li> <li>Adding Sandboxes - Guide to adding new sandbox types</li> </ul>"},{"location":"Contributing/","title":"Contributing Guidelines","text":""},{"location":"Contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow Google Python Style Guide</li> <li>Use <code>pyink</code> for formatting</li> <li>Use <code>isort</code> for import sorting</li> <li>Run <code>autoformat.sh</code> before committing</li> </ul>"},{"location":"Contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow Conventional Commits format:</p> <pre><code>feat(component): Description\nfix(component): Description\nrefactor(component): Description\n</code></pre>"},{"location":"Contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create feature branch</li> <li>Make changes with tests</li> <li>Run tests and linting</li> <li>Update documentation</li> <li>Submit PR with description</li> </ol>"},{"location":"Contributing/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>Add tests for new features</li> <li>Maintain or improve coverage</li> <li>Test with multiple sandbox types</li> <li>Test error cases</li> </ul>"},{"location":"Contributing/#documentation","title":"Documentation","text":"<ul> <li>Update relevant documentation</li> <li>Add code examples where helpful</li> <li>Keep wiki pages updated</li> </ul>"},{"location":"Contributing/#see-also","title":"See Also","text":"<ul> <li>Best Practices - Development best practices</li> <li>Development Guides - How to extend the framework</li> </ul>"},{"location":"Core-Components/","title":"Core Components","text":"<p>SAGE-X core components (Note: code uses <code>aigise</code> package name for compatibility).</p>"},{"location":"Core-Components/#1-aigisesession","title":"1. AigiseSession","text":"<p>The central manager for all session-specific resources.</p> <p>Key Responsibilities: - Configuration management (TOML loading, env overrides) - Agent lifecycle (creation, persistence, cleanup) - Sandbox management (Docker containers, resource isolation) - Neo4j client management - Agent ensemble coordination</p> <p>Key Files: - <code>src/aigise/session/aigise_session.py</code> - <code>src/aigise/session/aigise_dynamic_agent_manager.py</code> - <code>src/aigise/session/aigise_sandbox_manager.py</code></p>"},{"location":"Core-Components/#2-aigiseagent","title":"2. AigiseAgent","text":"<p>Extended ADK agent with security-focused features.</p> <p>Key Features: - Dynamic tool loading from filesystem - Integration with sandbox environments - Tool combo support - Session-aware tool execution</p> <p>Key Files: - <code>src/aigise/agents/aigise_agent.py</code></p>"},{"location":"Core-Components/#3-sandbox-system","title":"3. Sandbox System","text":"<p>Isolated execution environments for security analysis.</p> <p>Sandbox Types: - <code>main</code>: Primary analysis sandbox - <code>joern</code>: Static analysis (CPG generation) - <code>codeql</code>: CodeQL analysis - <code>neo4j</code>: Graph database for CPG storage - <code>gdb_mcp</code>: Debugger integration - <code>fuzz</code>: Fuzzing environment</p> <p>Key Files: - <code>src/aigise/sandbox/base_sandbox.py</code> - <code>src/aigise/sandbox/native_docker_sandbox.py</code> - <code>src/aigise/sandbox/k8s_sandbox.py</code> - <code>src/aigise/sandbox/initializers/</code></p>"},{"location":"Core-Components/#4-configuration-system","title":"4. Configuration System","text":"<p>TOML-based configuration with template variable expansion.</p> <p>Key Files: - <code>src/aigise/config/config_dataclass.py</code> - <code>src/aigise/templates/configs/default_config.toml</code></p>"},{"location":"Core-Components/#5-toolbox","title":"5. Toolbox","text":"<p>Collection of security analysis tools.</p> <p>Tool Categories: - Static Analysis: Joern, CodeQL queries - Dynamic Analysis: Fuzzing, debugging - Coverage: LLVM coverage tools - Retrieval: Code search and symbol lookup - Evaluation: PoC submission and validation</p> <p>Key Files: - <code>src/aigise/toolbox/</code></p>"},{"location":"Core-Components/#related-topics","title":"Related Topics","text":"<ul> <li>Core Concepts - Understanding how components work together</li> <li>Architecture - System architecture overview</li> <li>Development Guides - How to extend components</li> </ul>"},{"location":"Core-Concepts/","title":"Core Concepts","text":""},{"location":"Core-Concepts/#session-management","title":"Session Management","text":"<p>Every operation in SAGE-X is scoped to a session. Sessions provide: - Resource isolation - Configuration management - Lifecycle management</p> <pre><code>from aigise import get_aigise_session\n\nsession = get_aigise_session(\"my_session_id\", config_path=\"config.toml\")\n</code></pre>"},{"location":"Core-Concepts/#agent-creation","title":"Agent Creation","text":"<p>Agents are created through <code>mk_agent</code> functions:</p> <pre><code>def mk_agent(aigise_session_id: str) -&gt; AigiseAgent:\n    session = get_aigise_session(aigise_session_id)\n    # ... configure agent ...\n    return AigiseAgent(...)\n</code></pre>"},{"location":"Core-Concepts/#sandbox-lifecycle","title":"Sandbox Lifecycle","text":"<p>Sandboxes are managed through the session:</p> <pre><code>session = get_aigise_session(\"my_session_id\")\nsandbox = session.sandboxes.get_sandbox(\"main\")\nresult = sandbox.run_command_in_container(\"ls /shared\")\n</code></pre>"},{"location":"Core-Concepts/#tool-development","title":"Tool Development","text":"<p>In AIgiSE, tools are implemented as Agent Skills (bash scripts) or MCP toolsets, rather than Python functions. This design provides better isolation and allows tools to run directly in sandbox containers.</p>"},{"location":"Core-Concepts/#agent-skills-bash-scripts","title":"Agent Skills (Bash Scripts)","text":"<p>Agent Skills are bash scripts organized in a structured directory format:</p> <pre><code>src/aigise/bash_tools/\n\u2514\u2500\u2500 category/\n    \u2514\u2500\u2500 tool-name/\n        \u251c\u2500\u2500 SKILL.md          # Metadata and documentation\n        \u2514\u2500\u2500 scripts/\n            \u2514\u2500\u2500 tool_script.sh # Bash implementation\n</code></pre> <p>The <code>SKILL.md</code> file contains: - YAML frontmatter with <code>name</code> and <code>description</code> - Parameter definitions - Sandbox requirements - Usage examples - Return value format</p>"},{"location":"Core-Concepts/#mcp-toolsets","title":"MCP Toolsets","text":"<p>MCP (Model Context Protocol) toolsets provide integration with external services:</p> <pre><code>@safe_tool_execution\n@requires_sandbox(\"gdb_mcp\")\ndef get_toolset(aigise_session_id: str) -&gt; MCPToolset:\n    url = get_mcp_url_from_session_id(\"gdb_mcp\", aigise_session_id)\n    return MCPToolset(connection_params=SseConnectionParams(url=url))\n</code></pre>"},{"location":"Core-Concepts/#automatic-discovery","title":"Automatic Discovery","text":"<p>Tools are automatically discovered from: - <code>src/aigise/bash_tools/</code> (built-in tools) - <code>~/.local/plugins/aigise/tools/</code> (user plugins)</p> <p>No manual registration is required.</p>"},{"location":"Core-Concepts/#configuration","title":"Configuration","text":"<p>Configuration is TOML-based with template variables:</p> <pre><code>src_dir_in_sandbox = \"/shared/code\"\n[sandbox.sandboxes.main]\nimage = \"ubuntu:20.04\"\n</code></pre>"},{"location":"Core-Concepts/#see-also","title":"See Also","text":"<ul> <li>Development Guides - Practical development examples</li> <li>Common Patterns - Common code patterns</li> <li>Best Practices - Best practices</li> </ul>"},{"location":"Development-Guides/","title":"Development Guides","text":"<p>This section covers how to extend SAGE-X with new functionality.</p>"},{"location":"Development-Guides/#guides","title":"Guides","text":"<ul> <li>Adding Tools - How to add new tools</li> <li>Adding Sandboxes - How to add new sandbox types</li> <li>Adding Evaluations - How to add evaluation benchmarks</li> </ul>"},{"location":"Development-Guides/#extending-aigiseagent","title":"Extending AigiseAgent","text":"<p>To add features to AigiseAgent:</p> <ol> <li>Modify <code>src/aigise/agents/aigise_agent.py</code></li> <li>Ensure backward compatibility</li> <li>Add configuration options if needed</li> <li>Update documentation</li> </ol>"},{"location":"Development-Guides/#general-development-workflow","title":"General Development Workflow","text":"<ol> <li>Create feature branch</li> <li>Make changes with tests</li> <li>Run tests and linting</li> <li>Update documentation</li> <li>Submit PR</li> </ol>"},{"location":"Development-Guides/#see-also","title":"See Also","text":"<ul> <li>Best Practices - Best practices for development</li> <li>Common Patterns - Common code patterns</li> <li>Testing Debugging - Testing and debugging guide</li> </ul>"},{"location":"Entry-Points/","title":"Entry Points","text":"<p>SAGE-X has three main entry points for different use cases:</p> <ol> <li>Aigise Web Entry - Interactive web UI for development and debugging</li> <li>Evaluation Entry - Batch evaluation on benchmarks</li> <li>RL Framework Integration - Integration with RL frameworks (slime, verl, areal) for agent training</li> </ol> <p>Each entry point has a different workflow and use case. Click on the links above to see detailed step-by-step workflows.</p>"},{"location":"Entry-Points/#quick-comparison","title":"Quick Comparison","text":"Aspect aigise web Evaluations RL Integration Use Case Development, debugging Performance measurement Agent training Interaction Interactive chat Batch processing Framework API Sessions Single long-lived Multiple short-lived Per-sample sessions Parallelism Single user Multiple tasks Framework-managed Output Real-time events Saved results files Framework samples"},{"location":"Evaluation-Entry/","title":"Evaluations - Batch Processing Entry Point","text":"<p>Evaluation scripts run agents on benchmark datasets for performance measurement and testing.</p>"},{"location":"Evaluation-Entry/#command","title":"Command","text":"<pre><code>cd src/aigise/evaluations\npython cybergym/cybergym_vul_detection.py run \\\n  --agent-id my_agent \\\n  --config-path /path/to/config.toml \\\n  --max_llm_calls 75 \\\n  --use_multiprocessing \\\n  --max_workers 3\n</code></pre>"},{"location":"Evaluation-Entry/#step-by-step-workflow","title":"Step-by-Step Workflow","text":""},{"location":"Evaluation-Entry/#step-1-script-initialization","title":"Step 1: Script Initialization","text":"<ol> <li>Fire library parses command-line arguments</li> <li>Creates <code>Evaluation</code> class instance with parameters:</li> <li><code>agent_id</code>: Identifier for the agent</li> <li><code>config_path</code>: Path to TOML configuration</li> <li><code>max_llm_calls</code>: Maximum LLM calls per task</li> <li><code>use_multiprocessing</code>: Use processes vs threads</li> <li><code>max_workers</code>: Number of parallel workers</li> <li>Sets up logging and instrumentation (Langfuse, OpenTelemetry)</li> </ol>"},{"location":"Evaluation-Entry/#step-2-load-dataset","title":"Step 2: Load Dataset","text":"<pre><code>self.dataset = self._get_dataset()\n</code></pre> <ol> <li>Loads benchmark dataset (e.g., HuggingFace datasets, JSON files)</li> <li>Dataset contains multiple samples/tasks to evaluate</li> <li>Example: CyberGym dataset has vulnerability detection tasks</li> <li>Each sample contains:</li> <li>Task description</li> <li>Expected outputs (ground truth)</li> <li>Metadata (file paths, vulnerability info, etc.)</li> </ol>"},{"location":"Evaluation-Entry/#step-3-prepare-general-environment-_prepare_general_env","title":"Step 3: Prepare General Environment (<code>_prepare_general_env</code>)","text":"<p>This sets up shared resources used across all evaluation tasks.</p>"},{"location":"Evaluation-Entry/#31-create-base-configuration","title":"3.1 Create Base Configuration","text":"<ol> <li>Loads base configuration from TOML file</li> <li>Expands template variables</li> <li>Stores in class for later use</li> </ol>"},{"location":"Evaluation-Entry/#32-setup-evaluation-directories","title":"3.2 Setup Evaluation Directories","text":"<pre><code>self.eval_output_dir = Path(f\"evals/{self.agent_id}/...\")\nself.eval_output_dir.mkdir(parents=True, exist_ok=True)\n</code></pre> <ul> <li>Creates output directories for results</li> <li>Structure: <code>evals/{agent_id}/{benchmark_name}/{timestamp}/</code></li> <li>Stores agent outputs, logs, artifacts</li> </ul>"},{"location":"Evaluation-Entry/#step-4-generate-samples-parallel-execution","title":"Step 4: Generate Samples (Parallel Execution)","text":"<p>The evaluation runs tasks in parallel. Choose one mode:</p>"},{"location":"Evaluation-Entry/#mode-a-multiprocessing-generate","title":"Mode A: Multiprocessing (<code>generate()</code>)","text":"<pre><code>with ProcessPoolExecutor(max_workers=self.max_workers) as executor:\n    futures = {\n        executor.submit(_run_sample_in_process, self, sample): sample\n        for sample in self.dataset\n    }\n</code></pre> <ul> <li>Each sample runs in separate process</li> <li>True parallelism (bypasses Python GIL)</li> <li>Processes are isolated (no shared memory)</li> <li>Requires serializable data</li> </ul>"},{"location":"Evaluation-Entry/#mode-b-multithreading-generate_threaded","title":"Mode B: Multithreading (<code>generate_threaded()</code>)","text":"<pre><code>with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n    futures = {\n        executor.submit(run_sample_in_thread, sample): sample\n        for sample in self.dataset\n    }\n</code></pre> <ul> <li>Each sample runs in separate thread</li> <li>Shared memory (can share resources)</li> <li>Limited by GIL for CPU-bound tasks</li> <li>Better for I/O-bound operations</li> </ul>"},{"location":"Evaluation-Entry/#mode-c-single-thread-generate_single_thread","title":"Mode C: Single Thread (<code>generate_single_thread()</code>)","text":"<ul> <li>Sequential execution, one sample at a time</li> <li>Used for debugging</li> <li>Easier to debug issues</li> <li>Much slower</li> </ul>"},{"location":"Evaluation-Entry/#step-5-process-each-sample-_generate_sample-or-_run_sample_in_process","title":"Step 5: Process Each Sample (<code>_generate_sample</code> or <code>_run_sample_in_process</code>)","text":"<p>For each sample in the dataset:</p>"},{"location":"Evaluation-Entry/#51-create-evaluation-task","title":"5.1 Create Evaluation Task","text":"<pre><code>task = self._create_task(sample)\n</code></pre> <ol> <li>Extracts sample data</li> <li>Creates <code>EvaluationTask</code> object with:</li> <li><code>session_id</code>: Unique ID for this task</li> <li><code>sample</code>: Original sample data</li> <li><code>aigise_session</code>: Will be created next</li> <li>Metadata (task name, description, etc.)</li> </ol>"},{"location":"Evaluation-Entry/#52-create-sage-x-session","title":"5.2 Create SAGE-X Session","text":"<pre><code>aigise_session = get_aigise_session(\n    aigise_session_id=task.session_id,\n    config_path=self.config_path\n)\n</code></pre> <ul> <li>Creates isolated SAGE-X session for this task</li> <li>Loads configuration</li> <li>Each task gets its own session (isolation)</li> </ul>"},{"location":"Evaluation-Entry/#53-prepare-task-specific-environment-_prepare_environment","title":"5.3 Prepare Task-Specific Environment (<code>_prepare_environment</code>)","text":"<p>This is benchmark-specific. Example for CyberGym:</p> <ol> <li>Extract code/data:</li> <li>Extracts source code to sandbox</li> <li>Copies test files, build scripts</li> <li> <p>Sets up project structure</p> </li> <li> <p>Initialize sandboxes:    <pre><code>aigise_session.sandboxes.initialize_shared_volumes()\nawait aigise_session.sandboxes.launch_all_sandboxes()\nawait aigise_session.sandboxes.initialize_all_sandboxes()\n</code></pre></p> </li> <li>Creates shared volumes</li> <li>Launches required sandbox containers</li> <li> <p>Initializes sandboxes (tools, dependencies)</p> </li> <li> <p>Set source directory:    <pre><code>aigise_session.config.src_dir_in_sandbox = \"/shared/code\"\n</code></pre></p> </li> <li> <p>Tells tools where to find source code</p> </li> <li> <p>Git repository setup (if applicable):</p> </li> <li>Finds git repository in sandbox</li> <li>Checks out main/master branch</li> <li>Updates <code>src_dir_in_sandbox</code> to repo path</li> </ol>"},{"location":"Evaluation-Entry/#54-load-agent","title":"5.4 Load Agent","text":"<pre><code>mk_agent = self._load_mk_agent()\nagent = mk_agent(aigise_session_id=task.session_id)\n</code></pre> <ol> <li>Imports agent module</li> <li>Calls <code>mk_agent()</code> function with session ID</li> <li>Agent is configured for this specific session</li> <li>Agent has access to task-specific sandboxes and resources</li> </ol>"},{"location":"Evaluation-Entry/#55-create-adk-session-and-runner","title":"5.5 Create ADK Session and Runner","text":"<pre><code>inner_session_service = InMemorySessionService()\nawait inner_session_service.create_session(\n    app_name=app_name,\n    user_id=self.user_id + \"_\" + meta_data,\n    session_id=task.session_id,\n    state={\"aigise_session_id\": task.session_id},\n)\n\nrunner = Runner(\n    agent=agent,\n    app_name=app_name,\n    session_service=inner_session_service,\n)\n</code></pre> <ul> <li>Creates ADK session that maps to SAGE-X session</li> <li>Stores <code>aigise_session_id</code> in session state</li> <li>Creates ADK Runner for agent execution</li> </ul>"},{"location":"Evaluation-Entry/#56-run-agent","title":"5.6 Run Agent","text":"<pre><code>run_config = RunConfig(max_llm_calls=self.max_llm_calls)\n\nasync for event in runner.run_async(\n    user_id=user_id,\n    session_id=task.session_id,\n    run_config=run_config,\n    new_message=types.Content(parts=[types.Part(text=task.prompt)]),\n):\n    # Process events\n    if isinstance(event, types.FunctionResponse):\n        # Tool execution results\n    elif isinstance(event, types.Candidate):\n        # Agent responses\n</code></pre> <ol> <li>Runner starts agent execution:</li> <li>Sends prompt to agent</li> <li> <p>Agent enters reason-act loop</p> </li> <li> <p>Agent reasoning:</p> </li> <li>Calls LLM for reasoning</li> <li>Decides which tools to use</li> <li> <p>Generates function calls</p> </li> <li> <p>Tool execution:</p> </li> <li>Runner executes tools in sandbox</li> <li>Tools access session resources</li> <li> <p>Results returned to agent</p> </li> <li> <p>Iteration:</p> </li> <li>Agent processes tool results</li> <li>Decides next action</li> <li> <p>Continues until completion or max calls</p> </li> <li> <p>Completion:</p> </li> <li>Agent generates final response</li> <li>Runner finishes execution</li> <li>Events collected</li> </ol>"},{"location":"Evaluation-Entry/#57-collect-results","title":"5.7 Collect Results","text":"<pre><code>result = {\n    \"session_id\": task.session_id,\n    \"prompt\": task.prompt,\n    \"response\": agent_response,\n    \"events\": events,\n    \"metadata\": {...},\n}\n</code></pre> <ul> <li>Extracts agent response</li> <li>Collects execution metadata:</li> <li>Number of LLM calls</li> <li>Tools used</li> <li>Execution time</li> <li>Errors (if any)</li> </ul>"},{"location":"Evaluation-Entry/#58-save-results","title":"5.8 Save Results","text":"<pre><code>self._save_result(task, result)\n</code></pre> <ul> <li>Saves result to file (JSON)</li> <li>Location: <code>evals/{agent_id}/{benchmark}/results/{task_id}.json</code></li> <li>Includes full event history for analysis</li> </ul>"},{"location":"Evaluation-Entry/#59-cleanup-task-session","title":"5.9 Cleanup Task Session","text":"<pre><code>cleanup_aigise_session(task.session_id)\n</code></pre> <ul> <li>Stops sandbox containers</li> <li>Removes shared volumes</li> <li>Cleans up session resources</li> <li>Frees Docker resources</li> </ul>"},{"location":"Evaluation-Entry/#step-6-collect-all-results","title":"Step 6: Collect All Results","text":"<p>After all samples complete:</p> <ol> <li>Aggregates results from all tasks</li> <li>Collects statistics:</li> <li>Success rate</li> <li>Average execution time</li> <li>Tool usage patterns</li> <li>Error rates</li> </ol>"},{"location":"Evaluation-Entry/#step-7-evaluate-results-evaluate","title":"Step 7: Evaluate Results (<code>evaluate()</code>)","text":"<pre><code>self.evaluate()\n</code></pre> <ol> <li>Load ground truth:</li> <li>Loads expected outputs from dataset</li> <li> <p>Loads agent results from files</p> </li> <li> <p>Compare outputs:</p> </li> <li>Compares agent output vs ground truth</li> <li> <p>Calculates metrics:</p> <ul> <li>Accuracy</li> <li>Precision/Recall (if applicable)</li> <li>Custom benchmark metrics</li> </ul> </li> <li> <p>Generate report:</p> </li> <li>Creates evaluation report</li> <li>Includes metrics, statistics, examples</li> <li> <p>Saves to <code>evals/{agent_id}/{benchmark}/evaluation_report.json</code></p> </li> <li> <p>Display summary:</p> </li> <li>Prints metrics to console</li> <li>Shows top failures/successes</li> <li>Provides analysis</li> </ol>"},{"location":"Evaluation-Entry/#key-characteristics","title":"Key Characteristics","text":""},{"location":"Evaluation-Entry/#isolation","title":"Isolation","text":"<ul> <li>Each task gets its own SAGE-X session</li> <li>Separate sandbox containers</li> <li>No interference between tasks</li> </ul>"},{"location":"Evaluation-Entry/#parallelism","title":"Parallelism","text":"<ul> <li>Multiple tasks run simultaneously</li> <li>Configurable worker count</li> <li>Process or thread-based execution</li> </ul>"},{"location":"Evaluation-Entry/#reproducibility","title":"Reproducibility","text":"<ul> <li>Deterministic task execution</li> <li>Results saved with full event history</li> <li>Can replay specific tasks</li> </ul>"},{"location":"Evaluation-Entry/#resource-management","title":"Resource Management","text":"<ul> <li>Sessions cleaned up after each task</li> <li>Containers stopped and removed</li> <li>Prevents resource leaks</li> </ul>"},{"location":"Evaluation-Entry/#comparison-with-aigise-web","title":"Comparison with aigise web","text":"Aspect aigise web Evaluations Purpose Development, debugging Performance measurement Sessions Single long-lived session Multiple short-lived sessions Interaction Interactive chat Batch processing Parallelism Single user Multiple tasks in parallel Cleanup Manual (on exit) Automatic (per task) Output Real-time events Saved results files"},{"location":"Evaluation-Entry/#example-evaluation-flow","title":"Example Evaluation Flow","text":"<pre><code>Dataset (100 tasks)\n  \u2193\nProcess Pool (3 workers)\n  \u251c\u2500 Worker 1: Task 1 \u2192 Session 1 \u2192 Agent \u2192 Result 1\n  \u251c\u2500 Worker 2: Task 2 \u2192 Session 2 \u2192 Agent \u2192 Result 2\n  \u2514\u2500 Worker 3: Task 3 \u2192 Session 3 \u2192 Agent \u2192 Result 3\n  \u251c\u2500 Worker 1: Task 4 \u2192 Session 4 \u2192 Agent \u2192 Result 4\n  ...\n  \u2193\nAll Results Collected\n  \u2193\nEvaluation (compare vs ground truth)\n  \u2193\nReport Generated\n</code></pre>"},{"location":"Evaluation-Entry/#related-topics","title":"Related Topics","text":"<ul> <li>Entry Points - Overview of entry points</li> <li>Core Concepts - Understanding sessions</li> <li>Testing Debugging - Debugging evaluations</li> </ul>"},{"location":"Getting-Started/","title":"Getting Started","text":""},{"location":"Getting-Started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+ (recommended)</li> <li><code>uv</code> package manager (required)</li> <li>Docker (for sandbox execution)</li> <li>CodeQL (optional, for CodeQL analysis)</li> </ul>"},{"location":"Getting-Started/#installation","title":"Installation","text":""},{"location":"Getting-Started/#step-1-install-uv","title":"Step 1: Install uv","text":"<pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre>"},{"location":"Getting-Started/#step-2-clone-and-setup","title":"Step 2: Clone and Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/YOUR_USERNAME/adk-python.git\ncd adk-python/AIgiSE\n\n# Create virtual environment\nuv venv --python \"python3.11\" \".venv\"\nsource .venv/bin/activate\n\n# Install dependencies\nuv sync\n\n# Install pre-commit hooks\nuv run pre-commit install\n</code></pre>"},{"location":"Getting-Started/#step-3-additional-setup","title":"Step 3: Additional Setup","text":"<p>CodeQL Setup (Optional): <pre><code># Download CodeQL bundle\n# Extract to: PROJECT_PATH/src/aigise/sandbox_scripts/codeql\n</code></pre></p>"},{"location":"Getting-Started/#verify-installation","title":"Verify Installation","text":"<pre><code># Check aigise CLI is available\nuv run aigise --help\n</code></pre>"},{"location":"Getting-Started/#next-steps","title":"Next Steps","text":"<ul> <li>Project Structure - Understand the codebase structure</li> <li>Core Concepts - Learn the core concepts</li> <li>Development Guides - Start developing</li> </ul>"},{"location":"Getting-Started/#see-also","title":"See Also","text":"<ul> <li>Introduction - Project overview</li> <li>Configuration - Configuration guide</li> </ul>"},{"location":"Introduction/","title":"Introduction","text":""},{"location":"Introduction/#what-is-sage-x","title":"What is SAGE-X?","text":"<p>SAGE-X (Self-programming Agent Generation Engine: Next Generation) is an AI agent framework built on top of Google ADK (Agent Development Kit). It represents a paradigm shift from \"Agent Development 1.0\" to \"Agent Development 2.0\" \u2014 transitioning from agents that execute predefined structures to agents that can dynamically build and manage their own systems at runtime.</p>"},{"location":"Introduction/#core-value-proposition","title":"Core Value Proposition","text":""},{"location":"Introduction/#from-agent-using-system-to-agent-building-system","title":"From \"Agent Using System\" to \"Agent Building System\"","text":"<p>Agent Development 1.0 (Traditional Frameworks): - System structure pre-defined by humans (agent topology, workflows, tool sets) - Agents can only choose actions within given structures - Extending to new tasks requires significant manual refactoring - Essentially human-centered agent building</p> <p>Agent Development 2.0 (SAGE-X): - Agents upgrade from \"executing predefined structures\" to \"autonomously building and managing structures\" - Humans provide minimal, stable system-level scaffolding - Everything else is generated, composed, and scheduled by AI at runtime - Agents can \"invent new capabilities\" rather than just calling existing ones</p>"},{"location":"Introduction/#key-advantages-selling-points","title":"Key Advantages &amp; Selling Points","text":""},{"location":"Introduction/#1-ai-written-tools-as-first-class-system-entities","title":"1. AI-Written Tools as First-Class System Entities","text":"<p>Redefining Tools in Agent Development 2.0:</p> <p>In traditional frameworks, tools are: - Fixed API lists - Pre-registered function interfaces defined by humans - Static capabilities that agents can only call</p> <p>In SAGE-X (Agent Development 2.0), tools are: - Programmatic entities that agents can write, modify, and evolve - Runtime-generated capabilities that adapt to current tasks - First-class system entities with lifecycle management</p> <p>Supported Capabilities:</p> <p>SAGE-X natively supports: - Agent-generated tools: Agents can create new tools (bash scripts, analysis scripts, debugging tools) - Tool modification: Agents can modify existing tools to adapt to current tasks - Runtime tool management:   - Multiple bash sessions for parallel execution   - Tool-specific sandboxes (especially for long-running tools like fuzzers)   - Tool state persistence and restoration, enabling cross-task reuse</p> <p>Design Value:</p> <p>This design enables: - Agents can \"invent new capabilities\" rather than just calling existing ones - Tool sets evolve with tasks, not statically bound - System has continuous self-expansion potential</p> <p>Implementation: - <code>ToolLoader</code> dynamically discovers tools from <code>src/aigise/bash_tools/</code> - Tools structured as \"Skills\" with metadata (<code>SKILL.md</code>) - <code>bash_tool</code> enables execution of arbitrary commands, allowing agents to create new tools</p>"},{"location":"Introduction/#2-runtime-generated-sub-agents-dynamic-agent-topology","title":"2. Runtime-Generated Sub-Agents &amp; Dynamic Agent Topology","text":"<p>Sub-Agent Positioning:</p> <p>Sub-agents are functionally specialized agents temporarily created for specific sub-tasks, such as: - Debugger Agent - Retrieval Agent - Fuzzer Agent - Memory Agent</p> <p>Supported Capabilities:</p> <p>SAGE-X supports: - Runtime creation/destruction of sub-agents - Each sub-agent has:   - Independent identity   - Independent tool set   - Independent short-term memory - Recursive sub-agent creation: Sub-agents can create their own sub-agents</p> <p>Agent Topology:</p> <p>All agents and sub-agents form: - A task-specific agent graph (agent graph) - The graph can dynamically change during execution - Different tasks have different agent topology structures</p> <p>Agent Ensemble:</p> <p>System supports: - Parallel exploration: Multiple agents explore in parallel - Result merging: Results from multiple agents are merged - Dynamic trade-off: Balance between efficiency and stability - Thread-safe agent execution support</p> <p>Implementation: - <code>DynamicAgentManager</code> manages agent lifecycle - <code>AigiseEnsembleManager</code> coordinates multi-agent execution - Agents can discover and call other agents dynamically</p>"},{"location":"Introduction/#3-system-level-workflow-not-prompt-level","title":"3. System-Level Workflow (Not Prompt-Level)","text":"<p>Workflow Definition in Agent Development 2.0:</p> <p>In SAGE-X, workflow is: - A rule-driven, graph-based Agent/Tool scheduling system - Supports event-driven (pub-sub) coordination - System-enforced execution patterns</p> <p>It is NOT: - Step-by-step plans in prompts - Free-form LLM reasoning execution order</p> <p>Rule-Based Execution:</p> <p>Workflow execution is controlled by explicit rules: - Condition triggers: Rules determine when actions execute - State transitions: Clear state management - Failure recovery: Built-in error handling - Enforced execution order: System guarantees correct sequencing</p> <p>These rules are: - Verifiable: Can be checked and validated - Reproducible: Deterministic execution - System-enforced: Not suggestions, but guarantees</p> <p>Graph-Based Scheduling Model:</p> <p>Workflow structure is an execution graph: - Nodes: Agent / Sub-Agent / Tool - Edges: Invocation relationships, dependencies, data flow</p> <p>The graph: - Can be generated by AI at runtime - Can be dynamically modified during execution - Supports parallel execution and branching</p> <p>Pub-Sub Pattern for Agent Coordination:</p> <p>SAGE-X natively supports event-driven model: - Agents / Tools can publish events - Other Agents can subscribe to events of interest - Asynchronous, decoupled execution</p> <p>Typical events include: - Tool completion - Debugger hitting breakpoints - Fuzzer discovering new coverage - Sub-task completion</p> <p>Note: Detailed documentation for System-Level Workflow is planned. See System Workflow for more information (coming soon).</p>"},{"location":"Introduction/#4-memory-as-manageable-system-resource","title":"4. Memory as Manageable System Resource","text":"<p>Layered Memory Model:</p> <p>SAGE-X adopts: - Persistent long-term memory: Cross-session knowledge retention - Sub-agent specific short-term memory: Task-specific context</p> <p>Graph-Structured Memory:</p> <p>Memory is organized as a graph structure: - Nodes represent facts, events, summaries - Edges represent dependencies, causal relationships, or semantic relationships - Supports graph queries and retrieval</p> <p>Memory Agent:</p> <p>A dedicated memory agent (planned): - Decides when to store information - Determines when to compress or discard old information - Manages when to retrieve historical experience</p> <p>Memory is not passive context, but: - Runtime resource actively scheduled by agents - First-class entity in the system architecture</p> <p>Note: Graph-structured memory and Memory Agent are planned features. See Memory System for more information (coming soon).</p>"},{"location":"Introduction/#5-session-based-resource-isolation","title":"5. Session-Based Resource Isolation","text":"<p>Architecture: - Each session has completely isolated resources (sandboxes, configs, agents) - No global singletons \u2014 all resources are session-bound - Prevents interference between different agent runs - Clean resource management and cleanup</p>"},{"location":"Introduction/#6-multi-sandbox-support-with-flexible-backends","title":"6. Multi-Sandbox Support with Flexible Backends","text":"<p>Sandbox Types: - <code>main</code>: Primary analysis sandbox - <code>joern</code>: Static analysis (CPG generation) - <code>codeql</code>: CodeQL analysis - <code>neo4j</code>: Graph database for CPG storage - <code>gdb_mcp</code>: Debugger integration - <code>fuzz</code>: Fuzzing environment</p> <p>Backend Support: - Docker (Native): Local development and testing - Kubernetes: Production deployment with automatic scaling - Easy switching between backends via configuration</p> <p>Implementation: - <code>K8sSandbox</code> provides Kubernetes backend - <code>NativeDockerSandbox</code> for local Docker execution - Sandbox factory pattern for backend abstraction</p>"},{"location":"Introduction/#7-training-support-easy-integration","title":"7. Training Support &amp; Easy Integration","text":"<p>Kubernetes-Based Rapid Rollout:</p> <p>SAGE-X's native Kubernetes sandbox support enables: - Quick deployment at scale: Fast rollout of training environments - Parallel training runs: Session isolation allows simultaneous training experiments - Horizontal scaling: Easy scaling for large-scale agent training - Native resource management: Leverage Kubernetes mechanisms for resource allocation and scheduling</p> <p>Integration with Training Frameworks:</p> <p>SAGE-X is designed for seamless integration with popular training frameworks:</p> <ul> <li>AREL (Adaptive REinforcement Learning): Structure your agent tasks as RL environments and use SAGE-X agents as the policy network. The dynamic tool generation and sub-agent creation capabilities make it easy to design diverse RL environments.</li> <li>VERL (Versatile Reinforcement Learning): Leverage SAGE-X's dynamic agent creation and ensemble capabilities for multi-agent RL scenarios. The session isolation ensures clean parallel training runs.</li> <li>LLaMA Factory: Use SAGE-X agents for data generation, evaluation, and fine-tuning workflows. The multi-sandbox support allows for diverse data generation scenarios.</li> </ul> <p>Why SAGE-X Works Well for Training: - Session isolation enables clean, reproducible training runs - Dynamic sub-agent creation supports curriculum learning - Multi-sandbox support allows diverse environment simulation - Tool generation enables agents to adapt to new tasks during training - Kubernetes backend provides production-grade scalability</p>"},{"location":"Introduction/#8-security-focused-system-level-customization","title":"8. Security-Focused System-Level Customization","text":"<p>SAGE-X is not a generic agent demo, but deeply customized for software security and software engineering.</p> <p>Native Integration: - Static analysis tools: CPG generation, program slicing, call graphs (via Joern/CodeQL) - Dynamic analysis tools: Debuggers (GDB), fuzzing, coverage analysis (via sandbox tools) - LSP and code understanding tools: Language server protocol integration</p> <p>Agent Capabilities: Agents can: - Self-diagnose failure causes - Create specialized debugging sub-agents on demand - Adjust workflows based on runtime signals - Generate security-focused tools for specific vulnerability types</p> <p>This system-level customization makes SAGE-X a powerful platform for security research and software engineering automation.</p>"},{"location":"Introduction/#design-philosophy","title":"Design Philosophy","text":""},{"location":"Introduction/#agent-development-20-principles","title":"Agent Development 2.0 Principles","text":"<ol> <li>First-Class Evolvable Entities: Tool / Agent / Workflow / Memory are all first-class, evolvable entities, not static configurations</li> <li>Minimal Scaffolding: Humans provide only stable system-level infrastructure</li> <li>Runtime Generation: Agents build structures at runtime, not design time</li> <li>Continuous Self-Extension: System has the potential for continuous self-expansion</li> </ol>"},{"location":"Introduction/#the-fundamental-innovation","title":"The Fundamental Innovation","text":"<p>Agent Development 2.0's innovation is not about: - Larger models - More complex prompts</p> <p>Instead, it's about: - Treating agents as entities that can build systems - Elevating Tool / Agent / Workflow / Memory to first-class, evolvable entities - Building infrastructure that enables agents to autonomously design, execute, and improve complex task systems</p>"},{"location":"Introduction/#key-features","title":"Key Features","text":"<ul> <li>AI-written tools as first-class system entities</li> <li>Runtime sub-agent creation and dynamic agent topology</li> <li>System-level workflow (rule-based, graph-based, event-driven) - planned</li> <li>Memory as manageable resource (graph-structured, memory agent) - planned</li> <li>Session-based resource management with complete isolation</li> <li>Multi-sandbox support (Docker, Kubernetes)</li> <li>Dynamic tool loading and runtime tool generation</li> <li>Agent ensemble for parallel exploration</li> <li>Integration with security tools (Joern, CodeQL, GDB, Neo4j)</li> <li>Training framework integration (AREL, VERL, LLaMA Factory)</li> <li>Evaluation framework for security benchmarks</li> </ul>"},{"location":"Introduction/#why-sage-x","title":"Why SAGE-X?","text":"<p>SAGE-X was designed to make self-programming agent development feel more like software development. It provides:</p> <ol> <li>Isolation: Each agent session has its own resources, preventing interference</li> <li>Flexibility: Easy to add new tools, sandboxes, and agents</li> <li>Evolution: Tools and agents can be created and modified at runtime</li> <li>Integration: Seamless integration with existing security analysis tools</li> <li>Composability: Build complex agents from simple components</li> <li>Scalability: Kubernetes support for production deployment</li> </ol>"},{"location":"Introduction/#use-cases","title":"Use Cases","text":"<ul> <li>Self-programming agent development</li> <li>Code generation and analysis</li> <li>Vulnerability detection and analysis</li> <li>Fuzzing campaign management</li> <li>Code coverage analysis</li> <li>Static code analysis (CPG generation)</li> <li>Multi-agent workflows</li> <li>Agent training and evaluation</li> </ul>"},{"location":"Introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Set up your development environment</li> <li>Architecture - Understand the system architecture</li> <li>Core Concepts - Learn the core concepts</li> <li>Entry Points - Understand how to use SAGE-X</li> </ul>"},{"location":"Memory-System/","title":"Memory System","text":"<p>Status: Graph-structured memory and Memory Agent are planned features and under active development.</p>"},{"location":"Memory-System/#overview","title":"Overview","text":"<p>In SAGE-X, Memory is treated as a manageable system resource rather than passive context. The planned memory system includes layered memory models, graph-structured storage, and an active memory agent.</p>"},{"location":"Memory-System/#planned-features","title":"Planned Features","text":""},{"location":"Memory-System/#layered-memory-model","title":"Layered Memory Model","text":"<ul> <li>Persistent long-term memory (cross-session)</li> <li>Sub-agent specific short-term memory</li> <li>Memory isolation per session</li> </ul>"},{"location":"Memory-System/#graph-structured-memory","title":"Graph-Structured Memory","text":"<ul> <li>Nodes represent facts, events, summaries</li> <li>Edges represent dependencies, causal relationships, semantic relationships</li> <li>Graph queries and retrieval capabilities</li> </ul>"},{"location":"Memory-System/#memory-agent","title":"Memory Agent","text":"<ul> <li>Decides when to store information</li> <li>Determines when to compress or discard old information</li> <li>Manages when to retrieve historical experience</li> <li>Active memory management and scheduling</li> </ul>"},{"location":"Memory-System/#current-implementation","title":"Current Implementation","text":"<p>SAGE-X currently uses ADK's memory services: - In-memory memory service (for testing) - Vertex AI Memory Bank (for production)</p>"},{"location":"Memory-System/#documentation-status","title":"Documentation Status","text":"<p>Detailed documentation will be added as these features are implemented.</p>"},{"location":"Memory-System/#related-links","title":"Related Links","text":"<ul> <li>Introduction - Overview of SAGE-X design philosophy</li> <li>Core Concepts - Core concepts of the framework</li> </ul>"},{"location":"Project-Structure/","title":"Project Structure","text":""},{"location":"Project-Structure/#directory-overview","title":"Directory Overview","text":"<pre><code>SAGE-X/\n\u251c\u2500\u2500 src/aigise/              # Main source code\n\u2502   \u251c\u2500\u2500 agents/              # Agent implementations\n\u2502   \u251c\u2500\u2500 cli/                 # Command-line interface\n\u2502   \u251c\u2500\u2500 config/              # Configuration system\n\u2502   \u251c\u2500\u2500 session/             # Session management\n\u2502   \u251c\u2500\u2500 sandbox/             # Sandbox implementations\n\u2502   \u251c\u2500\u2500 toolbox/             # Security analysis tools\n\u2502   \u251c\u2500\u2500 evaluations/         # Benchmark evaluations\n\u2502   \u251c\u2500\u2500 features/            # Framework features\n\u2502   \u251c\u2500\u2500 plugins/             # ADK plugins\n\u2502   \u251c\u2500\u2500 patches/             # ADK patches\n\u2502   \u2514\u2500\u2500 templates/           # Configuration templates\n\u251c\u2500\u2500 examples/                # Example agents and usage\n\u251c\u2500\u2500 tests/                   # Test suite\n\u251c\u2500\u2500 docs/                    # Documentation\n\u2514\u2500\u2500 README.md               # Quick start guide\n</code></pre>"},{"location":"Project-Structure/#key-directories-explained","title":"Key Directories Explained","text":""},{"location":"Project-Structure/#srcaigiseagents","title":"<code>src/aigise/agents/</code>","text":"<ul> <li><code>aigise_agent.py</code>: Extended ADK agent class</li> <li>Tool loading and dynamic tool injection</li> </ul>"},{"location":"Project-Structure/#srcaigisesession","title":"<code>src/aigise/session/</code>","text":"<ul> <li><code>aigise_session.py</code>: Main session manager</li> <li><code>aigise_sandbox_manager.py</code>: Sandbox lifecycle management</li> <li><code>aigise_dynamic_agent_manager.py</code>: Agent creation and caching</li> <li><code>aigise_ensemble_manager.py</code>: Multi-agent coordination</li> </ul>"},{"location":"Project-Structure/#srcaigisesandbox","title":"<code>src/aigise/sandbox/</code>","text":"<ul> <li><code>base_sandbox.py</code>: Abstract sandbox interface</li> <li><code>native_docker_sandbox.py</code>: Docker-based sandbox</li> <li><code>k8s_sandbox.py</code>: Kubernetes-based sandbox</li> <li><code>initializers/</code>: Sandbox initialization logic</li> </ul>"},{"location":"Project-Structure/#srcaigisetoolbox","title":"<code>src/aigise/toolbox/</code>","text":"<ul> <li><code>static_analysis/</code>: Joern, CodeQL integration</li> <li><code>fuzzing/</code>: Fuzzing tools</li> <li><code>debugger/</code>: GDB integration</li> <li><code>coverage/</code>: Coverage analysis</li> <li><code>retrieval/</code>: Code search tools</li> </ul>"},{"location":"Project-Structure/#srcaigiseevaluations","title":"<code>src/aigise/evaluations/</code>","text":"<ul> <li><code>cybergym/</code>: CyberGym benchmark</li> <li><code>patchagent/</code>: PatchAgent benchmark</li> <li><code>secodeplt/</code>: SecCodePLT benchmark</li> </ul>"},{"location":"Project-Structure/#see-also","title":"See Also","text":"<ul> <li>Core Components - Component details</li> <li>Development Guides - How to add to the codebase</li> </ul>"},{"location":"RL-Integration/","title":"RL Framework Integration","text":"<p>AIgiSE provides seamless integration with RL frameworks (slime, verl, areal, etc.) for agent training and evaluation. This integration allows RL frameworks to use AIgiSE agents as rollout systems.</p>"},{"location":"RL-Integration/#overview","title":"Overview","text":"<p>The RL integration module (<code>aigise.rl_integration</code>) provides:</p> <ul> <li>Client: Manages agent configuration and model setup</li> <li>RLSession: Wraps AigiseSession with framework-specific generate methods</li> <li>Adapters: Framework-specific logic for sample handling (slime, verl, areal)</li> </ul>"},{"location":"RL-Integration/#architecture","title":"Architecture","text":"<pre><code>RL Framework (slime/verl/areal)\n    \u2193\nAIgiSE Client\n    \u2193\nRLSession (wraps AigiseSession)\n    \u2193\nFramework Adapter (SlimeAdapter/VerlAdapter/ArealAdapter)\n    \u2193\nAgent Execution\n</code></pre>"},{"location":"RL-Integration/#basic-usage","title":"Basic Usage","text":""},{"location":"RL-Integration/#creating-a-client","title":"Creating a Client","text":"<pre><code>import aigise\n\n# Create client for agent and benchmark\nclient = aigise.create(\n    agent_name=\"vul_agent\",\n    benchmark_name=\"secodeplt\"\n)\n</code></pre> <p>The <code>create()</code> function: - Resolves the agent directory from <code>examples/agents/&lt;agent_name&gt;/</code> - Loads the benchmark interface from <code>aigise/evaluations/&lt;benchmark_name&gt;/</code> - Creates a <code>Client</code> instance with agent and benchmark configuration</p>"},{"location":"RL-Integration/#using-rlsession","title":"Using RLSession","text":"<pre><code># Initialize session and generate samples\nwith client.init_session() as session:\n    # For slime framework\n    sample = await session.slime_generate(\n        args=args,\n        sample=sample,\n        sampling_params=sampling_params\n    )\n\n    # For verl framework (when implemented)\n    # sample = await session.verl_generate(args, sample, sampling_params)\n\n    # For areal framework (when implemented)\n    # sample = await session.areal_generate(args, sample, sampling_params)\n</code></pre>"},{"location":"RL-Integration/#framework-specific-methods","title":"Framework-Specific Methods","text":"<p>Each framework has its own generate method:</p> <ul> <li><code>slime_generate()</code>: For slime framework integration</li> <li><code>verl_generate()</code>: For verl framework integration (planned)</li> <li><code>areal_generate()</code>: For areal framework integration (planned)</li> </ul>"},{"location":"RL-Integration/#client-api","title":"Client API","text":""},{"location":"RL-Integration/#client__init__agent_name-benchmark_name","title":"<code>Client.__init__(agent_name, benchmark_name)</code>","text":"<p>Initializes the client with agent and benchmark configuration.</p> <p>Parameters: - <code>agent_name</code>: Name of the agent (must exist in <code>examples/agents/</code>) - <code>benchmark_name</code>: Name of the benchmark (must exist in <code>aigise/evaluations/</code>)</p> <p>Raises: - <code>ValueError</code>: If agent or benchmark not found</p>"},{"location":"RL-Integration/#clientinit_session","title":"<code>Client.init_session()</code>","text":"<p>Creates and returns an <code>RLSession</code> context manager.</p> <p>Returns: - <code>RLSession</code>: Session context manager for agent execution</p> <p>Usage: <pre><code>with client.init_session() as session:\n    # Use session for agent execution\n    pass\n</code></pre></p>"},{"location":"RL-Integration/#rlsession-api","title":"RLSession API","text":""},{"location":"RL-Integration/#rlsessionslime_generateargs-sample-sampling_params","title":"<code>RLSession.slime_generate(args, sample, sampling_params)</code>","text":"<p>Generates a sample using the slime framework adapter.</p> <p>Parameters: - <code>args</code>: Framework-specific arguments - <code>sample</code>: Input sample to process - <code>sampling_params</code>: Sampling parameters</p> <p>Returns: - Processed sample with agent output</p>"},{"location":"RL-Integration/#rlsessionverl_generateargs-sample-sampling_params","title":"<code>RLSession.verl_generate(args, sample, sampling_params)</code>","text":"<p>Generates a sample using the verl framework adapter (planned).</p>"},{"location":"RL-Integration/#rlsessionareal_generateargs-sample-sampling_params","title":"<code>RLSession.areal_generate(args, sample, sampling_params)</code>","text":"<p>Generates a sample using the areal framework adapter (planned).</p>"},{"location":"RL-Integration/#adapters","title":"Adapters","text":"<p>Adapters handle framework-specific logic for sample processing:</p> <ul> <li><code>SlimeAdapter</code>: Handles slime framework sample format and processing</li> <li><code>VerlAdapter</code>: Handles verl framework sample format (planned)</li> <li><code>ArealAdapter</code>: Handles areal framework sample format (planned)</li> </ul> <p>Each adapter implements the <code>BaseAdapter</code> interface and provides: - Sample format conversion - Framework-specific parameter handling - Result formatting</p>"},{"location":"RL-Integration/#benchmark-interface","title":"Benchmark Interface","text":"<p>The benchmark interface (<code>BenchmarkInterface</code>) provides:</p> <ul> <li>Benchmark configuration loading</li> <li>Evaluation instance creation</li> <li>Task data management</li> </ul> <p>Benchmarks are automatically loaded from <code>aigise/evaluations/&lt;benchmark_name&gt;/</code> and must implement the <code>BenchmarkInterface</code> protocol.</p>"},{"location":"RL-Integration/#example-complete-workflow","title":"Example: Complete Workflow","text":"<pre><code>import aigise\n\n# 1. Create client\nclient = aigise.create(\"vul_agent\", \"secodeplt\")\n\n# 2. Initialize session\nwith client.init_session() as session:\n    # 3. Generate samples for training\n    for sample in training_samples:\n        result = await session.slime_generate(\n            args=training_args,\n            sample=sample,\n            sampling_params=sampling_params\n        )\n        # Process result...\n</code></pre>"},{"location":"RL-Integration/#session-lifecycle","title":"Session Lifecycle","text":"<ol> <li>Session Creation: <code>init_session()</code> creates a new AigiseSession</li> <li>Agent Loading: Agent is loaded and configured</li> <li>Sandbox Initialization: Required sandboxes are launched and initialized</li> <li>Sample Generation: Framework-specific generate methods execute agents</li> <li>Session Cleanup: Session and resources are cleaned up on exit</li> </ol>"},{"location":"RL-Integration/#integration-points","title":"Integration Points","text":"<p>The RL integration automatically handles:</p> <ul> <li>Agent Configuration: Loads agent from <code>examples/agents/</code></li> <li>Model Setup: Configures LLM models from agent configuration</li> <li>Session Management: Creates and manages AigiseSession lifecycle</li> <li>Sandbox Management: Launches and initializes required sandboxes</li> <li>Benchmark Integration: Loads benchmark interface and evaluation instances</li> <li>Framework Adapters: Provides framework-specific sample handling</li> </ul>"},{"location":"RL-Integration/#see-also","title":"See Also","text":"<ul> <li>Entry Points - Overview of all entry points</li> <li>Core Concepts - Understanding sessions and agents</li> <li>Architecture - System architecture</li> </ul>"},{"location":"System-Workflow/","title":"System-Level Workflow","text":"<p>Status: This feature is planned and under active development.</p>"},{"location":"System-Workflow/#overview","title":"Overview","text":"<p>System-Level Workflow in SAGE-X represents a paradigm shift from prompt-level step-by-step planning to rule-driven, graph-based, event-driven agent and tool scheduling.</p>"},{"location":"System-Workflow/#planned-features","title":"Planned Features","text":""},{"location":"System-Workflow/#rule-based-execution","title":"Rule-Based Execution","text":"<ul> <li>Condition triggers</li> <li>State transitions</li> <li>Failure recovery</li> <li>Enforced execution order</li> </ul>"},{"location":"System-Workflow/#graph-based-scheduling","title":"Graph-Based Scheduling","text":"<ul> <li>Nodes: Agent / Sub-Agent / Tool</li> <li>Edges: Invocation relationships, dependencies, data flow</li> <li>Runtime graph generation</li> <li>Dynamic graph modification</li> </ul>"},{"location":"System-Workflow/#pub-sub-event-model","title":"Pub-Sub Event Model","text":"<ul> <li>Event publishing by agents/tools</li> <li>Event subscription by agents</li> <li>Asynchronous, decoupled execution</li> </ul>"},{"location":"System-Workflow/#documentation-status","title":"Documentation Status","text":"<p>Detailed documentation will be added as this feature is implemented.</p>"},{"location":"System-Workflow/#related-links","title":"Related Links","text":"<ul> <li>Introduction - Overview of SAGE-X design philosophy</li> <li>Core Concepts - Core concepts of the framework</li> </ul>"},{"location":"Testing-Debugging/","title":"Testing &amp; Debugging","text":""},{"location":"Testing-Debugging/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest tests/\n\n# Run specific test file\nuv run pytest tests/unit/test_session.py\n\n# Run with coverage\nuv run pytest --cov=src/aigise tests/\n</code></pre>"},{"location":"Testing-Debugging/#debugging-with-web-ui","title":"Debugging with Web UI","text":"<p>The web UI is the primary debugging tool:</p> <pre><code>uv run aigise web \\\n  --config /path/to/config.toml \\\n  --agent /path/to/agent_dir \\\n  --port 8080 \\\n  --neo4j_logging  # optional\n</code></pre>"},{"location":"Testing-Debugging/#debugging-sandboxes","title":"Debugging Sandboxes","text":"<pre><code># In your code\nsandbox = session.sandboxes.get_sandbox(\"main\")\nresult, exit_code = sandbox.run_command_in_container(\"pwd\")\nprint(f\"Working dir: {result}\")\n</code></pre>"},{"location":"Testing-Debugging/#logging","title":"Logging","text":"<p>SAGE-X uses structured logging:</p> <pre><code>import logging\nlogger = logging.getLogger(__name__)\nlogger.info(\"Operation started\", extra={\"session_id\": session_id})\n</code></pre>"},{"location":"Testing-Debugging/#common-debugging-tasks","title":"Common Debugging Tasks","text":"<ul> <li>Check session logs</li> <li>Verify sandbox container status</li> <li>Check configuration values</li> <li>Verify tool imports</li> <li>Check ADK compatibility</li> </ul>"},{"location":"Testing-Debugging/#see-also","title":"See Also","text":"<ul> <li>Troubleshooting - Common issues and solutions</li> <li>Best Practices - Development best practices</li> </ul>"},{"location":"Troubleshooting/","title":"Troubleshooting","text":""},{"location":"Troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"Troubleshooting/#session-not-found","title":"Session not found","text":"<p>Problem: Session lookup fails</p> <p>Solutions: - Ensure session was created before use - Check session ID matches exactly - Verify session hasn't been cleaned up</p>"},{"location":"Troubleshooting/#sandbox-not-initialized","title":"Sandbox not initialized","text":"<p>Problem: Sandbox access fails or sandbox is not ready</p> <p>Solutions: - Check sandbox initializer ran successfully - Verify configuration has sandbox settings - Check logs for initialization errors - Wait for sandbox to be ready: <code>await session.sandboxes.wait_for_ready(\"main\")</code></p>"},{"location":"Troubleshooting/#tool-not-found","title":"Tool not found","text":"<p>Problem: Agent cannot find or use a tool</p> <p>Solutions: - Verify tool is in agent's tools list - Check tool decorators are correct - Ensure tool is importable - Check tool metadata if using dynamic loading</p>"},{"location":"Troubleshooting/#configuration-not-loading","title":"Configuration not loading","text":"<p>Problem: Configuration errors or missing values</p> <p>Solutions: - Verify TOML file syntax - Check template variable expansion - Ensure config path is correct - Validate required fields are present</p>"},{"location":"Troubleshooting/#debug-checklist","title":"Debug Checklist","text":"<p>When debugging issues, check:</p> <ul> <li>[ ] Check session logs</li> <li>[ ] Verify sandbox container status</li> <li>[ ] Check configuration values</li> <li>[ ] Verify tool imports</li> <li>[ ] Check ADK compatibility</li> <li>[ ] Review error messages carefully</li> </ul>"},{"location":"Troubleshooting/#getting-help","title":"Getting Help","text":"<ul> <li>Check Common Patterns for examples</li> <li>Review Best Practices for guidelines</li> <li>Check GitHub issues for known problems</li> </ul>"},{"location":"Troubleshooting/#see-also","title":"See Also","text":"<ul> <li>Testing Debugging - Debugging techniques</li> <li>Development Guides - Development guides</li> </ul>"},{"location":"_Sidebar/","title":"Sidebar","text":""},{"location":"_Sidebar/#navigation","title":"Navigation","text":""},{"location":"_Sidebar/#home","title":"Home","text":"<ul> <li>Home</li> </ul>"},{"location":"_Sidebar/#getting-started","title":"Getting Started","text":"<ul> <li>Introduction</li> <li>Getting Started</li> <li>Project Structure</li> </ul>"},{"location":"_Sidebar/#entry-points","title":"Entry Points","text":"<ul> <li>Entry Points</li> <li>Aigise Web Entry</li> <li>Evaluation Entry</li> <li>RL Integration</li> </ul>"},{"location":"_Sidebar/#architecture","title":"Architecture","text":"<ul> <li>Architecture</li> <li>Core Components</li> <li>Core Concepts</li> <li>System Workflow (planned)</li> <li>Memory System (planned)</li> </ul>"},{"location":"_Sidebar/#development","title":"Development","text":"<ul> <li>Development Guides</li> <li>Adding Tools</li> <li>Adding Sandboxes</li> <li>Adding Evaluations</li> </ul>"},{"location":"_Sidebar/#practices","title":"Practices","text":"<ul> <li>Best Practices</li> <li>Common Patterns</li> <li>Testing Debugging</li> </ul>"},{"location":"_Sidebar/#reference","title":"Reference","text":"<ul> <li>Configuration</li> <li>Troubleshooting</li> <li>Contributing</li> </ul>"}]}