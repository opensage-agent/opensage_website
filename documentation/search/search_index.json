{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OpenSage Development Wiki","text":"<p>Welcome to the OpenSage Development Documentation!</p> <p>OpenSage (Open Self-programming Agent Generation Engine) is an AI agent framework built on top of Google ADK.</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Introduction - Project overview and features</li> <li>Getting Started - Quick start guide</li> <li>Architecture - System architecture overview</li> <li>Core Concepts - Core concepts explained</li> </ul>"},{"location":"#documentation-index","title":"Documentation Index","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Introduction - What is OpenSage?</li> <li>Getting Started - Environment setup and installation</li> <li>Project Structure - Project structure overview</li> </ul>"},{"location":"#entry-points","title":"Entry Points","text":"<ul> <li>Entry Points - Overview of entry points</li> <li>OpenSage Web Entry - Interactive web UI workflow</li> <li>Evaluation Entry - Batch evaluation workflow</li> <li>RL Integration - RL framework integration for agent training</li> </ul>"},{"location":"#core-topics","title":"Core Topics","text":"<ul> <li>Architecture - Architecture design</li> <li>Core Components - Core components explained</li> <li>Core Concepts - Core concepts (Sessions, Agents, Sandboxes)</li> </ul>"},{"location":"#development-guides","title":"Development Guides","text":"<ul> <li>Development Guides - Development guide overview</li> <li>Adding Tools - How to add new tools</li> <li>Sandboxes - Sandbox backends and how to add new sandboxes</li> <li>Adding Evaluations - How to add evaluation benchmarks</li> </ul>"},{"location":"#practices","title":"Practices","text":"<ul> <li>Best Practices - Best practices</li> <li>Common Patterns - Common code patterns</li> <li>Testing Debugging - Testing and debugging</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Contributing - Contributing guidelines</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Session-based resource management with isolation</li> <li>Multi-sandbox support (Docker, Kubernetes)</li> <li>Security tool integration (Joern, CodeQL, GDB, Neo4j)</li> <li>Dynamic tool loading</li> <li>Evaluation framework</li> </ul>"},{"location":"#getting-started_1","title":"Getting Started","text":"<p>If you're new to OpenSage, we recommend reading in this order:</p> <ol> <li>Introduction - Learn about the project</li> <li>Getting Started - Set up your environment</li> <li>Core Concepts - Understand core concepts</li> <li>Development Guides - Start developing</li> </ol> <p>Check the GitHub repository for the latest code</p>"},{"location":"API-Reference/","title":"API Reference","text":"<p>This section is the API reference for the OpenSage/SAGE-X codebase.</p>"},{"location":"Adding-Evaluations/","title":"Adding a New Evaluation Benchmark","text":""},{"location":"Adding-Evaluations/#overview","title":"Overview","text":"<p>Evaluations are used to benchmark agent performance on specific tasks. The evaluation system in AIgiSE is built on top of the base <code>Evaluation</code> class, which provides a complete framework for running benchmarks, managing sandboxes, collecting outputs, and generating metrics.</p>"},{"location":"Adding-Evaluations/#entry-points","title":"Entry Points","text":"<p>The <code>Evaluation</code> class provides multiple entry points for running evaluations, each suited for different use cases:</p>"},{"location":"Adding-Evaluations/#1-generate-multiprocessing-mode-default","title":"1. <code>generate()</code> - Multiprocessing Mode (Default)","text":"<ul> <li>Uses <code>ProcessPoolExecutor</code> for true parallelism</li> <li>Each sample runs in a separate process</li> <li>Best for production runs with maximum parallelism</li> <li>Bypasses Python's GIL for true concurrent execution</li> </ul>"},{"location":"Adding-Evaluations/#2-generate_threaded-multithreading-mode","title":"2. <code>generate_threaded()</code> - Multithreading Mode","text":"<ul> <li>Uses <code>ThreadPoolExecutor</code> for parallel execution</li> <li>Each sample runs in a separate thread</li> <li>Useful when multiprocessing has serialization issues</li> <li>Shares memory across threads</li> </ul>"},{"location":"Adding-Evaluations/#3-generate_single_thread-single-threaded-mode","title":"3. <code>generate_single_thread()</code> - Single-Threaded Mode","text":"<ul> <li>Sequential execution in a single thread</li> <li>Best for debugging and development</li> <li>Easiest to debug with step-by-step execution</li> </ul>"},{"location":"Adding-Evaluations/#4-run-auto-select-mode","title":"4. <code>run()</code> - Auto-Select Mode","text":"<ul> <li>Automatically selects execution mode based on <code>use_multiprocessing</code> flag</li> <li>If <code>use_multiprocessing=True</code>: calls <code>generate()</code> (multiprocessing)</li> <li>If <code>use_multiprocessing=False</code>: calls <code>generate_threaded()</code> (multithreading)</li> <li>Calls <code>evaluate()</code> after generation completes</li> <li>Recommended for most use cases</li> </ul>"},{"location":"Adding-Evaluations/#5-run_debug-debug-mode","title":"5. <code>run_debug()</code> - Debug Mode","text":"<ul> <li>Calls <code>generate_single_thread()</code> followed by <code>evaluate()</code></li> <li>Best for debugging and development</li> <li>Slower but easier to debug</li> </ul>"},{"location":"Adding-Evaluations/#usage-example","title":"Usage Example","text":"<p>Evaluations use Python Fire for command-line interface. You can run evaluations in several ways:</p> <p>Using command-line (recommended):</p> <pre><code># Option 1: Auto-select mode (uses generate() or generate_threaded() based on use_multiprocessing)\npython -m aigise.evaluations.my_benchmark.my_evaluation \\\n  --dataset_path=\"org/dataset\" \\\n  --agent_dir=\"examples/agents/my_agent\" \\\n  --max_workers=6 \\\n  --use_multiprocessing=true \\\n  run\n\n# Option 2: Explicit multiprocessing mode\npython -m aigise.evaluations.my_benchmark.my_evaluation \\\n  --dataset_path=\"org/dataset\" \\\n  --agent_dir=\"examples/agents/my_agent\" \\\n  generate\n\n# Option 3: Multithreading mode\npython -m aigise.evaluations.my_benchmark.my_evaluation \\\n  --dataset_path=\"org/dataset\" \\\n  --agent_dir=\"examples/agents/my_agent\" \\\n  generate_threaded\n\n# Option 4: Single-threaded debugging mode\npython -m aigise.evaluations.my_benchmark.my_evaluation \\\n  --dataset_path=\"org/dataset\" \\\n  --agent_dir=\"examples/agents/my_agent\" \\\n  run_debug\n\n# Or using direct file path\npython src/aigise/evaluations/my_benchmark/my_evaluation.py \\\n  --dataset_path=\"org/dataset\" \\\n  --agent_dir=\"examples/agents/my_agent\" \\\n  run\n</code></pre> <p>Using Python API:</p> <pre><code>from aigise.evaluations import MyEvaluation\n\n# Create evaluation instance\neval = MyEvaluation(\n    dataset_path=\"org/dataset\",\n    agent_dir=\"examples/agents/my_agent\",\n    max_workers=6,\n    use_multiprocessing=True,\n)\n\n# Option 1: Auto-select mode (recommended)\neval.run()\n\n# Option 2: Explicit multiprocessing\neval.generate()\n\n# Option 3: Multithreading\neval.generate_threaded()\n\n# Option 4: Single-threaded debugging\neval.run_debug()\n</code></pre>"},{"location":"Adding-Evaluations/#steps-to-create-a-new-evaluation","title":"Steps to Create a New Evaluation","text":""},{"location":"Adding-Evaluations/#1-create-evaluation-module","title":"1. Create Evaluation Module","text":"<p>Create a new directory under <code>src/aigise/evaluations/</code> with your benchmark name:</p> <pre><code>src/aigise/evaluations/\n\u2514\u2500\u2500 my_benchmark/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 my_evaluation.py\n</code></pre>"},{"location":"Adding-Evaluations/#2-implement-evaluation-class","title":"2. Implement Evaluation Class","text":"<p>Create a class that inherits from <code>Evaluation</code> and implements required abstract methods:</p> <pre><code>from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom pathlib import Path\n\nfrom aigise.evaluations import Evaluation, EvaluationTask\n\n@dataclass\nclass MyEvaluation(Evaluation):\n    \"\"\"Custom evaluation benchmark.\n\n    This class is automatically registered by name (lowercase).\n    You can retrieve it later using: get_evaluation_class(\"myevaluation\")\n    \"\"\"\n\n    # Required fields from parent class\n    dataset_path: str = \"org/dataset_name\"  # HuggingFace dataset or local path\n    agent_dir: str = \"examples/agents/my_agent\"  # Directory containing agent.py\n\n    # Optional configuration overrides\n    max_llm_calls: int = 100\n    max_workers: int = 6\n    use_multiprocessing: bool = True\n    run_until_explicit_finish: bool = True\n    use_cache: bool = True\n\n    # Custom fields for your benchmark\n    custom_param: str = \"default_value\"\n\n    # Implement required abstract methods\n    def _get_sample_id(self, sample: dict) -&gt; str:\n        \"\"\"Extract unique task ID from sample.\n\n        This ID is used for:\n        - Output directory naming\n        - Task identification in logs\n        - Result tracking\n        \"\"\"\n        return sample[\"task_id\"]  # or sample.get(\"id\"), etc.\n\n    def _get_user_msg_first(self, sample: dict) -&gt; str:\n        \"\"\"Extract the initial prompt/message to send to agent.\n\n        This is the first message that will trigger agent execution.\n        \"\"\"\n        return sample[\"prompt\"]  # or sample.get(\"question\"), etc.\n\n    # Optional: Override methods for custom behavior\n    def _get_dataset(self) -&gt; datasets.Dataset:\n        \"\"\"Load dataset with custom filtering or preprocessing.\"\"\"\n        dataset = super()._get_dataset()\n        # Add custom filtering logic if needed\n        # dataset = dataset.filter(lambda x: x[\"difficulty\"] == \"hard\")\n        return dataset\n\n    def _create_task(self, sample: dict) -&gt; EvaluationTask:\n        \"\"\"Create custom task with additional fields if needed.\"\"\"\n        task = super()._create_task(sample)\n        # Add custom fields to task if needed\n        return task\n\n    def _get_input_data_path(self, sample: dict) -&gt; str:\n        \"\"\"Specify input data directory for this sample.\"\"\"\n        task_id = self._get_sample_id(sample)\n        return str(Path(self.input_data_path) / task_id) if self.input_data_path else \"\"\n\n    def _get_cache_dir(self, sample: dict) -&gt; str:\n        \"\"\"Specify cache directory for sandbox state.\"\"\"\n        task_id = self._get_sample_id(sample)\n        return str(Path(self.cache_dir) / task_id) if self.cache_dir else \"\"\n\n    def _get_output_dir_in_sandbox(self, sample: dict) -&gt; str | tuple | None:\n        \"\"\"Specify which sandbox directories to export after execution.\"\"\"\n        return \"/output\"  # or (\"/output1\", \"/output2\") for multiple dirs\n\n    def customized_modify_and_save_results(\n        self,\n        *,\n        results: list | None,\n        failed_samples: list[str] | None,\n        mode: str,\n    ) -&gt; None:\n        \"\"\"Post-process and save aggregated results after all samples complete.\n\n        Args:\n            results: List of successful sample outputs\n            failed_samples: List of task IDs that failed\n            mode: Execution mode (\"multiprocess\", \"threaded\", or \"single_thread\")\n        \"\"\"\n        # Calculate metrics, save summary, etc.\n        pass\n\n    def evaluate(self) -&gt; None:\n        \"\"\"Analyze collected results and generate final metrics.\n\n        This is called after generate() completes. Implement your\n        evaluation logic here (accuracy, pass rate, etc.).\n        \"\"\"\n        # Load results from output_dir\n        # Calculate metrics\n        # Save evaluation report\n        pass\n</code></pre>"},{"location":"Adding-Evaluations/#3-configuration-template","title":"3. Configuration Template","text":"<p>Create a configuration template in <code>src/aigise/evaluations/configs/</code>:</p> <pre><code># src/aigise/evaluations/configs/my_benchmark_config.toml\n[llm]\nmodel_name = \"gemini-2.0-flash-exp\"\ntemperature = 0.7\n\n[sandbox]\n[sandbox.main]\ntype = \"docker\"\nimage = \"python:3.11\"\nworking_dir = \"/workspace\"\n\n# Template variables can be used:\n# ${TASK_NAME} - Replaced with actual task ID\n# ${PROJECT_RELATIVE_SHARED_DATA_PATH} - Replaced with data path\n</code></pre>"},{"location":"Adding-Evaluations/#4-registration","title":"4. Registration","text":"<p>The evaluation class is automatically registered when imported. The registration name is the lowercase class name.</p> <p>Example: - Class name: <code>MyEvaluation</code> \u2192 Registered as: <code>\"myevaluation\"</code> - Retrieve with: <code>get_evaluation_class(\"myevaluation\")</code></p>"},{"location":"Adding-Evaluations/#5-running-the-evaluation","title":"5. Running the Evaluation","text":"<p>Since evaluations use Python Fire, you can run them from command-line:</p> <pre><code># Run with auto-select mode (recommended)\npython -m aigise.evaluations.my_benchmark.my_evaluation \\\n  --dataset_path=\"org/dataset\" \\\n  --agent_dir=\"examples/agents/my_agent\" \\\n  --max_workers=6 \\\n  --output_dir=\"results/my_benchmark\" \\\n  run\n\n# Or for debugging (single-threaded)\npython -m aigise.evaluations.my_benchmark.my_evaluation \\\n  --dataset_path=\"org/dataset\" \\\n  --agent_dir=\"examples/agents/my_agent\" \\\n  run_debug\n\n# Or directly specify execution method\npython -m aigise.evaluations.my_benchmark.my_evaluation \\\n  --dataset_path=\"org/dataset\" \\\n  --agent_dir=\"examples/agents/my_agent\" \\\n  generate  # or generate_threaded, generate_single_thread\n</code></pre> <p>Or programmatically:</p> <pre><code>from aigise.evaluations import MyEvaluation\n\n# Create and run\neval = MyEvaluation(\n    dataset_path=\"org/dataset\",\n    agent_dir=\"examples/agents/my_agent\",\n    output_dir=\"results/my_benchmark\",  # Optional, auto-generated if not provided\n    max_workers=6,\n)\n\n# Run evaluation\neval.run()  # or eval.run_debug() for debugging\n</code></pre>"},{"location":"Adding-Evaluations/#evaluation-lifecycle","title":"Evaluation Lifecycle","text":"<p>Each evaluation sample goes through the following lifecycle:</p> <ol> <li>Task Creation (<code>_create_task()</code>)</li> <li>Convert dataset sample to <code>EvaluationTask</code></li> <li> <p>Extract task ID, prompt, paths, etc.</p> </li> <li> <p>Environment Preparation (<code>_prepare_environment()</code>)</p> </li> <li>Initialize AIgiSE session</li> <li>Load/launch sandboxes</li> <li>Set up Neo4j (if enabled)</li> <li> <p>Load cached sandbox states (if <code>use_cache=True</code>)</p> </li> <li> <p>Agent Preparation (<code>_prepare_agent()</code>)</p> </li> <li>Load <code>mk_agent</code> function from <code>agent_dir</code></li> <li>Create agent instance</li> <li> <p>Configure model (if <code>use_config_model=True</code>)</p> </li> <li> <p>Agent Execution (<code>_run_agent()</code>)</p> </li> <li>Send prompt to agent</li> <li>Run agent with configured limits</li> <li>Track LLM calls, costs, etc.</li> <li> <p>Handle <code>run_until_explicit_finish</code> loop</p> </li> <li> <p>Output Collection (<code>_collect_outputs()</code>)</p> </li> <li>Export sandbox outputs (if <code>output_dir_in_sandbox</code> specified)</li> <li>Export Neo4j database</li> <li>Save session trace</li> <li> <p>Calculate cost information</p> </li> <li> <p>Cleanup</p> </li> <li>Clean up sandboxes</li> <li>Close sessions</li> <li>Save error information (if failed)</li> </ol>"},{"location":"Adding-Evaluations/#key-methods-to-override","title":"Key Methods to Override","text":""},{"location":"Adding-Evaluations/#required-abstract-methods","title":"Required Abstract Methods","text":"<ul> <li><code>_get_sample_id(sample: dict) -&gt; str</code>: Extract unique task ID</li> <li><code>_get_user_msg_first(sample: dict) -&gt; str</code>: Extract initial prompt</li> </ul>"},{"location":"Adding-Evaluations/#optional-methods-with-defaults","title":"Optional Methods (with Defaults)","text":"<ul> <li><code>_get_dataset() -&gt; datasets.Dataset</code>: Load and filter dataset</li> <li><code>_create_task(sample: dict) -&gt; EvaluationTask</code>: Create task instance</li> <li><code>_get_input_data_path(sample: dict) -&gt; str</code>: Input data directory</li> <li><code>_get_cache_dir(sample: dict) -&gt; str</code>: Cache directory</li> <li><code>_get_output_dir_in_sandbox(sample: dict) -&gt; str | tuple | None</code>: Output dirs to export</li> <li><code>_prepare_general_env() -&gt; None</code>: Setup shared across all samples</li> <li><code>_before_initialize_hooks(aigise_session, task) -&gt; None</code>: Hooks before sandbox init</li> <li><code>customized_modify_and_save_results(results, failed_samples, mode) -&gt; None</code>: Post-processing</li> <li><code>evaluate() -&gt; None</code>: Final evaluation and metrics</li> </ul>"},{"location":"Adding-Evaluations/#output-structure","title":"Output Structure","text":"<p>Each evaluation run creates an output directory with the following structure:</p> <pre><code>evals/\n\u2514\u2500\u2500 myevaluation/\n    \u2514\u2500\u2500 yymmdd_HHMMSS/\n        \u251c\u2500\u2500 evaluation_master.log       # Master log for entire run\n        \u251c\u2500\u2500 eval_params.json            # Evaluation parameters\n        \u251c\u2500\u2500 task_001/\n        \u2502   \u251c\u2500\u2500 execution_debug.log     # DEBUG-level log\n        \u2502   \u251c\u2500\u2500 execution_info.log      # INFO-level log\n        \u2502   \u251c\u2500\u2500 config_used.toml        # Config used for this task\n        \u2502   \u251c\u2500\u2500 cost_info.json          # Token usage and costs\n        \u2502   \u251c\u2500\u2500 session_trace.json      # Complete session events\n        \u2502   \u251c\u2500\u2500 session_trace.txt       # Human-readable trace\n        \u2502   \u251c\u2500\u2500 metadata.json           # Task metadata\n        \u2502   \u251c\u2500\u2500 sandbox_output/         # Exported from sandbox\n        \u2502   \u2514\u2500\u2500 neo4j_history/          # Neo4j database export\n        \u2514\u2500\u2500 task_002/\n            \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"Adding-Evaluations/#configuration-options","title":"Configuration Options","text":"<p>Key configuration options available in <code>Evaluation</code>:</p> Option Type Default Description <code>dataset_path</code> str Required HuggingFace dataset or local path <code>agent_dir</code> str Required Directory with <code>agent.py</code> <code>max_llm_calls</code> int 100 Maximum LLM calls per task <code>max_workers</code> int 6 Parallel workers <code>use_multiprocessing</code> bool True Use multiprocessing vs threading <code>use_cache</code> bool True Load/cache sandbox states <code>run_until_explicit_finish</code> bool True Keep running until task finished <code>use_config_model</code> bool False Use model from config file <code>llm_retry_count</code> int 3 Retries for LLM API calls <code>llm_retry_timeout</code> int 30 Timeout per LLM request (seconds) <code>log_level</code> str \"INFO\" Terminal log level"},{"location":"Adding-Evaluations/#examples","title":"Examples","text":"<p>See existing evaluations for reference:</p> <ul> <li><code>src/aigise/evaluations/cybergym/__init__.py</code> - Base class of evaluation</li> <li><code>src/aigise/evaluations/cybergym/cybergym_static.py</code> - Full-featured evaluation</li> <li><code>src/aigise/evaluations/mock_debug/mock_debug_evaluation.py</code> - Minimal example</li> <li><code>src/aigise/evaluations/secodeplt/vul_detection.py</code> - Another example</li> </ul>"},{"location":"Adding-Evaluations/#see-also","title":"See Also","text":"<ul> <li>Development Guides - Other development guides</li> <li>Testing Debugging - Testing evaluations</li> <li><code>src/aigise/evaluations/__init__.py</code> - Base Evaluation class implementation</li> </ul>"},{"location":"Adding-Tools/","title":"Adding a New Tool","text":""},{"location":"Adding-Tools/#overview","title":"Overview","text":"<p>In OpenSage, tools are implemented as Agent Skills (bash scripts) or MCP toolsets (Model Context Protocol), rather than Python functions. This design allows tools to be executed directly in sandbox containers via bash commands, providing better isolation and flexibility.</p>"},{"location":"Adding-Tools/#tool-types","title":"Tool Types","text":""},{"location":"Adding-Tools/#1-agent-skills-bash-scripts","title":"1. Agent Skills (Bash Scripts)","text":"<p>Agent Skills are bash scripts organized in a structured directory format with metadata. They are automatically discovered and loaded by the framework.</p>"},{"location":"Adding-Tools/#2-mcp-toolsets","title":"2. MCP Toolsets","text":"<p>MCP (Model Context Protocol) toolsets provide integration with external services or tools running in separate containers, typically accessed via SSE (Server-Sent Events) connections.</p>"},{"location":"Adding-Tools/#creating-an-agent-skill","title":"Creating an Agent Skill","text":""},{"location":"Adding-Tools/#directory-structure","title":"Directory Structure","text":"<p>Create a skill directory under <code>src/&lt;package&gt;/bash_tools/</code>:</p> <pre><code>src/&lt;package&gt;/bash_tools/\n\u2514\u2500\u2500 category/\n    \u2514\u2500\u2500 tool-name/\n        \u251c\u2500\u2500 SKILL.md          # Tool metadata and documentation\n        \u2514\u2500\u2500 scripts/\n            \u2514\u2500\u2500 tool_script.sh # The actual bash script\n</code></pre> <p>Example structure: <pre><code>src/&lt;package&gt;/bash_tools/\n\u2514\u2500\u2500 retrieval/\n    \u2514\u2500\u2500 grep/\n        \u251c\u2500\u2500 SKILL.md\n        \u2514\u2500\u2500 scripts/\n            \u2514\u2500\u2500 grep.sh\n</code></pre></p>"},{"location":"Adding-Tools/#skillmd-format","title":"SKILL.md Format","text":"<p>The <code>SKILL.md</code> file contains YAML frontmatter and markdown documentation:</p> <pre><code>---\nname: tool-name\ndescription: Brief description of what the tool does\n---\n\n# Tool Name\n\nDetailed description of the tool's functionality.\n\n## Usage\n\n```bash\nscripts/tool_script.sh arg1 arg2 --option value\n</code></pre>"},{"location":"Adding-Tools/#parameters","title":"Parameters","text":""},{"location":"Adding-Tools/#param1-required-positional-position-0","title":"param1 (required, positional position 0)","text":"<p>Type: <code>str</code></p> <p>Description of the parameter.</p>"},{"location":"Adding-Tools/#param2-optional-positional-position-1","title":"param2 (optional, positional position 1)","text":"<p>Type: <code>int</code></p> <p>Description of the parameter.</p>"},{"location":"Adding-Tools/#-option-optional-named-parameter","title":"--option (optional, named parameter)","text":"<p>Type: <code>str</code></p> <p>Description of the option.</p>"},{"location":"Adding-Tools/#-flag-optional-flag","title":"--flag (optional, flag)","text":"<p>Type: <code>bool</code> (default: <code>false</code>)</p> <p>Description of the flag.</p>"},{"location":"Adding-Tools/#return-value","title":"Return Value","text":"<p>Returns a JSON object with results:</p> <pre><code>{\n  \"success\": true,\n  \"result\": \"...\"\n}\n</code></pre>"},{"location":"Adding-Tools/#requires-sandbox","title":"Requires Sandbox","text":"<p>main</p>"},{"location":"Adding-Tools/#timeout","title":"Timeout","text":"<p>Default timeout: 60 seconds <pre><code>### Parameter Types\n\n- **Positional parameters**: Specified with `positional position N` in the parameter description\n- **Named parameters**: Use `--param_name value` format\n- **Boolean flags**: Use `--flag` (no value needed)\n\n### Bash Script Implementation\n\nThe bash script should:\n\n1. Accept command-line arguments (positional and named)\n2. Return JSON output for structured results\n3. Use proper exit codes (0 for success, non-zero for errors)\n\n**Example script:**\n\n```bash\n#!/bin/bash\n\n# tool_script.sh - Tool description\n# Usage: ./tool_script.sh param1 param2 --option value\n\nif [ -z \"$1\" ]; then\n    echo '{\"error\": \"Missing required parameter\"}'\n    exit 1\nfi\n\nPARAM1=\"$1\"\nPARAM2=\"${2:-default}\"\n\n# Process --option if provided\nOPTION=\"\"\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --option)\n            OPTION=\"$2\"\n            shift 2\n            ;;\n        *)\n            shift\n            ;;\n    esac\ndone\n\n# Tool logic here\nRESULT=$(some_command \"$PARAM1\" \"$PARAM2\")\n\n# Return JSON\necho \"{\\\"success\\\": true, \\\"result\\\": \\\"$RESULT\\\"}\"\n</code></pre></p>"},{"location":"Adding-Tools/#sandbox-requirements","title":"Sandbox Requirements","text":"<p>Specify required sandbox types in the <code>## Requires Sandbox</code> section:</p> <pre><code>## Requires Sandbox\n\nmain\n</code></pre> <p>Or for multiple sandboxes:</p> <pre><code>## Requires Sandbox\n\nmain, fuzz\n</code></pre>"},{"location":"Adding-Tools/#automatic-discovery","title":"Automatic Discovery","text":"<p>Tools are automatically discovered from: - <code>src/&lt;package&gt;/bash_tools/</code> (built-in tools) - <code>~/.local/plugins/&lt;product&gt;/tools/</code> (user plugins)</p> <p>The framework scans these directories for <code>SKILL.md</code> files and loads them automatically.</p>"},{"location":"Adding-Tools/#creating-an-mcp-toolset","title":"Creating an MCP Toolset","text":"<p>MCP toolsets are created via Python functions that return <code>MCPToolset</code> instances:</p> <pre><code># src/&lt;package&gt;/toolbox/category/get_toolset.py\nfrom google.adk.tools.mcp_tool.mcp_toolset import MCPToolset, SseConnectionParams\nfrom &lt;package&gt;.toolbox.decorators import requires_sandbox, safe_tool_execution\nfrom &lt;package&gt;.utils.agent_utils import get_mcp_url_from_session_id\n\n@safe_tool_execution\n@requires_sandbox(\"gdb_mcp\")\ndef get_toolset(aigise_session_id: str) -&gt; MCPToolset:\n    \"\"\"Create MCPToolset with GDB MCP server running in Docker container.\n\n    Args:\n        aigise_session_id: Shared session ID for session-based management\n\n    Returns:\n        MCPToolset connected to GDB MCP server\n    \"\"\"\n    url = get_mcp_url_from_session_id(\"gdb_mcp\", aigise_session_id)\n    mcp_toolset = MCPToolset(connection_params=SseConnectionParams(url=url))\n    return mcp_toolset\n</code></pre> <p>The function should: - Use <code>@safe_tool_execution</code> decorator - Use <code>@requires_sandbox</code> to specify required sandbox types - Return an <code>MCPToolset</code> instance - Be registered in the agent's tools list</p>"},{"location":"Adding-Tools/#tool-registration","title":"Tool Registration","text":""},{"location":"Adding-Tools/#for-agent-skills","title":"For Agent Skills","text":"<p>Agent Skills are automatically discovered and registered. No manual registration needed.</p>"},{"location":"Adding-Tools/#for-mcp-toolsets","title":"For MCP Toolsets","text":"<p>Add the toolset getter function to your agent's tools:</p> <pre><code>from &lt;package&gt;.toolbox.category.get_toolset import get_toolset\n\nagent = AigiseAgent(\n    name=\"my_agent\",\n    tools=[get_toolset, ...],  # Add the getter function\n    ...\n)\n</code></pre>"},{"location":"Adding-Tools/#best-practices","title":"Best Practices","text":"<ol> <li>Use bash scripts for container operations: Prefer bash scripts for tools that interact with sandbox containers</li> <li>Return JSON: Always return structured JSON from bash scripts for easy parsing</li> <li>Document thoroughly: Include clear parameter descriptions and usage examples in <code>SKILL.md</code></li> <li>Handle errors gracefully: Use proper exit codes and error messages</li> <li>Specify sandbox requirements: Always document which sandboxes are required</li> <li>Use MCP for external services: Use MCP toolsets for tools that run in separate containers or services</li> </ol>"},{"location":"Adding-Tools/#see-also","title":"See Also","text":"<ul> <li>Common Patterns - Tool development patterns</li> <li>Best Practices - Best practices for tools</li> <li>Core Concepts - Understanding tools in context</li> </ul>"},{"location":"Architecture/","title":"Architecture Overview","text":""},{"location":"Architecture/#design-principles","title":"Design Principles","text":"<ol> <li>Session Isolation: Each session has its own resources (sandboxes, configs, agents)</li> <li>No Global Singletons: All resources are session-bound</li> <li>Composability: Build complex agents from simple components</li> <li>Tool Integration: Seamless integration with security analysis tools</li> <li>Extensibility: Easy to add new tools, sandboxes, and agents</li> </ol>"},{"location":"Architecture/#component-relationships","title":"Component Relationships","text":"<ul> <li>AigiseSession is the central manager that coordinates all resources</li> <li>AigiseAgent extends ADK agents with self-programming capabilities</li> <li>Sandboxes provide isolated execution environments</li> <li>Configuration is TOML-based with template variables</li> <li>Tools are dynamically loaded and session-aware</li> </ul>"},{"location":"Architecture/#see-also","title":"See Also","text":"<ul> <li>Core Components - Detailed component descriptions</li> <li>Core Concepts - Core concepts explained</li> <li>Project Structure - Code organization</li> </ul>"},{"location":"Benchmarking/","title":"Benchmarking","text":"<p>This section covers how to evaluate OpenSage/SAGE-X agents and measure performance across tasks.</p>"},{"location":"Benchmarking/#what-youll-find-here","title":"What you'll find here","text":"<ul> <li>How to run built-in evaluations (entry point + workflow)</li> <li>How to add a new evaluation/benchmark to the repo</li> <li>Recommended reporting and reproducibility practices</li> </ul>"},{"location":"Benchmarking/#entry-points","title":"Entry points","text":"<ul> <li>Evaluation Entry: Batch evaluation workflow and   lifecycle.</li> <li>Adding Evaluations: How to integrate a new benchmark.</li> </ul>"},{"location":"Best-Practices/","title":"Best Practices","text":""},{"location":"Best-Practices/#session-management","title":"Session Management","text":"<ul> <li>Always use <code>get_aigise_session()</code> instead of creating sessions directly</li> <li>Clean up sessions when done: <code>cleanup_aigise_session(session_id)</code></li> <li>Use unique session IDs for different runs</li> </ul>"},{"location":"Best-Practices/#agent-development","title":"Agent Development","text":"<ul> <li>Keep agents focused on single responsibilities</li> <li>Use sub-agents for complex workflows</li> <li>Leverage tool combos for related tool groups</li> <li>Document tool parameters and return values</li> </ul>"},{"location":"Best-Practices/#tool-development","title":"Tool Development","text":""},{"location":"Best-Practices/#agent-skills-bash-scripts","title":"Agent Skills (Bash Scripts)","text":"<ul> <li>Create structured directory with <code>SKILL.md</code> and <code>scripts/</code> subdirectory</li> <li>Document all parameters in <code>SKILL.md</code> with types and descriptions</li> <li>Specify sandbox requirements in <code>## Requires Sandbox</code> section</li> <li>Return JSON output for structured results</li> <li>Use proper exit codes (0 for success, non-zero for errors)</li> <li>Handle errors gracefully with informative JSON error messages</li> <li>Use positional and named parameters appropriately</li> <li>Set appropriate timeout values</li> </ul>"},{"location":"Best-Practices/#mcp-toolsets","title":"MCP Toolsets","text":"<ul> <li>Use <code>@safe_tool_execution</code> decorator</li> <li>Use <code>@requires_sandbox</code> to specify required sandbox types</li> <li>Return <code>MCPToolset</code> instances from getter functions</li> <li>Document connection parameters and usage</li> </ul>"},{"location":"Best-Practices/#configuration","title":"Configuration","text":"<ul> <li>Use template variables for environment-specific values</li> <li>Document configuration options</li> <li>Validate configuration in initialization</li> <li>Provide sensible defaults</li> </ul>"},{"location":"Best-Practices/#code-organization","title":"Code Organization","text":"<ul> <li>Follow existing module structure</li> <li>Use relative imports in source code</li> <li>Use absolute imports in tests</li> <li>Add docstrings to public APIs</li> </ul>"},{"location":"Best-Practices/#see-also","title":"See Also","text":"<ul> <li>Common Patterns - Common code patterns</li> <li>Contributing - Contribution guidelines</li> </ul>"},{"location":"CHANGES/","title":"Documentation Changes","text":"<p>This file summarizes significant changes to the OpenSage documentation.</p>"},{"location":"CHANGES/#latest-updates","title":"Latest Updates","text":""},{"location":"CHANGES/#introductionmd-enhanced-selling-points-and-design-philosophy","title":"Introduction.md - Enhanced Selling Points and Design Philosophy","text":"<p>Date: Current update</p> <p>Changes Made:</p> <ol> <li>Expanded AI-Written Tools Section:</li> <li>Added detailed explanation of tools as \"first-class system entities\"</li> <li>Clarified the distinction between traditional tools and OpenSage's programmatic tools</li> <li> <p>Added design value propositions</p> </li> <li> <p>Enhanced Runtime Sub-Agents Section:</p> </li> <li>Added sub-agent positioning examples (Debugger, Retrieval, Fuzzer, Memory agents)</li> <li>Expanded on agent topology and dynamic graph concepts</li> <li> <p>Clarified agent ensemble capabilities</p> </li> <li> <p>Added System-Level Workflow Section (NEW - Planned Feature):</p> </li> <li>Rule-based execution model</li> <li>Graph-based scheduling</li> <li>Pub-sub event-driven coordination</li> <li> <p>Note: Feature is planned, placeholder documentation created</p> </li> <li> <p>Added Memory as Manageable System Resource Section (NEW - Planned Feature):</p> </li> <li>Layered memory model</li> <li>Graph-structured memory</li> <li>Memory agent concept</li> <li> <p>Note: Feature is planned, placeholder documentation created</p> </li> <li> <p>Enhanced Training Support Section:</p> </li> <li>Expanded Kubernetes-based rapid rollout details</li> <li>Enhanced integration details for AREL, VERL, and LLaMA Factory</li> <li> <p>Added rationale for why OpenSage works well for training</p> </li> <li> <p>Enhanced Security-Focused Customization Section:</p> </li> <li>Renamed to \"Security-Focused System-Level Customization\"</li> <li>Added more detailed capabilities</li> <li> <p>Emphasized the system-level nature of customization</p> </li> <li> <p>Updated Key Features List:</p> </li> <li>Added planned features with notes</li> <li>Reorganized to match the selling points structure</li> </ol>"},{"location":"CHANGES/#new-files-created","title":"New Files Created","text":"<ol> <li>System-Workflow.md (removed):</li> <li>Placeholder documentation for planned system-level workflow feature</li> <li>Includes planned features: rule-based execution, graph-based scheduling, pub-sub events</li> <li> <p>Status: Planned/Under Development</p> </li> <li> <p>Memory-System.md (removed):</p> </li> <li>Placeholder documentation for planned memory system features</li> <li>Includes: layered memory, graph-structured memory, memory agent</li> <li> <p>Status: Planned/Under Development</p> </li> <li> <p>_Sidebar.md:</p> </li> <li>Updated to include links to new System-Workflow and Memory-System pages</li> </ol>"},{"location":"CHANGES/#previous-updates","title":"Previous Updates","text":""},{"location":"CHANGES/#project-name-change-aigise-opensage","title":"Project Name Change: AIgiSE \u2192 OpenSage","text":"<p>All documentation was updated to reflect the project name change from \"AIgiSE\" to \"OpenSage\" (Open Self-programming Agent Generation Engine).</p> <p>Note: Code paths and package names remain as <code>aigise</code> for functional reasons.</p>"},{"location":"CLI-Reference/","title":"CLI Reference","text":"<p>This section documents the OpenSage/SAGE-X command-line interface.</p>"},{"location":"CLI-Reference/#commands","title":"Commands","text":"<ul> <li><code>opensage</code>: Main CLI entry point</li> </ul> <p>See the generated reference pages:</p> <ul> <li>opensage</li> <li>opensage web</li> <li>opensage dependency-check</li> </ul>"},{"location":"CLI-Reference/#common-entry-points","title":"Common entry points","text":"<ul> <li>OpenSage Web Entry: Interactive development web UI</li> <li>Evaluation Entry: Batch evaluation entry point</li> </ul>"},{"location":"CLI-Reference/#auto-generation","title":"Auto-generation","text":"<p>The CLI reference pages above are generated at build time from <code>--help</code> output.</p>"},{"location":"Common-Patterns/","title":"Common Patterns","text":""},{"location":"Common-Patterns/#pattern-agent-skill-bash-script-tool","title":"Pattern: Agent Skill (Bash Script Tool)","text":"<p>Agent Skills are bash scripts organized in a structured format with <code>SKILL.md</code> metadata:</p> <pre><code>src/aigise/bash_tools/\n\u2514\u2500\u2500 category/\n    \u2514\u2500\u2500 tool-name/\n        \u251c\u2500\u2500 SKILL.md\n        \u2514\u2500\u2500 scripts/\n            \u2514\u2500\u2500 tool_script.sh\n</code></pre> <p>SKILL.md example:</p> <pre><code>---\nname: my-tool\ndescription: Tool description\n---\n\n# My Tool\n\n## Parameters\n\n### input (required, positional position 0)\n\n**Type**: `str`\n\nInput parameter description.\n\n### --option (optional, named parameter)\n\n**Type**: `str`\n\nOption description.\n\n## Requires Sandbox\n\nmain\n\n## Timeout\n\n60 seconds\n</code></pre> <p>Bash script example:</p> <pre><code>#!/bin/bash\n\nINPUT=\"$1\"\nOPTION=\"\"\n\n# Parse named parameters\nwhile [[ $# -gt 0 ]]; do\n    case $1 in\n        --option)\n            OPTION=\"$2\"\n            shift 2\n            ;;\n        *)\n            shift\n            ;;\n    esac\ndone\n\n# Tool logic\nRESULT=$(process \"$INPUT\" \"$OPTION\")\n\n# Return JSON\necho \"{\\\"success\\\": true, \\\"result\\\": \\\"$RESULT\\\"}\"\n</code></pre>"},{"location":"Common-Patterns/#pattern-multi-sandbox-skill","title":"Pattern: Multi-Sandbox Skill","text":"<p>For tools that require multiple sandboxes, specify in <code>SKILL.md</code>:</p> <pre><code>## Requires Sandbox\n\nmain, joern\n</code></pre> <p>The framework automatically ensures both sandboxes are available before executing the tool.</p>"},{"location":"Common-Patterns/#pattern-mcp-toolset","title":"Pattern: MCP Toolset","text":"<p>MCP toolsets provide integration with external services:</p> <pre><code>from google.adk.tools.mcp_tool.mcp_toolset import MCPToolset, SseConnectionParams\nfrom aigise.toolbox.decorators import requires_sandbox, safe_tool_execution\nfrom aigise.utils.agent_utils import get_mcp_url_from_session_id\n\n@safe_tool_execution\n@requires_sandbox(\"gdb_mcp\")\ndef get_gdb_toolset(aigise_session_id: str) -&gt; MCPToolset:\n    \"\"\"Create MCPToolset for GDB debugging.\"\"\"\n    url = get_mcp_url_from_session_id(\"gdb_mcp\", aigise_session_id)\n    return MCPToolset(connection_params=SseConnectionParams(url=url))\n</code></pre>"},{"location":"Common-Patterns/#pattern-dynamic-tool-discovery","title":"Pattern: Dynamic Tool Discovery","text":"<p>Tools are automatically discovered from: - <code>src/aigise/bash_tools/</code> (built-in tools) - <code>~/.local/plugins/aigise/tools/</code> (user plugins)</p> <p>The framework scans for <code>SKILL.md</code> files and loads them automatically. No manual registration needed.</p>"},{"location":"Common-Patterns/#pattern-agent-composition","title":"Pattern: Agent Composition","text":"<pre><code>def mk_agent(aigise_session_id: str) -&gt; AigiseAgent:\n    sub_agent = AigiseAgent(...)\n    sub_agent_tool = AgentTool(agent=sub_agent)\n\n    root_agent = AigiseAgent(\n        tools=[sub_agent_tool, ...],\n        sub_agents=[...]\n    )\n    return root_agent\n</code></pre>"},{"location":"Common-Patterns/#pattern-code-understanding-agent-with-memory-caching","title":"Pattern: Code Understanding Agent with Memory Caching","text":"<p>The Code Understanding Agent is a utility agent that caches question-answer pairs in Neo4j to avoid redundant computation. It can be used as a tool by other agents.</p> <p>Basic Usage:</p> <pre><code>from examples.agents.code_understanding_agent import create_code_understanding_agent_tool\nfrom google.adk.models import BaseLlm, Gemini\nfrom aigise.agents.aigise_agent import AigiseAgent\n\n# Create code understanding agent tool\ncode_tool = create_code_understanding_agent_tool(\n    model=Gemini(model=\"gemini-2.5-flash\"),\n    name=\"code_understanding_agent\",\n)\n\n# Use in another agent\norchestrator = AigiseAgent(\n    name=\"orchestrator\",\n    model=Gemini(model=\"gemini-2.5-flash\"),\n    tools=[code_tool, other_tools...],\n)\n</code></pre> <p>How It Works:</p> <ol> <li>Cache Lookup: Before answering a question, the agent first checks for semantically similar cached answers using <code>lookup_similar_answers</code></li> <li>Smart Reuse: If a highly similar answer exists (similarity &gt; 0.85), it reuses the cached answer directly</li> <li>Fresh Analysis: If no similar answer exists, it performs fresh code analysis using available tools</li> <li>Cache Storage: After generating a new answer, it stores it using <code>cache_qa_pair</code> for future use</li> </ol> <p>Available Tools:</p> <ul> <li><code>lookup_similar_answers</code>: Find semantically similar cached Q&amp;A pairs</li> <li><code>cache_qa_pair</code>: Store a new Q&amp;A pair in the cache</li> <li><code>list_cached_questions</code>: Browse cached questions</li> <li><code>get_cached_answer_by_id</code>: Retrieve full answer content by ID</li> <li>Code analysis tools: <code>search_function</code>, <code>grep_tool</code>, <code>list_functions_in_file</code>, etc.</li> </ul> <p>Benefits:</p> <ul> <li>Reduces redundant computation for repeated or similar questions</li> <li>Improves response time for cached queries</li> <li>Maintains context across multiple agent invocations</li> <li>Works seamlessly with Neo4j-based memory system</li> </ul> <p>See <code>examples/agents/code_understanding_agent/README.md</code> for more details.</p>"},{"location":"Common-Patterns/#see-also","title":"See Also","text":"<ul> <li>Best Practices - Best practices</li> <li>Development Guides - Development guides</li> <li>Core Concepts - Core concepts</li> </ul>"},{"location":"Community/","title":"Community","text":"<p>This section covers how the project is developed and how contributors can get involved.</p>"},{"location":"Community/#contributing","title":"Contributing","text":"<ul> <li>See Contributing</li> </ul>"},{"location":"Community/#support-and-feedback","title":"Support and feedback","text":"<ul> <li>GitHub issues: Please open an issue in <code>OpenSage-ADK/OpenSage</code> with steps to   reproduce, expected behavior, and logs if applicable.</li> <li>Discord: Join the community chat at   discord.gg/zbKe5ue8xc.</li> </ul>"},{"location":"Configuration/","title":"Configuration Guide","text":"<p>This document describes the OpenSage configuration system, including all configuration fields, their purposes, and how to write configuration files.</p>"},{"location":"Configuration/#overview","title":"Overview","text":"<p>OpenSage uses TOML (Tom's Obvious, Minimal Language) format for configuration files. The configuration system supports:</p> <ul> <li>Template Variables: Use <code>${VAR_NAME}</code> syntax for reusable values</li> <li>Nested Sections: Organize related settings into logical groups</li> <li>Environment Variable Support: Template variables can reference environment variables</li> <li>Type Safety: Automatic conversion to Python dataclasses with type checking</li> </ul>"},{"location":"Configuration/#configuration-file-location","title":"Configuration File Location","text":"<p>Configuration files are loaded in the following order:</p> <ol> <li>Default Configuration: <code>src/&lt;package&gt;/templates/configs/default_config.toml</code> (used when no config is specified)</li> <li>Custom Configuration: Path specified via <code>config_path</code> parameter when creating <code>AigiseSession</code></li> </ol>"},{"location":"Configuration/#configuration-structure","title":"Configuration Structure","text":"<p>The configuration is organized into several main sections:</p> <pre><code># Top-level template variables (optional)\nVARIABLE_NAME = \"value\"\n\n# Root-level fields\ntask_name = \"my_task\"\nsrc_dir_in_sandbox = \"/shared/code\"\ndefault_host = \"127.0.0.1\"\nauto_cleanup = true\n\n# Section-based configuration\n[neo4j]\n# Neo4j database configuration\n\n[sandbox]\n# Sandbox configuration\n\n[llm]\n# LLM model configuration\n\n[history]\n# History and tool response configuration\n\n[plugins]\n# Plugin configuration\n\n[agent_ensemble]\n# Agent ensemble configuration\n\n[build]\n# Build and execution configuration\n\n[mcp]\n# Model Context Protocol services configuration\n</code></pre>"},{"location":"Configuration/#template-variables","title":"Template Variables","text":"<p>OpenSage supports template variable expansion using <code>${VAR_NAME}</code> syntax.</p>"},{"location":"Configuration/#rules","title":"Rules:","text":"<ol> <li>Top-level UPPERCASE variables automatically become template variables</li> <li>Variables can be referenced anywhere using <code>${VAR_NAME}</code></li> <li>Variables are expanded recursively throughout the configuration</li> <li>Undefined variables cause an error at load time</li> </ol>"},{"location":"Configuration/#example","title":"Example:","text":"<pre><code># Define template variables (UPPERCASE)\nDEFAULT_IMAGE = \"ubuntu:20.04\"\nMAIN_MODEL = \"openai/gpt-4\"\nNEO4J_PASSWORD = \"mypassword123\"\n\n# Use template variables\n[sandbox.sandboxes.main]\nimage = \"${DEFAULT_IMAGE}\"\n\n[llm.model_configs.main]\nmodel_name = \"${MAIN_MODEL}\"\n\n[neo4j]\npassword = \"${NEO4J_PASSWORD}\"\n</code></pre>"},{"location":"Configuration/#configuration-sections","title":"Configuration Sections","text":""},{"location":"Configuration/#root-level-fields","title":"Root-Level Fields","text":"<p>These fields are defined at the top level of the configuration file:</p> Field Type Description Default <code>task_name</code> <code>string</code> Name identifier for the current task/session <code>None</code> <code>src_dir_in_sandbox</code> <code>string</code> Path to source code directory within sandbox containers <code>\"/shared/code\"</code> <code>agent_storage_path</code> <code>string</code> Path where dynamically created agents are stored <code>None</code> <code>default_host</code> <code>string</code> Default hostname for services (used by Neo4j and MCP services) <code>None</code> (falls back to <code>127.0.0.1</code>) <code>auto_cleanup</code> <code>boolean</code> Whether to automatically cleanup resources when session ends <code>true</code> <p>Example:</p> <pre><code>task_name = \"vulnerability_analysis\"\nsrc_dir_in_sandbox = \"/shared/code\"\nagent_storage_path = \"/tmp/agents\"\ndefault_host = \"localhost\"\nauto_cleanup = true\n</code></pre>"},{"location":"Configuration/#neo4j-configuration","title":"Neo4j Configuration","text":"<p>Configures the Neo4j graph database connection.</p> <p>Section: <code>[neo4j]</code></p>"},{"location":"Configuration/#sandbox-images-requirements-practical-notes","title":"Sandbox Images &amp; Requirements (Practical Notes)","text":"<p>Some sandboxes require Python tooling inside their Docker images. In the default configuration template (<code>src/&lt;package&gt;/templates/configs/default_config.toml</code>):</p> <ul> <li><code>sandbox.sandboxes.main</code></li> <li>Built from <code>src/&lt;package&gt;/templates/dockerfiles/main/Dockerfile</code></li> <li>Provides <code>python3</code> via <code>/app/.venv/bin/python</code></li> <li> <p>Installs Python package <code>neo4j</code> (used by <code>src/&lt;package&gt;/sandbox/initializers/main.py</code>)</p> </li> <li> <p><code>sandbox.sandboxes.joern</code></p> </li> <li>Built from <code>src/&lt;package&gt;/templates/dockerfiles/joern/Dockerfile</code></li> <li>Provides <code>python3</code> via <code>/app/.venv/bin/python</code></li> <li>Installs Python packages <code>httpx</code> and <code>websockets</code> (used by Joern query helper scripts)</li> </ul> <p>These images install Python deps using <code>uv</code> in the Dockerfile (create <code>/app/.venv</code> and run <code>uv pip install ...</code>), rather than at runtime inside a running container.</p> Field Type Description Default <code>user</code> <code>string</code> Neo4j username <code>None</code> <code>password</code> <code>string</code> Neo4j password <code>None</code> <code>bolt_port</code> <code>integer</code> Neo4j Bolt protocol port <code>7687</code> <code>neo4j_http_port</code> <code>integer</code> Neo4j HTTP port <code>7474</code> <p>Note: The <code>uri</code> property is dynamically constructed as <code>neo4j://{default_host}:{bolt_port}</code>. If <code>default_host</code> is not set, it defaults to <code>127.0.0.1</code>.</p> <p>Example:</p> <pre><code>[neo4j]\nuser = \"neo4j\"\npassword = \"callgraphn4j!\"\nbolt_port = 7687\nneo4j_http_port = 7474\n</code></pre>"},{"location":"Configuration/#sandbox-configuration","title":"Sandbox Configuration","text":"<p>Configures sandbox environments (Docker containers or Kubernetes pods).</p> <p>Section: <code>[sandbox]</code></p>"},{"location":"Configuration/#top-level-sandbox-settings","title":"Top-Level Sandbox Settings","text":"Field Type Description Default <code>default_image</code> <code>string</code> Default Docker image for sandboxes <code>None</code> <code>backend</code> <code>string</code> Sandbox backend type: <code>\"native\"</code> (Docker) or <code>\"k8s\"</code> (Kubernetes) <code>\"native\"</code> <code>project_relative_shared_data_path</code> <code>string</code> Path relative to project root for shared data (will be mounted as <code>/shared</code> in containers) <code>None</code> <code>absolute_shared_data_path</code> <code>string</code> Absolute path for shared data <code>None</code> <code>tolerations</code> <code>list[dict]</code> Kubernetes tolerations applied to all pods <code>None</code>"},{"location":"Configuration/#per-sandbox-configuration","title":"Per-Sandbox Configuration","text":"<p>Each sandbox type is configured under <code>[sandbox.sandboxes.&lt;sandbox_type&gt;]</code>:</p> <p>Common Sandbox Types: - <code>main</code>: Primary analysis sandbox - <code>joern</code>: Joern static analysis sandbox - <code>codeql</code>: CodeQL analysis sandbox - <code>neo4j</code>: Neo4j database container - <code>gdb_mcp</code>: GDB debugger MCP service - <code>pdb_mcp</code>: PDB debugger MCP service - <code>fuzz</code>: Fuzzing environment</p> <p>Container Configuration Fields:</p> Field Type Description Default <code>image</code> <code>string</code> Docker image name/tag <code>None</code> <code>container_id</code> <code>string</code> Connect to existing container (instead of creating new) <code>None</code> <code>timeout</code> <code>integer</code> Container operation timeout in seconds <code>300</code> <code>project_relative_dockerfile_path</code> <code>string</code> Path to Dockerfile relative to project root <code>None</code> <code>absolute_dockerfile_path</code> <code>string</code> Absolute path to Dockerfile <code>None</code> <code>command</code> <code>string</code> Override container command (empty string = use Dockerfile default, <code>None</code> = use <code>bash</code>) <code>None</code> <code>platform</code> <code>string</code> Platform architecture (e.g., <code>\"linux/amd64\"</code>) <code>None</code> <code>network</code> <code>string</code> Docker network name <code>None</code> <code>privileged</code> <code>boolean</code> Run container in privileged mode <code>false</code> <code>security_opt</code> <code>list[string]</code> Security options <code>[]</code> <code>cap_add</code> <code>list[string]</code> Additional capabilities <code>[]</code> <code>gpus</code> <code>string</code> GPU allocation (e.g., <code>\"all\"</code> or <code>\"device=GPU-UUID\"</code>) <code>None</code> <code>shm_size</code> <code>string</code> Shared memory size (e.g., <code>\"2g\"</code>) <code>None</code> <code>mem_limit</code> <code>string</code> Memory limit (e.g., <code>\"4g\"</code>) <code>None</code> <code>cpus</code> <code>string</code> CPU limit (e.g., <code>\"2\"</code>) <code>None</code> <code>user</code> <code>string</code> User to run as (e.g., <code>\"1000:1000\"</code>) <code>None</code> <code>working_dir</code> <code>string</code> Working directory in container <code>None</code> <p>Build Configuration:</p> Field Type Description <code>build_args</code> <code>dict[string, string]</code> Docker build arguments <code>using_cached</code> <code>boolean</code> Whether to use cached image (internal flag) <p>Environment, Volumes, and Ports:</p> Field Type Description <code>environment</code> <code>dict[string, any]</code> Environment variables <code>volumes</code> <code>list[string]</code> Volume mounts in format <code>\"/host:/container:ro\"</code> <code>mounts</code> <code>list[string]</code> Docker mount specifications <code>ports</code> <code>dict[string, int\\|string]</code> Port mappings in format <code>{\"port/tcp\" = host_port}</code> <code>docker_args</code> <code>list[string]</code> Raw arguments passed through to Docker CLI <p>Extra Configuration:</p> Field Type Description <code>extra</code> <code>dict[string, any]</code> Additional custom configuration (e.g., <code>initializer_timeout_sec</code>) <p>Kubernetes-Specific Fields:</p> Field Type Description <code>pod_name</code> <code>string</code> Connect to existing Pod instead of creating new <code>container_name</code> <code>string</code> Name of container within the Pod <p>Example:</p> <pre><code>[sandbox]\nbackend = \"native\"\nproject_relative_shared_data_path = \"data/my_project.tar.gz\"\n\n[sandbox.sandboxes.main]\nimage = \"ubuntu:20.04\"\nproject_relative_dockerfile_path = \"dockerfiles/main/Dockerfile\"\ntimeout = 300\n\n[sandbox.sandboxes.main.build_args]\nBASE_IMAGE = \"ubuntu:20.04\"\n\n[sandbox.sandboxes.main.environment]\nPYTHONPATH = \"/shared/code\"\n\n[sandbox.sandboxes.main.ports]\n\"8080/tcp\" = 8080\n\n[sandbox.sandboxes.main.extra]\ninitializer_timeout_sec = 1800\n\n[sandbox.sandboxes.joern]\nimage = \"aigise/joern\"\nproject_relative_dockerfile_path = \"dockerfiles/joern/Dockerfile\"\ncommand = \"\"\n\n[sandbox.sandboxes.joern.environment]\nJAVA_OPTS = \"-Xmx16G -Xms4G\"\n\n[sandbox.sandboxes.joern.ports]\n\"8081/tcp\" = 18087\n</code></pre>"},{"location":"Configuration/#llm-configuration","title":"LLM Configuration","text":"<p>Configures language models used by agents.</p> <p>Section: <code>[llm]</code></p> <p>Models are configured under <code>[llm.model_configs.&lt;model_name&gt;]</code>:</p> <p>Common Model Names: - <code>main</code>: Primary model for agent reasoning - <code>summarize</code>: Model for summarization and context compression - <code>flag_claims</code>: Model for flag claims processing</p> <p>Model Configuration Fields:</p> Field Type Description Default <code>model_name</code> <code>string</code> Model identifier (e.g., <code>\"openai/gpt-4\"</code>, <code>\"anthropic/claude-3\"</code>) Required <code>temperature</code> <code>float</code> Sampling temperature (0.0-2.0) <code>None</code> <code>max_tokens</code> <code>integer</code> Maximum tokens in response <code>None</code> <code>rpm</code> <code>integer</code> Rate limit: requests per minute <code>None</code> <code>tpm</code> <code>integer</code> Rate limit: tokens per minute <code>None</code> <p>Example:</p> <pre><code>[llm]\n\n[llm.model_configs.main]\nmodel_name = \"openai/gpt-4\"\ntemperature = 0.7\nmax_tokens = 4096\nrpm = 60\ntpm = 60000\n\n[llm.model_configs.summarize]\nmodel_name = \"openai/gpt-3.5-turbo\"\ntemperature = 0.3\nmax_tokens = 2048\nrpm = 30\ntpm = 30000\n</code></pre>"},{"location":"Configuration/#history-configuration","title":"History Configuration","text":"<p>Configures tool response handling and event history management.</p> <p>Section: <code>[history]</code></p> Field Type Description Default <code>max_tool_response_length</code> <code>integer</code> Maximum length of a single tool response before special handling <code>10000</code> <code>enable_quota_countdown</code> <code>boolean</code> Show remaining LLM call quota after each tool response <code>false</code> <p>Events Compaction Configuration:</p> <p>Section: <code>[history.events_compaction]</code></p> Field Type Description Default <code>max_history_summary_length</code> <code>integer</code> Character budget threshold for triggering compaction <code>100000</code> <code>compaction_percent</code> <code>integer</code> Percentage of history to compress (0-100) <code>50</code> <p>Example:</p> <pre><code>[history]\nmax_tool_response_length = 10000\nenable_quota_countdown = true\n\n[history.events_compaction]\nmax_history_summary_length = 100000\ncompaction_percent = 50\n</code></pre>"},{"location":"Configuration/#plugins-configuration","title":"Plugins Configuration","text":"<p>Configures which plugins are enabled.</p> <p>Section: <code>[plugins]</code></p> Field Type Description Default <code>enabled</code> <code>list[string]</code> List of enabled plugin names <code>[]</code> <p>Common Plugins: - <code>history_summarizer_plugin</code>: Summarizes long conversation history - <code>tool_response_summarizer_plugin</code>: Summarizes long tool responses - <code>quota_after_tool_plugin</code>: Shows quota countdown after tools</p> <p>Example:</p> <pre><code>[plugins]\nenabled = [\n    \"history_summarizer_plugin\",\n    \"tool_response_summarizer_plugin\",\n    \"quota_after_tool_plugin\",\n]\n</code></pre>"},{"location":"Configuration/#agent-ensemble-configuration","title":"Agent Ensemble Configuration","text":"<p>Configures multi-agent ensemble execution.</p> <p>Section: <code>[agent_ensemble]</code></p> Field Type Description Default <code>thread_safe_tools</code> <code>list[string]</code> List of tool names that are thread-safe (can be called in parallel) <code>[]</code> <code>available_models_for_ensemble</code> <code>list[string]</code> or <code>string</code> List of model names available for ensemble (can be comma-separated string) <code>[]</code> <p>Example:</p> <pre><code>[agent_ensemble]\nthread_safe_tools = [\"google_search\", \"read_file\"]\navailable_models_for_ensemble = [\"openai/gpt-4\", \"anthropic/claude-3\"]\n</code></pre> <p>Or as comma-separated string:</p> <pre><code>[agent_ensemble]\nthread_safe_tools = [\"google_search\", \"read_file\"]\navailable_models_for_ensemble = \"openai/gpt-4,anthropic/claude-3\"\n</code></pre>"},{"location":"Configuration/#build-configuration","title":"Build Configuration","text":"<p>Configures build and execution commands for target programs.</p> <p>Section: <code>[build]</code></p> Field Type Description Default <code>poc_dir</code> <code>string</code> Directory path for proof-of-concept code <code>None</code> <code>compile_command</code> <code>string</code> Command to compile the target program <code>None</code> <code>run_command</code> <code>string</code> Command to run the target program <code>None</code> <code>target_type</code> <code>string</code> Type of target (e.g., <code>\"default\"</code>, <code>\"binary\"</code>) <code>None</code> <code>target_binary</code> <code>string</code> Path to target binary <code>None</code> <p>Example:</p> <pre><code>[build]\npoc_dir = \"/tmp/poc\"\ncompile_command = \"gcc -o target target.c\"\nrun_command = \"./target\"\ntarget_type = \"binary\"\ntarget_binary = \"/tmp/poc/target\"\n</code></pre>"},{"location":"Configuration/#mcp-configuration","title":"MCP Configuration","text":"<p>Configures Model Context Protocol (MCP) services.</p> <p>Section: <code>[mcp]</code></p> <p>MCP services are configured under <code>[mcp.services.&lt;service_name&gt;]</code>:</p> <p>Common Service Names: - <code>gdb_mcp</code>: GDB debugger MCP service - <code>pdb_mcp</code>: PDB debugger MCP service</p> <p>MCP Service Configuration Fields:</p> Field Type Description <code>sse_port</code> <code>integer</code> Server-Sent Events (SSE) server port <code>sse_host</code> <code>string</code> SSE server host (if <code>None</code>, uses <code>default_host</code> from root config) <p>Note: The <code>sse_host</code> property dynamically uses <code>default_host</code> from the root configuration if not explicitly set.</p> <p>Example:</p> <pre><code>[mcp]\n\n[mcp.services.gdb_mcp]\nsse_port = 1111\n\n[mcp.services.pdb_mcp]\nsse_port = 1112\nsse_host = \"localhost\"  # Optional, defaults to root config's default_host\n</code></pre>"},{"location":"Configuration/#complete-example","title":"Complete Example","text":"<p>Here's a complete configuration file example:</p> <pre><code># Template Variables\nDEFAULT_IMAGE = \"ubuntu:20.04\"\nMAIN_MODEL = \"openai/gpt-4\"\nNEO4J_PASSWORD = \"secure_password\"\nTASK_NAME = \"security_analysis\"\n\n# Root Configuration\ntask_name = \"${TASK_NAME}\"\nsrc_dir_in_sandbox = \"/shared/code\"\ndefault_host = \"localhost\"\nauto_cleanup = true\n\n# Neo4j Configuration\n[neo4j]\nuser = \"neo4j\"\npassword = \"${NEO4J_PASSWORD}\"\nbolt_port = 7687\nneo4j_http_port = 7474\n\n# Sandbox Configuration\n[sandbox]\nbackend = \"native\"\nproject_relative_shared_data_path = \"data/project.tar.gz\"\n\n[sandbox.sandboxes.main]\nimage = \"${DEFAULT_IMAGE}\"\nproject_relative_dockerfile_path = \"dockerfiles/main/Dockerfile\"\ntimeout = 300\n\n[sandbox.sandboxes.main.environment]\nPYTHONPATH = \"/shared/code\"\n\n[sandbox.sandboxes.joern]\nimage = \"aigise/joern\"\nproject_relative_dockerfile_path = \"dockerfiles/joern/Dockerfile\"\ncommand = \"\"\n\n[sandbox.sandboxes.joern.ports]\n\"8081/tcp\" = 18087\n\n# LLM Configuration\n[llm]\n\n[llm.model_configs.main]\nmodel_name = \"${MAIN_MODEL}\"\ntemperature = 0.7\nmax_tokens = 4096\n\n[llm.model_configs.summarize]\nmodel_name = \"${MAIN_MODEL}\"\ntemperature = 0.3\nmax_tokens = 2048\n\n# History Configuration\n[history]\nmax_tool_response_length = 10000\nenable_quota_countdown = true\n\n[history.events_compaction]\nmax_history_summary_length = 100000\ncompaction_percent = 50\n\n# Plugins Configuration\n[plugins]\nenabled = [\n    \"history_summarizer_plugin\",\n    \"tool_response_summarizer_plugin\",\n]\n\n# Agent Ensemble Configuration\n[agent_ensemble]\nthread_safe_tools = [\"google_search\"]\navailable_models_for_ensemble = \"${MAIN_MODEL}\"\n\n# Build Configuration\n[build]\ncompile_command = \"make\"\nrun_command = \"./target\"\n\n# MCP Configuration\n[mcp]\n\n[mcp.services.gdb_mcp]\nsse_port = 1111\n</code></pre>"},{"location":"Configuration/#loading-configuration-in-code","title":"Loading Configuration in Code","text":""},{"location":"Configuration/#using-default-configuration","title":"Using Default Configuration","text":"<pre><code>from aigise.session import AigiseSession\n\n# Uses default config from src/&lt;package&gt;/templates/configs/default_config.toml\nsession = AigiseSession(aigise_session_id=\"my_session\")\n</code></pre>"},{"location":"Configuration/#using-custom-configuration","title":"Using Custom Configuration","text":"<pre><code>from aigise.session import AigiseSession\n\n# Load custom configuration file\nsession = AigiseSession(\n    aigise_session_id=\"my_session\",\n    config_path=\"/path/to/my_config.toml\"\n)\n</code></pre>"},{"location":"Configuration/#accessing-configuration","title":"Accessing Configuration","text":"<pre><code># Access configuration through session\nconfig = session.config\n\n# Access specific sections\nneo4j_config = config.neo4j\nsandbox_config = config.sandbox\nllm_config = config.llm\n\n# Access nested configurations\nmain_sandbox = config.get_sandbox_config(\"main\")\nmain_model = config.get_llm_config(\"main\")\n</code></pre>"},{"location":"Configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Use Template Variables: Define reusable values as UPPERCASE template variables at the top</li> <li>Organize by Section: Group related settings into logical sections</li> <li>Document Custom Fields: Add comments for non-standard or custom configuration</li> <li>Version Control: Keep configuration files in version control, but exclude sensitive values (passwords, API keys)</li> <li>Environment-Specific Configs: Create separate config files for development, testing, and production</li> <li>Validate Early: Test configuration files before deploying to catch errors early</li> </ol>"},{"location":"Configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"Configuration/#template-variable-not-found","title":"Template Variable Not Found","text":"<p>If you see <code>KeyError: Template variable 'VAR_NAME' not found</code>, ensure: - The variable is defined as an UPPERCASE top-level variable - The variable name matches exactly (case-sensitive) - There are no typos in <code>${VAR_NAME}</code> references</p>"},{"location":"Configuration/#configuration-not-loading","title":"Configuration Not Loading","text":"<ul> <li>Verify the TOML file syntax is correct</li> <li>Check file path is correct (use absolute paths if relative paths don't work)</li> <li>Ensure all required fields are present (check error messages)</li> </ul>"},{"location":"Configuration/#dynamic-host-resolution","title":"Dynamic Host Resolution","text":"<p>If <code>default_host</code> is not set, services like Neo4j and MCP will default to <code>127.0.0.1</code>. Set <code>default_host</code> at the root level for Kubernetes deployments or remote services.</p>"},{"location":"Configuration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Getting Started - Initial setup guide</li> <li>Architecture - System architecture overview</li> <li>Core Concepts - Core concepts including sessions</li> <li>Sandboxes - Sandbox backends and configuration guide</li> </ul>"},{"location":"Contributing/","title":"Contributing Guidelines","text":""},{"location":"Contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow Google Python Style Guide</li> <li>Use <code>pyink</code> for formatting</li> <li>Use <code>isort</code> for import sorting</li> <li>Run <code>autoformat.sh</code> before committing</li> </ul>"},{"location":"Contributing/#commit-messages","title":"Commit Messages","text":"<p>Follow Conventional Commits format:</p> <pre><code>feat(component): Description\nfix(component): Description\nrefactor(component): Description\n</code></pre>"},{"location":"Contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create feature branch</li> <li>Make changes with tests</li> <li>Run tests and linting</li> <li>Update documentation</li> <li>Submit PR with description</li> </ol>"},{"location":"Contributing/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>Add tests for new features</li> <li>Maintain or improve coverage</li> <li>Test with multiple sandbox types</li> <li>Test error cases</li> </ul>"},{"location":"Contributing/#documentation","title":"Documentation","text":"<ul> <li>Update relevant documentation</li> <li>Add code examples where helpful</li> <li>Keep wiki pages updated</li> </ul>"},{"location":"Contributing/#see-also","title":"See Also","text":"<ul> <li>Best Practices - Development best practices</li> <li>Development Guides - How to extend the framework</li> </ul>"},{"location":"Core-Components/","title":"Core Components","text":"<p>OpenSage core components (Note: code uses <code>aigise</code> package name for compatibility).</p>"},{"location":"Core-Components/#1-aigisesession","title":"1. AigiseSession","text":"<p>The central manager for all session-specific resources.</p> <p>Key Responsibilities: - Configuration management (TOML loading, env overrides) - Agent lifecycle (creation, persistence, cleanup) - Sandbox management (Docker containers, resource isolation) - Neo4j client management - Agent ensemble coordination</p> <p>Key Files: - <code>src/aigise/session/aigise_session.py</code> - <code>src/aigise/session/aigise_dynamic_agent_manager.py</code> - <code>src/aigise/session/aigise_sandbox_manager.py</code></p>"},{"location":"Core-Components/#2-aigiseagent","title":"2. AigiseAgent","text":"<p>Extended ADK agent with security-focused features.</p> <p>Key Features: - Dynamic tool loading from filesystem - Integration with sandbox environments - Tool combo support - Session-aware tool execution</p> <p>Key Files: - <code>src/aigise/agents/aigise_agent.py</code></p>"},{"location":"Core-Components/#3-sandbox-system","title":"3. Sandbox System","text":"<p>Isolated execution environments for security analysis.</p> <p>Sandbox Types: - <code>main</code>: Primary analysis sandbox - <code>joern</code>: Static analysis (CPG generation) - <code>codeql</code>: CodeQL analysis - <code>neo4j</code>: Graph database for CPG storage - <code>gdb_mcp</code>: Debugger integration - <code>fuzz</code>: Fuzzing environment</p> <p>Key Files: - <code>src/aigise/sandbox/base_sandbox.py</code> - <code>src/aigise/sandbox/native_docker_sandbox.py</code> - <code>src/aigise/sandbox/k8s_sandbox.py</code> - <code>src/aigise/sandbox/initializers/</code></p>"},{"location":"Core-Components/#4-configuration-system","title":"4. Configuration System","text":"<p>TOML-based configuration with template variable expansion.</p> <p>Key Files: - <code>src/aigise/config/config_dataclass.py</code> - <code>src/aigise/templates/configs/default_config.toml</code></p>"},{"location":"Core-Components/#5-toolbox","title":"5. Toolbox","text":"<p>Collection of security analysis tools.</p> <p>Tool Categories: - Static Analysis: Joern, CodeQL queries - Dynamic Analysis: Fuzzing, debugging - Coverage: LLVM coverage tools - Retrieval: Code search and symbol lookup - Evaluation: PoC submission and validation</p> <p>Key Files: - <code>src/aigise/toolbox/</code></p>"},{"location":"Core-Components/#related-topics","title":"Related Topics","text":"<ul> <li>Core Concepts - Understanding how components work together</li> <li>Architecture - System architecture overview</li> <li>Development Guides - How to extend components</li> </ul>"},{"location":"Core-Concepts/","title":"Core Concepts","text":""},{"location":"Core-Concepts/#session-management","title":"Session Management","text":"<p>Every operation in OpenSage is scoped to a session. Sessions provide: - Resource isolation - Configuration management - Lifecycle management</p> <pre><code>from &lt;package&gt; import get_session\n\nsession = get_aigise_session(\"my_session_id\", config_path=\"config.toml\")\n</code></pre>"},{"location":"Core-Concepts/#agent-creation","title":"Agent Creation","text":"<p>Agents are created through <code>mk_agent</code> functions:</p> <pre><code>def mk_agent(aigise_session_id: str) -&gt; AigiseAgent:\n    session = get_aigise_session(aigise_session_id)\n    # ... configure agent ...\n    return AigiseAgent(...)\n</code></pre>"},{"location":"Core-Concepts/#sandbox-lifecycle","title":"Sandbox Lifecycle","text":"<p>Sandboxes are managed through the session:</p> <pre><code>session = get_aigise_session(\"my_session_id\")\nsandbox = session.sandboxes.get_sandbox(\"main\")\nresult = sandbox.run_command_in_container(\"ls /shared\")\n</code></pre>"},{"location":"Core-Concepts/#tool-development","title":"Tool Development","text":"<p>In OpenSage, tools are implemented as Agent Skills (bash scripts) or MCP toolsets, rather than Python functions. This design provides better isolation and allows tools to run directly in sandbox containers.</p>"},{"location":"Core-Concepts/#agent-skills-bash-scripts","title":"Agent Skills (Bash Scripts)","text":"<p>Agent Skills are bash scripts organized in a structured directory format:</p> <pre><code>src/&lt;package&gt;/bash_tools/\n\u2514\u2500\u2500 category/\n    \u2514\u2500\u2500 tool-name/\n        \u251c\u2500\u2500 SKILL.md          # Metadata and documentation\n        \u2514\u2500\u2500 scripts/\n            \u2514\u2500\u2500 tool_script.sh # Bash implementation\n</code></pre> <p>The <code>SKILL.md</code> file contains: - YAML frontmatter with <code>name</code> and <code>description</code> - Parameter definitions - Sandbox requirements - Usage examples - Return value format</p>"},{"location":"Core-Concepts/#mcp-toolsets","title":"MCP Toolsets","text":"<p>MCP (Model Context Protocol) toolsets provide integration with external services:</p> <pre><code>@safe_tool_execution\n@requires_sandbox(\"gdb_mcp\")\ndef get_toolset(aigise_session_id: str) -&gt; MCPToolset:\n    url = get_mcp_url_from_session_id(\"gdb_mcp\", aigise_session_id)\n    return MCPToolset(connection_params=SseConnectionParams(url=url))\n</code></pre>"},{"location":"Core-Concepts/#automatic-discovery","title":"Automatic Discovery","text":"<p>Tools are automatically discovered from: - <code>src/&lt;package&gt;/bash_tools/</code> (built-in tools) - <code>~/.local/plugins/&lt;product&gt;/tools/</code> (user plugins)</p> <p>No manual registration is required.</p>"},{"location":"Core-Concepts/#configuration","title":"Configuration","text":"<p>Configuration is TOML-based with template variables:</p> <pre><code>src_dir_in_sandbox = \"/shared/code\"\n[sandbox.sandboxes.main]\nimage = \"ubuntu:20.04\"\n</code></pre>"},{"location":"Core-Concepts/#see-also","title":"See Also","text":"<ul> <li>Development Guides - Practical development examples</li> <li>Common Patterns - Common code patterns</li> <li>Best Practices - Best practices</li> </ul>"},{"location":"Development-Guides/","title":"Development Guides","text":"<p>This section covers how to extend OpenSage with new functionality.</p>"},{"location":"Development-Guides/#guides","title":"Guides","text":"<ul> <li>Adding Tools - How to add new tools</li> <li>Sandboxes - Sandbox backends and how to add new sandbox types</li> <li>Adding Evaluations - How to add evaluation benchmarks</li> </ul>"},{"location":"Development-Guides/#extending-aigiseagent","title":"Extending AigiseAgent","text":"<p>To add features to AigiseAgent:</p> <ol> <li>Modify <code>src/aigise/agents/aigise_agent.py</code></li> <li>Ensure backward compatibility</li> <li>Add configuration options if needed</li> <li>Update documentation</li> </ol>"},{"location":"Development-Guides/#general-development-workflow","title":"General Development Workflow","text":"<ol> <li>Create feature branch</li> <li>Make changes with tests</li> <li>Run tests and linting</li> <li>Update documentation</li> <li>Submit PR</li> </ol>"},{"location":"Development-Guides/#see-also","title":"See Also","text":"<ul> <li>Best Practices - Best practices for development</li> <li>Common Patterns - Common code patterns</li> <li>Testing Debugging - Testing and debugging guide</li> </ul>"},{"location":"Entry-Points/","title":"Entry Points","text":"<p>OpenSage has three main entry points for different use cases:</p> <ol> <li>OpenSage Web Entry - Interactive web UI for development and debugging</li> <li>Evaluation Entry - Batch evaluation on benchmarks</li> <li>RL Framework Integration - Integration with RL frameworks (slime, verl, areal) for agent training</li> </ol> <p>Each entry point has a different workflow and use case. Click on the links above to see detailed step-by-step workflows.</p>"},{"location":"Entry-Points/#quick-comparison","title":"Quick Comparison","text":"Aspect opensage web Evaluations RL Integration Use Case Development, debugging Performance measurement Agent training Interaction Interactive chat Batch processing Framework API Sessions Single long-lived Multiple short-lived Per-sample sessions Parallelism Single user Multiple tasks Framework-managed Output Real-time events Saved results files Framework samples"},{"location":"Evaluation-Entry/","title":"Evaluations - Batch Processing Entry Point","text":"<p>Evaluation scripts run agents on benchmark datasets for performance measurement and testing.</p>"},{"location":"Evaluation-Entry/#command","title":"Command","text":"<pre><code>cd src/aigise/evaluations\npython cybergym/cybergym_vul_detection.py run \\\n  --agent-id my_agent \\\n  --config-path /path/to/config.toml \\\n  --max_llm_calls 75 \\\n  --use_multiprocessing \\\n  --max_workers 3\n</code></pre>"},{"location":"Evaluation-Entry/#step-by-step-workflow","title":"Step-by-Step Workflow","text":""},{"location":"Evaluation-Entry/#step-1-script-initialization","title":"Step 1: Script Initialization","text":"<ol> <li>Fire library parses command-line arguments</li> <li>Creates <code>Evaluation</code> class instance with parameters:</li> <li><code>agent_id</code>: Identifier for the agent</li> <li><code>config_path</code>: Path to TOML configuration</li> <li><code>max_llm_calls</code>: Maximum LLM calls per task</li> <li><code>use_multiprocessing</code>: Use processes vs threads</li> <li><code>max_workers</code>: Number of parallel workers</li> <li>Sets up logging and instrumentation (Langfuse, OpenTelemetry)</li> </ol>"},{"location":"Evaluation-Entry/#step-2-load-dataset","title":"Step 2: Load Dataset","text":"<pre><code>self.dataset = self._get_dataset()\n</code></pre> <ol> <li>Loads benchmark dataset (e.g., HuggingFace datasets, JSON files)</li> <li>Dataset contains multiple samples/tasks to evaluate</li> <li>Example: CyberGym dataset has vulnerability detection tasks</li> <li>Each sample contains:</li> <li>Task description</li> <li>Expected outputs (ground truth)</li> <li>Metadata (file paths, vulnerability info, etc.)</li> </ol>"},{"location":"Evaluation-Entry/#step-3-prepare-general-environment-_prepare_general_env","title":"Step 3: Prepare General Environment (<code>_prepare_general_env</code>)","text":"<p>This sets up shared resources used across all evaluation tasks.</p>"},{"location":"Evaluation-Entry/#31-create-base-configuration","title":"3.1 Create Base Configuration","text":"<ol> <li>Loads base configuration from TOML file</li> <li>Expands template variables</li> <li>Stores in class for later use</li> </ol>"},{"location":"Evaluation-Entry/#32-setup-evaluation-directories","title":"3.2 Setup Evaluation Directories","text":"<pre><code>self.eval_output_dir = Path(f\"evals/{self.agent_id}/...\")\nself.eval_output_dir.mkdir(parents=True, exist_ok=True)\n</code></pre> <ul> <li>Creates output directories for results</li> <li>Structure: <code>evals/{agent_id}/{benchmark_name}/{timestamp}/</code></li> <li>Stores agent outputs, logs, artifacts</li> </ul>"},{"location":"Evaluation-Entry/#step-4-generate-samples-parallel-execution","title":"Step 4: Generate Samples (Parallel Execution)","text":"<p>The evaluation runs tasks in parallel. Choose one mode:</p>"},{"location":"Evaluation-Entry/#mode-a-multiprocessing-generate","title":"Mode A: Multiprocessing (<code>generate()</code>)","text":"<pre><code>with ProcessPoolExecutor(max_workers=self.max_workers) as executor:\n    futures = {\n        executor.submit(_run_sample_in_process, self, sample): sample\n        for sample in self.dataset\n    }\n</code></pre> <ul> <li>Each sample runs in separate process</li> <li>True parallelism (bypasses Python GIL)</li> <li>Processes are isolated (no shared memory)</li> <li>Requires serializable data</li> </ul>"},{"location":"Evaluation-Entry/#mode-b-multithreading-generate_threaded","title":"Mode B: Multithreading (<code>generate_threaded()</code>)","text":"<pre><code>with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n    futures = {\n        executor.submit(run_sample_in_thread, sample): sample\n        for sample in self.dataset\n    }\n</code></pre> <ul> <li>Each sample runs in separate thread</li> <li>Shared memory (can share resources)</li> <li>Limited by GIL for CPU-bound tasks</li> <li>Better for I/O-bound operations</li> </ul>"},{"location":"Evaluation-Entry/#mode-c-single-thread-generate_single_thread","title":"Mode C: Single Thread (<code>generate_single_thread()</code>)","text":"<ul> <li>Sequential execution, one sample at a time</li> <li>Used for debugging</li> <li>Easier to debug issues</li> <li>Much slower</li> </ul>"},{"location":"Evaluation-Entry/#step-5-process-each-sample-_generate_sample-or-_run_sample_in_process","title":"Step 5: Process Each Sample (<code>_generate_sample</code> or <code>_run_sample_in_process</code>)","text":"<p>For each sample in the dataset:</p>"},{"location":"Evaluation-Entry/#51-create-evaluation-task","title":"5.1 Create Evaluation Task","text":"<pre><code>task = self._create_task(sample)\n</code></pre> <ol> <li>Extracts sample data</li> <li>Creates <code>EvaluationTask</code> object with:</li> <li><code>session_id</code>: Unique ID for this task</li> <li><code>sample</code>: Original sample data</li> <li><code>aigise_session</code>: Will be created next</li> <li>Metadata (task name, description, etc.)</li> </ol>"},{"location":"Evaluation-Entry/#52-create-opensage-session","title":"5.2 Create OpenSage Session","text":"<pre><code>aigise_session = get_aigise_session(\n    aigise_session_id=task.session_id,\n    config_path=self.config_path\n)\n</code></pre> <ul> <li>Creates isolated OpenSage session for this task</li> <li>Loads configuration</li> <li>Each task gets its own session (isolation)</li> </ul>"},{"location":"Evaluation-Entry/#53-prepare-task-specific-environment-_prepare_environment","title":"5.3 Prepare Task-Specific Environment (<code>_prepare_environment</code>)","text":"<p>This is benchmark-specific. Example for CyberGym:</p> <ol> <li>Extract code/data:</li> <li>Extracts source code to sandbox</li> <li>Copies test files, build scripts</li> <li> <p>Sets up project structure</p> </li> <li> <p>Initialize sandboxes:    <pre><code>aigise_session.sandboxes.initialize_shared_volumes()\nawait aigise_session.sandboxes.launch_all_sandboxes()\nawait aigise_session.sandboxes.initialize_all_sandboxes()\n</code></pre></p> </li> <li>Creates shared volumes</li> <li>Launches required sandbox containers</li> <li> <p>Initializes sandboxes (tools, dependencies)</p> </li> <li> <p>Set source directory:    <pre><code>aigise_session.config.src_dir_in_sandbox = \"/shared/code\"\n</code></pre></p> </li> <li> <p>Tells tools where to find source code</p> </li> <li> <p>Git repository setup (if applicable):</p> </li> <li>Finds git repository in sandbox</li> <li>Checks out main/master branch</li> <li>Updates <code>src_dir_in_sandbox</code> to repo path</li> </ol>"},{"location":"Evaluation-Entry/#54-load-agent","title":"5.4 Load Agent","text":"<pre><code>mk_agent = self._load_mk_agent()\nagent = mk_agent(aigise_session_id=task.session_id)\n</code></pre> <ol> <li>Imports agent module</li> <li>Calls <code>mk_agent()</code> function with session ID</li> <li>Agent is configured for this specific session</li> <li>Agent has access to task-specific sandboxes and resources</li> </ol>"},{"location":"Evaluation-Entry/#55-create-adk-session-and-runner","title":"5.5 Create ADK Session and Runner","text":"<pre><code>inner_session_service = InMemorySessionService()\nawait inner_session_service.create_session(\n    app_name=app_name,\n    user_id=self.user_id + \"_\" + meta_data,\n    session_id=task.session_id,\n    state={\"aigise_session_id\": task.session_id},\n)\n\nrunner = Runner(\n    agent=agent,\n    app_name=app_name,\n    session_service=inner_session_service,\n)\n</code></pre> <ul> <li>Creates ADK session that maps to OpenSage session</li> <li>Stores <code>aigise_session_id</code> in session state</li> <li>Creates ADK Runner for agent execution</li> </ul>"},{"location":"Evaluation-Entry/#56-run-agent","title":"5.6 Run Agent","text":"<pre><code>run_config = RunConfig(max_llm_calls=self.max_llm_calls)\n\nasync for event in runner.run_async(\n    user_id=user_id,\n    session_id=task.session_id,\n    run_config=run_config,\n    new_message=types.Content(parts=[types.Part(text=task.prompt)]),\n):\n    # Process events\n    if isinstance(event, types.FunctionResponse):\n        # Tool execution results\n    elif isinstance(event, types.Candidate):\n        # Agent responses\n</code></pre> <ol> <li>Runner starts agent execution:</li> <li>Sends prompt to agent</li> <li> <p>Agent enters reason-act loop</p> </li> <li> <p>Agent reasoning:</p> </li> <li>Calls LLM for reasoning</li> <li>Decides which tools to use</li> <li> <p>Generates function calls</p> </li> <li> <p>Tool execution:</p> </li> <li>Runner executes tools in sandbox</li> <li>Tools access session resources</li> <li> <p>Results returned to agent</p> </li> <li> <p>Iteration:</p> </li> <li>Agent processes tool results</li> <li>Decides next action</li> <li> <p>Continues until completion or max calls</p> </li> <li> <p>Completion:</p> </li> <li>Agent generates final response</li> <li>Runner finishes execution</li> <li>Events collected</li> </ol>"},{"location":"Evaluation-Entry/#57-collect-results","title":"5.7 Collect Results","text":"<pre><code>result = {\n    \"session_id\": task.session_id,\n    \"prompt\": task.prompt,\n    \"response\": agent_response,\n    \"events\": events,\n    \"metadata\": {...},\n}\n</code></pre> <ul> <li>Extracts agent response</li> <li>Collects execution metadata:</li> <li>Number of LLM calls</li> <li>Tools used</li> <li>Execution time</li> <li>Errors (if any)</li> </ul>"},{"location":"Evaluation-Entry/#58-save-results","title":"5.8 Save Results","text":"<pre><code>self._save_result(task, result)\n</code></pre> <ul> <li>Saves result to file (JSON)</li> <li>Location: <code>evals/{agent_id}/{benchmark}/results/{task_id}.json</code></li> <li>Includes full event history for analysis</li> </ul>"},{"location":"Evaluation-Entry/#59-cleanup-task-session","title":"5.9 Cleanup Task Session","text":"<pre><code>cleanup_aigise_session(task.session_id)\n</code></pre> <ul> <li>Stops sandbox containers</li> <li>Removes shared volumes</li> <li>Cleans up session resources</li> <li>Frees Docker resources</li> </ul>"},{"location":"Evaluation-Entry/#step-6-collect-all-results","title":"Step 6: Collect All Results","text":"<p>After all samples complete:</p> <ol> <li>Aggregates results from all tasks</li> <li>Collects statistics:</li> <li>Success rate</li> <li>Average execution time</li> <li>Tool usage patterns</li> <li>Error rates</li> </ol>"},{"location":"Evaluation-Entry/#step-7-evaluate-results-evaluate","title":"Step 7: Evaluate Results (<code>evaluate()</code>)","text":"<pre><code>self.evaluate()\n</code></pre> <ol> <li>Load ground truth:</li> <li>Loads expected outputs from dataset</li> <li> <p>Loads agent results from files</p> </li> <li> <p>Compare outputs:</p> </li> <li>Compares agent output vs ground truth</li> <li> <p>Calculates metrics:</p> <ul> <li>Accuracy</li> <li>Precision/Recall (if applicable)</li> <li>Custom benchmark metrics</li> </ul> </li> <li> <p>Generate report:</p> </li> <li>Creates evaluation report</li> <li>Includes metrics, statistics, examples</li> <li> <p>Saves to <code>evals/{agent_id}/{benchmark}/evaluation_report.json</code></p> </li> <li> <p>Display summary:</p> </li> <li>Prints metrics to console</li> <li>Shows top failures/successes</li> <li>Provides analysis</li> </ol>"},{"location":"Evaluation-Entry/#key-characteristics","title":"Key Characteristics","text":""},{"location":"Evaluation-Entry/#isolation","title":"Isolation","text":"<ul> <li>Each task gets its own OpenSage session</li> <li>Separate sandbox containers</li> <li>No interference between tasks</li> </ul>"},{"location":"Evaluation-Entry/#parallelism","title":"Parallelism","text":"<ul> <li>Multiple tasks run simultaneously</li> <li>Configurable worker count</li> <li>Process or thread-based execution</li> </ul>"},{"location":"Evaluation-Entry/#reproducibility","title":"Reproducibility","text":"<ul> <li>Deterministic task execution</li> <li>Results saved with full event history</li> <li>Can replay specific tasks</li> </ul>"},{"location":"Evaluation-Entry/#resource-management","title":"Resource Management","text":"<ul> <li>Sessions cleaned up after each task</li> <li>Containers stopped and removed</li> <li>Prevents resource leaks</li> </ul>"},{"location":"Evaluation-Entry/#comparison-with-opensage-web","title":"Comparison with opensage web","text":"Aspect opensage web Evaluations Purpose Development, debugging Performance measurement Sessions Single long-lived session Multiple short-lived sessions Interaction Interactive chat Batch processing Parallelism Single user Multiple tasks in parallel Cleanup Manual (on exit) Automatic (per task) Output Real-time events Saved results files"},{"location":"Evaluation-Entry/#example-evaluation-flow","title":"Example Evaluation Flow","text":"<pre><code>Dataset (100 tasks)\n  \u2193\nProcess Pool (3 workers)\n  \u251c\u2500 Worker 1: Task 1 \u2192 Session 1 \u2192 Agent \u2192 Result 1\n  \u251c\u2500 Worker 2: Task 2 \u2192 Session 2 \u2192 Agent \u2192 Result 2\n  \u2514\u2500 Worker 3: Task 3 \u2192 Session 3 \u2192 Agent \u2192 Result 3\n  \u251c\u2500 Worker 1: Task 4 \u2192 Session 4 \u2192 Agent \u2192 Result 4\n  ...\n  \u2193\nAll Results Collected\n  \u2193\nEvaluation (compare vs ground truth)\n  \u2193\nReport Generated\n</code></pre>"},{"location":"Evaluation-Entry/#related-topics","title":"Related Topics","text":"<ul> <li>Entry Points - Overview of entry points</li> <li>Core Concepts - Understanding sessions</li> <li>Testing Debugging - Debugging evaluations</li> </ul>"},{"location":"Getting-Started/","title":"Getting Started","text":""},{"location":"Getting-Started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+ (recommended)</li> <li><code>uv</code> package manager (required)</li> <li>Docker (for sandbox execution)</li> <li>CodeQL (optional, for CodeQL analysis)</li> </ul>"},{"location":"Getting-Started/#installation","title":"Installation","text":""},{"location":"Getting-Started/#step-1-install-uv","title":"Step 1: Install uv","text":"<pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre>"},{"location":"Getting-Started/#step-2-clone-and-setup","title":"Step 2: Clone and Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/OpenSage-ADK/OpenSage.git\ncd OpenSage\n\n# Create virtual environment\nuv venv --python \"python3.11\" \".venv\"\nsource .venv/bin/activate\n\n# Install dependencies\nuv sync\n\n# Install pre-commit hooks\nuv run pre-commit install\n</code></pre>"},{"location":"Getting-Started/#step-3-additional-setup","title":"Step 3: Additional Setup","text":"<p>CodeQL Setup (Optional): <pre><code># Download CodeQL bundle\n# Extract to: PROJECT_PATH/src/&lt;package&gt;/sandbox_scripts/codeql\n</code></pre></p>"},{"location":"Getting-Started/#verify-installation","title":"Verify Installation","text":"<pre><code># Check OpenSage CLI is available\nuv run opensage --help\n</code></pre>"},{"location":"Getting-Started/#next-steps","title":"Next Steps","text":"<ul> <li>Project Structure - Understand the codebase structure</li> <li>Core Concepts - Learn the core concepts</li> <li>Development Guides - Start developing</li> </ul>"},{"location":"Getting-Started/#sandbox-images-docker","title":"Sandbox Images (Docker)","text":"<p>OpenSage uses Docker-based sandboxes. Some sandboxes require Python tooling inside their images (for initializers and Python-based helper scripts).</p>"},{"location":"Getting-Started/#uv-inside-sandbox-images","title":"uv inside sandbox images","text":"<p>Sandbox Dockerfiles install <code>uv</code> using:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre>"},{"location":"Getting-Started/#python-in-sandbox-images","title":"Python in sandbox images","text":"<p>For sandboxes that need Python, the Dockerfile creates a venv at <code>/app/.venv</code>:</p> <pre><code>uv venv --python 3.12\n</code></pre> <p>and installs Python dependencies into that venv:</p> <pre><code>uv pip install &lt;package...&gt;\n</code></pre> <p>Because sandbox command execution is non-persistent (each command is a fresh process), prefer calling the venv Python explicitly:</p> <ul> <li><code>/app/.venv/bin/python ...</code></li> <li><code>/app/.venv/bin/pip ...</code></li> </ul>"},{"location":"Getting-Started/#per-sandbox-requirements-defaults","title":"Per-sandbox requirements (defaults)","text":"<ul> <li>main sandbox</li> <li>Requires <code>python3</code> and the Python package <code>neo4j</code></li> <li> <p>Image built from <code>src/&lt;package&gt;/templates/dockerfiles/main/Dockerfile</code></p> </li> <li> <p>joern sandbox</p> </li> <li>Requires <code>python3</code> and Python packages <code>httpx</code> + <code>websockets</code></li> <li>Image built from <code>src/&lt;package&gt;/templates/dockerfiles/joern/Dockerfile</code></li> </ul>"},{"location":"Getting-Started/#see-also","title":"See Also","text":"<ul> <li>Introduction - Project overview</li> <li>Configuration - Configuration guide</li> </ul>"},{"location":"Introduction/","title":"Introduction","text":""},{"location":"Introduction/#what-is-opensage","title":"What is OpenSage?","text":"<p>OpenSage (Open Self-programming Agent Generation Engine) is an AI agent framework built on top of Google ADK (Agent Development Kit). It represents a paradigm shift from \"Agent Development 1.0\" to \"Agent Development 2.0\" \u2014 transitioning from agents that execute predefined structures to agents that can dynamically build and manage their own systems at runtime.</p>"},{"location":"Introduction/#core-value-proposition","title":"Core Value Proposition","text":""},{"location":"Introduction/#from-agent-using-system-to-agent-building-system","title":"From \"Agent Using System\" to \"Agent Building System\"","text":"<p>Agent Development 1.0 (Traditional Frameworks): - System structure pre-defined by humans (agent topology, workflows, tool sets) - Agents can only choose actions within given structures - Extending to new tasks requires significant manual refactoring - Essentially human-centered agent building</p> <p>Agent Development 2.0 (OpenSage): - Agents upgrade from \"executing predefined structures\" to \"autonomously building and managing structures\" - Humans provide minimal, stable system-level scaffolding - Everything else is generated, composed, and scheduled by AI at runtime - Agents can \"invent new capabilities\" rather than just calling existing ones</p>"},{"location":"Introduction/#key-advantages","title":"Key Advantages","text":""},{"location":"Introduction/#1-ai-written-tools-as-first-class-system-entities","title":"1. AI-Written Tools as First-Class System Entities","text":"<p>Redefining Tools in Agent Development 2.0:</p> <p>In traditional frameworks, tools are: - Fixed API lists - Pre-registered function interfaces defined by humans - Static capabilities that agents can only call</p> <p>In OpenSage (Agent Development 2.0), tools are: - Programmatic entities that agents can write, modify, and evolve - Runtime-generated capabilities that adapt to current tasks - First-class system entities with lifecycle management</p> <p>Supported Capabilities:</p> <p>OpenSage natively supports: - Agent-generated tools: Agents can create new tools (bash scripts, analysis scripts, debugging tools) - Tool modification: Agents can modify existing tools to adapt to current tasks - Runtime tool management:   - Multiple bash sessions for parallel execution   - Tool-specific sandboxes (especially for long-running tools like fuzzers)   - Tool state persistence and restoration, enabling cross-task reuse</p> <p>Design Value:</p> <p>This design enables: - Agents can \"invent new capabilities\" rather than just calling existing ones - Tool sets evolve with tasks, not statically bound - System has continuous self-expansion potential</p> <p>Implementation: - <code>ToolLoader</code> dynamically discovers tools from <code>src/aigise/bash_tools/</code> - Tools structured as \"Skills\" with metadata (<code>SKILL.md</code>) - <code>bash_tool</code> enables execution of arbitrary commands, allowing agents to create new tools</p>"},{"location":"Introduction/#2-runtime-generated-sub-agents-dynamic-agent-topology","title":"2. Runtime-Generated Sub-Agents &amp; Dynamic Agent Topology","text":"<p>Sub-Agent Positioning:</p> <p>Sub-agents are functionally specialized agents temporarily created for specific sub-tasks, such as: - Debugger Agent - Retrieval Agent - Fuzzer Agent - Memory Agent</p> <p>Supported Capabilities:</p> <p>OpenSage supports: - Runtime creation/destruction of sub-agents - Each sub-agent has:   - Independent identity   - Independent tool set   - Independent short-term memory - Recursive sub-agent creation: Sub-agents can create their own sub-agents</p> <p>Agent Topology:</p> <p>All agents and sub-agents form: - A task-specific agent graph (agent graph) - The graph can dynamically change during execution - Different tasks have different agent topology structures</p> <p>Agent Ensemble:</p> <p>System supports: - Parallel exploration: Multiple agents explore in parallel - Result merging: Results from multiple agents are merged - Dynamic trade-off: Balance between efficiency and stability - Thread-safe agent execution support</p> <p>Implementation: - <code>DynamicAgentManager</code> manages agent lifecycle - <code>AigiseEnsembleManager</code> coordinates multi-agent execution - Agents can discover and call other agents dynamically</p>"},{"location":"Introduction/#3-memory-as-manageable-system-resource","title":"3. Memory as Manageable System Resource","text":"<p>Layered Memory Model:</p> <p>OpenSage adopts: - Persistent long-term memory: Cross-session knowledge retention - Sub-agent specific short-term memory: Task-specific context</p> <p>Graph-Structured Memory:</p> <p>Memory is organized as a graph structure: - Nodes represent facts, events, summaries - Edges represent dependencies, causal relationships, or semantic relationships - Supports graph queries and retrieval</p> <p>Memory Agent:</p> <p>A dedicated memory agent (planned): - Decides when to store information - Determines when to compress or discard old information - Manages when to retrieve historical experience</p> <p>Memory is not passive context, but: - Runtime resource actively scheduled by agents - First-class entity in the system architecture</p> <p>Note: Graph-structured memory and Memory Agent are planned features and documentation will be added as these features are implemented.</p>"},{"location":"Introduction/#4-session-based-resource-isolation","title":"4. Session-Based Resource Isolation","text":"<p>Architecture: - Each session has completely isolated resources (sandboxes, configs, agents) - No global singletons \u2014 all resources are session-bound - Prevents interference between different agent runs - Clean resource management and cleanup</p>"},{"location":"Introduction/#5-multi-sandbox-support-with-flexible-backends","title":"5. Multi-Sandbox Support with Flexible Backends","text":"<p>Sandbox Types: - <code>main</code>: Primary analysis sandbox - <code>joern</code>: Static analysis (CPG generation) - <code>codeql</code>: CodeQL analysis - <code>neo4j</code>: Graph database for CPG storage - <code>gdb_mcp</code>: Debugger integration - <code>fuzz</code>: Fuzzing environment</p> <p>Backend Support: - Docker (Native): Local development and testing - Kubernetes: Production deployment with automatic scaling - Easy switching between backends via configuration</p> <p>Implementation: - <code>K8sSandbox</code> provides Kubernetes backend - <code>NativeDockerSandbox</code> for local Docker execution - Sandbox factory pattern for backend abstraction</p>"},{"location":"Introduction/#6-security-focused-system-level-customization","title":"6. Security-Focused System-Level Customization","text":"<p>OpenSage is not a generic agent demo, but deeply customized for software security and software engineering.</p> <p>Native Integration: - Static analysis tools: CPG generation, program slicing, call graphs (via Joern/CodeQL) - Dynamic analysis tools: Debuggers (GDB), fuzzing, coverage analysis (via sandbox tools) - LSP and code understanding tools: Language server protocol integration</p> <p>Agent Capabilities: Agents can: - Self-diagnose failure causes - Create specialized debugging sub-agents on demand - Adjust workflows based on runtime signals - Generate security-focused tools for specific vulnerability types</p> <p>This system-level customization makes OpenSage a powerful platform for security research and software engineering automation.</p>"},{"location":"Introduction/#design-philosophy","title":"Design Philosophy","text":""},{"location":"Introduction/#agent-development-20-principles","title":"Agent Development 2.0 Principles","text":"<ol> <li>First-Class Evolvable Entities: Tool / Agent / Workflow / Memory are all first-class, evolvable entities, not static configurations</li> <li>Minimal Scaffolding: Humans provide only stable system-level infrastructure</li> <li>Runtime Generation: Agents build structures at runtime, not design time</li> <li>Continuous Self-Extension: System has the potential for continuous self-expansion</li> </ol>"},{"location":"Introduction/#the-fundamental-innovation","title":"The Fundamental Innovation","text":"<p>Agent Development 2.0's innovation is not about: - Larger models - More complex prompts</p> <p>Instead, it's about: - Treating agents as entities that can build systems - Elevating Tool / Agent / Workflow / Memory to first-class, evolvable entities - Building infrastructure that enables agents to autonomously design, execute, and improve complex task systems</p>"},{"location":"Introduction/#key-features","title":"Key Features","text":"<ul> <li>AI-written tools as first-class system entities</li> <li>Runtime sub-agent creation and dynamic agent topology</li> <li>Memory as manageable resource (graph-structured, memory agent) - planned</li> <li>Session-based resource management with complete isolation</li> <li>Multi-sandbox support (Docker, Kubernetes)</li> <li>Dynamic tool loading and runtime tool generation</li> <li>Agent ensemble for parallel exploration</li> <li>Integration with security tools (Joern, CodeQL, GDB, Neo4j)</li> <li>Evaluation framework for security benchmarks</li> </ul>"},{"location":"Introduction/#why-opensage","title":"Why OpenSage?","text":"<p>OpenSage was designed to make self-programming agent development feel more like software development. It provides:</p> <ol> <li>Isolation: Each agent session has its own resources, preventing interference</li> <li>Flexibility: Easy to add new tools, sandboxes, and agents</li> <li>Evolution: Tools and agents can be created and modified at runtime</li> <li>Integration: Seamless integration with existing security analysis tools</li> <li>Composability: Build complex agents from simple components</li> <li>Scalability: Kubernetes support for production deployment</li> </ol>"},{"location":"Introduction/#use-cases","title":"Use Cases","text":"<ul> <li>Self-programming agent development</li> <li>Code generation and analysis</li> <li>Vulnerability detection and analysis</li> <li>Fuzzing campaign management</li> <li>Code coverage analysis</li> <li>Static code analysis (CPG generation)</li> <li>Multi-agent workflows</li> <li>Agent training and evaluation</li> </ul>"},{"location":"Introduction/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Set up your development environment</li> <li>Architecture - Understand the system architecture</li> <li>Core Concepts - Learn the core concepts</li> <li>Entry Points - Understand how to use OpenSage</li> </ul>"},{"location":"OpenSage-Web-Entry/","title":"opensage web - Interactive Development Entry Point","text":"<p>The <code>opensage web</code> command starts an interactive web UI for developing and debugging agents.</p>"},{"location":"OpenSage-Web-Entry/#cli-commands","title":"CLI Commands","text":""},{"location":"OpenSage-Web-Entry/#opensage-web","title":"opensage web","text":"<p>Starts an interactive web UI for agent development and debugging.</p> <pre><code>uv run opensage web \\\n  --config /path/to/config.toml \\\n  --agent /path/to/agent_dir \\\n  --port 8000 \\\n  --neo4j_logging  # optional\n</code></pre>"},{"location":"OpenSage-Web-Entry/#opensage-dependency-check","title":"opensage dependency-check","text":"<p>Checks if external dependencies are properly installed.</p> <pre><code>uv run opensage dependency-check\n</code></pre> <p>This command verifies: - CodeQL: Required for CodeQL static analysis features - Docker: Required for native Docker sandbox backend - kubectl: Required for Kubernetes sandbox backend</p> <p>All dependencies are optional unless you plan to use the corresponding features. The command will show: - Green checkmarks for available dependencies - Yellow warnings for missing optional dependencies - Red errors for missing required dependencies (if any)</p> <p>Example Output:</p> <pre><code>Checking OpenSage dependencies...\n\nChecking CodeQL...\n  [OK] CodeQL binary found at /path/to/codeql\n\nChecking Docker...\n  [OK] Docker daemon is running and accessible\n\nChecking kubectl...\n  [WARN] kubectl command not found in PATH. Install kubectl to use Kubernetes backend.\n    Note: Only required when using Kubernetes sandbox backend\n\n============================================================\n[WARN] Some dependencies missing (2/3 available)\n\nNote: Missing dependencies are optional unless you plan to use\nthe corresponding features.\n============================================================\n</code></pre>"},{"location":"OpenSage-Web-Entry/#step-by-step-workflow","title":"Step-by-Step Workflow","text":""},{"location":"OpenSage-Web-Entry/#step-1-command-parsing-and-validation","title":"Step 1: Command Parsing and Validation","text":"<ol> <li>CLI parses command-line arguments</li> <li>Validates that <code>config_path</code> exists and is a file</li> <li>Validates that <code>agent_dir</code> exists and is a directory</li> <li>Sets up logging based on <code>--log_level</code> option</li> </ol>"},{"location":"OpenSage-Web-Entry/#step-2-optional-neo4j-logging-setup","title":"Step 2: Optional Neo4j Logging Setup","text":"<p>If <code>--neo4j_logging</code> flag is provided: 1. Imports <code>enable_neo4j_logging</code> from <code>&lt;package&gt;.features.agent_history_tracker</code> 2. Enables Neo4j logging via monkey patches 3. This allows event logging to Neo4j for analysis</p>"},{"location":"OpenSage-Web-Entry/#step-3-environment-preparation-_prepare_environment_async","title":"Step 3: Environment Preparation (<code>_prepare_environment_async</code>)","text":"<p>This is the core setup phase that creates the OpenSage session and initializes all resources.</p>"},{"location":"OpenSage-Web-Entry/#31-create-session-id","title":"3.1 Create Session ID","text":"<ul> <li>Generates a unique UUID for the session</li> <li>Format: <code>str(uuid.uuid4())</code></li> <li>Example: <code>\"550e8400-e29b-41d4-a716-446655440000\"</code></li> </ul>"},{"location":"OpenSage-Web-Entry/#32-create-aigisesession","title":"3.2 Create AigiseSession","text":"<p><pre><code>aigise_session = get_aigise_session(\n    aigise_session_id=session_id,\n    config_path=config_path\n)\n</code></pre> - Loads TOML configuration file - Expands template variables (e.g., <code>${VAR_NAME}</code>) - Creates <code>AigiseSession</code> instance with all managers:   - <code>config</code>: Configuration manager   - <code>agents</code>: DynamicAgentManager   - <code>sandboxes</code>: AigiseSandboxManager   - <code>neo4j</code>: AigiseNeo4jClientManager   - <code>ensemble</code>: AigiseEnsembleManager</p>"},{"location":"OpenSage-Web-Entry/#33-load-agent-and-collect-dependencies","title":"3.3 Load Agent and Collect Dependencies","text":"<p><pre><code>mk_agent = _load_mk_agent_from_dir(agent_dir)\ndummy_agent = mk_agent(aigise_session_id=session_id)\nsandbox_dependencies = collect_sandbox_dependencies(dummy_agent)\n</code></pre> - Dynamically imports <code>agent.py</code> from the agent directory - Extracts the <code>mk_agent</code> function - Creates a dummy agent instance to analyze dependencies - Collects which sandbox types the agent requires (e.g., <code>{\"main\", \"joern\", \"neo4j\"}</code>)</p>"},{"location":"OpenSage-Web-Entry/#34-prune-unused-sandboxes","title":"3.4 Prune Unused Sandboxes","text":"<ul> <li>Compares required sandboxes with configured sandboxes</li> <li>Removes sandbox configurations that are not needed</li> <li>Example: If agent only needs <code>{\"main\", \"joern\"}</code>, removes <code>gdb_mcp</code>, <code>pdb_mcp</code>, etc.</li> <li>This optimizes startup time by not launching unnecessary containers</li> </ul>"},{"location":"OpenSage-Web-Entry/#35-initialize-shared-volumes","title":"3.5 Initialize Shared Volumes","text":"<p><pre><code>aigise_session.sandboxes.initialize_shared_volumes()\n</code></pre> - Creates Docker volumes for shared data:   - <code>scripts_volume</code>: Read-only scripts and tools   - <code>data_volume</code>: Read-write data directory - Configures volume mounts for all sandbox containers - Volumes are shared across all sandboxes in the session</p>"},{"location":"OpenSage-Web-Entry/#36-launch-sandbox-containers","title":"3.6 Launch Sandbox Containers","text":"<p><pre><code>await aigise_session.sandboxes.launch_all_sandboxes()\n</code></pre> For each required sandbox type: 1. Gets sandbox configuration from <code>session.config.sandbox.sandboxes[sandbox_type]</code> 2. Creates Docker container (or connects to existing one) 3. Sets up network, volumes, environment variables 4. Starts the container 5. Stores sandbox instance in <code>session.sandboxes._sandboxes[sandbox_type]</code></p>"},{"location":"OpenSage-Web-Entry/#37-initialize-sandboxes","title":"3.7 Initialize Sandboxes","text":"<p><pre><code>await aigise_session.sandboxes.initialize_all_sandboxes(continue_on_error=True)\n</code></pre> For each sandbox: 1. Finds the appropriate initializer (e.g., <code>JoernInitializer</code>, <code>FuzzInitializer</code>) 2. Calls <code>async_initialize()</code> method:    - Installs tools and dependencies    - Sets up environment    - Prepares resources    - Example: Joern initializer runs CPG generation scripts 3. Marks sandbox as ready 4. Continues even if one sandbox fails (due to <code>continue_on_error=True</code>)</p>"},{"location":"OpenSage-Web-Entry/#step-4-load-agent","title":"Step 4: Load Agent","text":"<pre><code>mk_agent = _load_mk_agent_from_dir(agent_dir)\nroot_agent = mk_agent(aigise_session_id=session_id)\n</code></pre> <ol> <li>Imports agent module again (ensuring latest code)</li> <li>Calls <code>mk_agent()</code> with the session ID</li> <li>Agent constructor:</li> <li>Gets session via <code>get_aigise_session(session_id)</code></li> <li>Loads dynamic tools from filesystem (if using <code>AigiseAgent</code>)</li> <li>Sets up tool combos, sub-agents, etc.</li> <li>Returns configured agent instance</li> </ol>"},{"location":"OpenSage-Web-Entry/#step-5-load-plugins","title":"Step 5: Load Plugins","text":"<pre><code>enabled_plugins = aigise_session.config.plugins.enabled or []\nplugins = load_plugins(enabled_plugins)\n</code></pre> <ol> <li>Reads plugin list from configuration</li> <li>Loads plugin classes dynamically</li> <li>Instantiates plugin objects</li> <li>Returns list of plugin instances</li> </ol>"},{"location":"OpenSage-Web-Entry/#step-6-create-adk-services","title":"Step 6: Create ADK Services","text":"<pre><code>session_service = AigiseInMemorySessionService()\nartifact_service = InMemoryArtifactService()\nmemory_service = InMemoryMemoryService()\ncredential_service = InMemoryCredentialService()\neval_sets_manager = LocalEvalSetsManager(agents_dir=agents_dir_parent)\neval_set_results_manager = LocalEvalSetResultsManager(agents_dir=agents_dir_parent)\n</code></pre> <ul> <li>Creates in-memory services for ADK integration</li> <li><code>AigiseInMemorySessionService</code> bridges ADK sessions with OpenSage sessions</li> <li>Other services are standard ADK in-memory implementations</li> </ul>"},{"location":"OpenSage-Web-Entry/#step-7-determine-app-name","title":"Step 7: Determine App Name","text":"<pre><code>app_name = os.path.basename(os.path.dirname(agent_dir.rstrip(os.sep)))\n</code></pre> <ul> <li>Extracts parent directory name as app name</li> <li>Example: <code>/path/to/examples/agents/my_agent</code> \u2192 <code>app_name = \"agents\"</code></li> </ul>"},{"location":"OpenSage-Web-Entry/#step-8-create-web-server","title":"Step 8: Create Web Server","text":"<pre><code>web_server = AigiseWebServer(\n    app_name=app_name,\n    root_agent=root_agent,\n    fixed_session_id=session_id,\n    session_service=session_service,\n    artifact_service=artifact_service,\n    memory_service=memory_service,\n    credential_service=credential_service,\n    eval_sets_manager=eval_sets_manager,\n    eval_set_results_manager=eval_set_results_manager,\n    plugins=plugins,\n)\n</code></pre> <ul> <li>Creates <code>AigiseWebServer</code> instance</li> <li>Configures all services and agent</li> <li>Sets up FastAPI endpoints for:</li> <li>Agent execution (<code>/run</code>)</li> <li>Server-Sent Events (<code>/events</code>)</li> <li>Live streaming (<code>/live</code>)</li> <li>Session management</li> <li>Artifact access</li> <li>Dev UI static files</li> </ul>"},{"location":"OpenSage-Web-Entry/#step-9-pre-create-adk-session","title":"Step 9: Pre-create ADK Session","text":"<pre><code>await session_service.create_session(\n    app_name=web_server.app_name,\n    user_id=\"user\",\n    state={\"aigise_session_id\": session_id},\n    session_id=session_id,\n)\n</code></pre> <ul> <li>Creates ADK session that maps to OpenSage session</li> <li>Stores <code>aigise_session_id</code> in session state</li> <li>This allows ADK Runner to find the OpenSage session</li> </ul>"},{"location":"OpenSage-Web-Entry/#step-10-create-fastapi-app","title":"Step 10: Create FastAPI App","text":"<pre><code>app = web_server.get_fast_api_app(allow_origins=None, enable_dev_ui=True)\n</code></pre> <ul> <li>Generates FastAPI application with all routes</li> <li>Enables CORS middleware</li> <li>Mounts static files for Dev UI</li> <li>Sets up WebSocket endpoints</li> </ul>"},{"location":"OpenSage-Web-Entry/#step-11-start-uvicorn-server","title":"Step 11: Start Uvicorn Server","text":"<pre><code>config = uvicorn.Config(app, host=host, port=port, reload=reload, log_level=log_level.lower())\nserver = uvicorn.Server(config)\nserver.run()\n</code></pre> <ul> <li>Configures Uvicorn ASGI server</li> <li>Starts server on specified host/port</li> <li>If <code>reload=True</code>, watches for code changes and restarts</li> <li>Server runs until interrupted (Ctrl+C)</li> </ul>"},{"location":"OpenSage-Web-Entry/#user-interaction-flow","title":"User Interaction Flow","text":"<p>Once the server is running:</p> <ol> <li>User opens browser to <code>http://localhost:8000</code></li> <li>Dev UI loads and connects to backend</li> <li>User types a message in the chat interface</li> <li>Frontend sends POST request to <code>/run</code> endpoint</li> <li>Web server creates ADK Runner with the agent</li> <li>Runner executes agent with user message</li> <li>Events are streamed back via Server-Sent Events</li> <li>Frontend displays agent responses in real-time</li> <li>User can continue conversation or start new session</li> </ol>"},{"location":"OpenSage-Web-Entry/#key-differences-from-evaluation","title":"Key Differences from Evaluation","text":"<ul> <li>Single session: One OpenSage session for the entire web server</li> <li>Interactive: User can send multiple messages</li> <li>Real-time: Events streamed as they happen</li> <li>Development-focused: Hot reload, debugging tools, Dev UI</li> <li>Long-lived: Server runs until manually stopped</li> </ul>"},{"location":"OpenSage-Web-Entry/#cleanup","title":"Cleanup","text":"<p>When server stops (Ctrl+C): 1. Signal handler calls <code>cleanup_all_sessions()</code> 2. All sandbox containers are stopped 3. Shared volumes are cleaned up (if configured) 4. Session registry is cleared</p>"},{"location":"OpenSage-Web-Entry/#related-topics","title":"Related Topics","text":"<ul> <li>Core Concepts - Understanding sessions and sandboxes</li> <li>Development Guides - How to develop agents</li> <li>Testing Debugging - Debugging with web UI</li> </ul>"},{"location":"Project-Structure/","title":"Project Structure","text":""},{"location":"Project-Structure/#directory-overview","title":"Directory Overview","text":"<pre><code>OpenSage/\n\u251c\u2500\u2500 src/aigise/              # Main source code\n\u2502   \u251c\u2500\u2500 agents/              # Agent implementations\n\u2502   \u251c\u2500\u2500 cli/                 # Command-line interface\n\u2502   \u251c\u2500\u2500 config/              # Configuration system\n\u2502   \u251c\u2500\u2500 session/             # Session management\n\u2502   \u251c\u2500\u2500 sandbox/             # Sandbox implementations\n\u2502   \u251c\u2500\u2500 toolbox/             # Security analysis tools\n\u2502   \u251c\u2500\u2500 evaluations/         # Benchmark evaluations\n\u2502   \u251c\u2500\u2500 features/            # Framework features\n\u2502   \u251c\u2500\u2500 plugins/             # ADK plugins\n\u2502   \u251c\u2500\u2500 patches/             # ADK patches\n\u2502   \u2514\u2500\u2500 templates/           # Configuration templates\n\u251c\u2500\u2500 examples/                # Example agents and usage\n\u251c\u2500\u2500 tests/                   # Test suite\n\u251c\u2500\u2500 docs/                    # Documentation\n\u2514\u2500\u2500 README.md               # Quick start guide\n</code></pre>"},{"location":"Project-Structure/#key-directories-explained","title":"Key Directories Explained","text":""},{"location":"Project-Structure/#srcaigiseagents","title":"<code>src/aigise/agents/</code>","text":"<ul> <li><code>aigise_agent.py</code>: Extended ADK agent class</li> <li>Tool loading and dynamic tool injection</li> </ul>"},{"location":"Project-Structure/#srcaigisesession","title":"<code>src/aigise/session/</code>","text":"<ul> <li><code>aigise_session.py</code>: Main session manager</li> <li><code>aigise_sandbox_manager.py</code>: Sandbox lifecycle management</li> <li><code>aigise_dynamic_agent_manager.py</code>: Agent creation and caching</li> <li><code>aigise_ensemble_manager.py</code>: Multi-agent coordination</li> </ul>"},{"location":"Project-Structure/#srcaigisesandbox","title":"<code>src/aigise/sandbox/</code>","text":"<ul> <li><code>base_sandbox.py</code>: Abstract sandbox interface</li> <li><code>native_docker_sandbox.py</code>: Docker-based sandbox</li> <li><code>k8s_sandbox.py</code>: Kubernetes-based sandbox</li> <li><code>initializers/</code>: Sandbox initialization logic</li> </ul>"},{"location":"Project-Structure/#srcaigisetoolbox","title":"<code>src/aigise/toolbox/</code>","text":"<ul> <li><code>static_analysis/</code>: Joern, CodeQL integration</li> <li><code>fuzzing/</code>: Fuzzing tools</li> <li><code>debugger/</code>: GDB integration</li> <li><code>coverage/</code>: Coverage analysis</li> <li><code>retrieval/</code>: Code search tools</li> </ul>"},{"location":"Project-Structure/#srcaigiseevaluations","title":"<code>src/aigise/evaluations/</code>","text":"<ul> <li><code>cybergym/</code>: CyberGym benchmark</li> <li><code>patchagent/</code>: PatchAgent benchmark</li> <li><code>secodeplt/</code>: SecCodePLT benchmark</li> </ul>"},{"location":"Project-Structure/#see-also","title":"See Also","text":"<ul> <li>Core Components - Component details</li> <li>Development Guides - How to add to the codebase</li> </ul>"},{"location":"RL-Integration/","title":"RL Framework Integration","text":"<p>AIgiSE provides seamless integration with RL frameworks (slime, verl, areal, etc.) for agent training and evaluation. This integration allows RL frameworks to use AIgiSE agents as rollout systems.</p>"},{"location":"RL-Integration/#overview","title":"Overview","text":"<p>The RL integration module (<code>aigise.rl_integration</code>) provides:</p> <ul> <li>Client: Manages agent configuration and model setup</li> <li>RLSession: Wraps AigiseSession with framework-specific generate methods</li> <li>Adapters: Framework-specific logic for sample handling (slime, verl, areal)</li> </ul>"},{"location":"RL-Integration/#architecture","title":"Architecture","text":"<pre><code>RL Framework (slime/verl/areal)\n    \u2193\nAIgiSE Client\n    \u2193\nRLSession (wraps AigiseSession)\n    \u2193\nFramework Adapter (SlimeAdapter/VerlAdapter/ArealAdapter)\n    \u2193\nAgent Execution\n</code></pre>"},{"location":"RL-Integration/#basic-usage","title":"Basic Usage","text":""},{"location":"RL-Integration/#creating-a-client","title":"Creating a Client","text":"<pre><code>import aigise\n\n# Create client for agent and benchmark\nclient = aigise.create(\n    agent_name=\"vul_agent\",\n    benchmark_name=\"secodeplt\"\n)\n</code></pre> <p>The <code>create()</code> function: - Resolves the agent directory from <code>examples/agents/&lt;agent_name&gt;/</code> - Loads the benchmark interface from <code>aigise/evaluations/&lt;benchmark_name&gt;/</code> - Creates a <code>Client</code> instance with agent and benchmark configuration</p>"},{"location":"RL-Integration/#using-rlsession","title":"Using RLSession","text":"<pre><code># Initialize session and generate samples\nwith client.init_session() as session:\n    # For slime framework\n    sample = await session.slime_generate(\n        args=args,\n        sample=sample,\n        sampling_params=sampling_params\n    )\n\n    # For verl framework (when implemented)\n    # sample = await session.verl_generate(args, sample, sampling_params)\n\n    # For areal framework (when implemented)\n    # sample = await session.areal_generate(args, sample, sampling_params)\n</code></pre>"},{"location":"RL-Integration/#framework-specific-methods","title":"Framework-Specific Methods","text":"<p>Each framework has its own generate method:</p> <ul> <li><code>slime_generate()</code>: For slime framework integration</li> <li><code>verl_generate()</code>: For verl framework integration (planned)</li> <li><code>areal_generate()</code>: For areal framework integration (planned)</li> </ul>"},{"location":"RL-Integration/#client-api","title":"Client API","text":""},{"location":"RL-Integration/#client__init__agent_name-benchmark_name","title":"<code>Client.__init__(agent_name, benchmark_name)</code>","text":"<p>Initializes the client with agent and benchmark configuration.</p> <p>Parameters: - <code>agent_name</code>: Name of the agent (must exist in <code>examples/agents/</code>) - <code>benchmark_name</code>: Name of the benchmark (must exist in <code>aigise/evaluations/</code>)</p> <p>Raises: - <code>ValueError</code>: If agent or benchmark not found</p>"},{"location":"RL-Integration/#clientinit_session","title":"<code>Client.init_session()</code>","text":"<p>Creates and returns an <code>RLSession</code> context manager.</p> <p>Returns: - <code>RLSession</code>: Session context manager for agent execution</p> <p>Usage: <pre><code>with client.init_session() as session:\n    # Use session for agent execution\n    pass\n</code></pre></p>"},{"location":"RL-Integration/#rlsession-api","title":"RLSession API","text":""},{"location":"RL-Integration/#rlsessionslime_generateargs-sample-sampling_params","title":"<code>RLSession.slime_generate(args, sample, sampling_params)</code>","text":"<p>Generates a sample using the slime framework adapter.</p> <p>Parameters: - <code>args</code>: Framework-specific arguments - <code>sample</code>: Input sample to process - <code>sampling_params</code>: Sampling parameters</p> <p>Returns: - Processed sample with agent output</p>"},{"location":"RL-Integration/#rlsessionverl_generateargs-sample-sampling_params","title":"<code>RLSession.verl_generate(args, sample, sampling_params)</code>","text":"<p>Generates a sample using the verl framework adapter (planned).</p>"},{"location":"RL-Integration/#rlsessionareal_generateargs-sample-sampling_params","title":"<code>RLSession.areal_generate(args, sample, sampling_params)</code>","text":"<p>Generates a sample using the areal framework adapter (planned).</p>"},{"location":"RL-Integration/#adapters","title":"Adapters","text":"<p>Adapters handle framework-specific logic for sample processing:</p> <ul> <li><code>SlimeAdapter</code>: Handles slime framework sample format and processing</li> <li><code>VerlAdapter</code>: Handles verl framework sample format (planned)</li> <li><code>ArealAdapter</code>: Handles areal framework sample format (planned)</li> </ul> <p>Each adapter implements the <code>BaseAdapter</code> interface and provides: - Sample format conversion - Framework-specific parameter handling - Result formatting</p>"},{"location":"RL-Integration/#benchmark-interface","title":"Benchmark Interface","text":"<p>The benchmark interface (<code>BenchmarkInterface</code>) provides:</p> <ul> <li>Benchmark configuration loading</li> <li>Evaluation instance creation</li> <li>Task data management</li> </ul> <p>Benchmarks are automatically loaded from <code>aigise/evaluations/&lt;benchmark_name&gt;/</code> and must implement the <code>BenchmarkInterface</code> protocol.</p>"},{"location":"RL-Integration/#example-complete-workflow","title":"Example: Complete Workflow","text":"<pre><code>import aigise\n\n# 1. Create client\nclient = aigise.create(\"vul_agent\", \"secodeplt\")\n\n# 2. Initialize session\nwith client.init_session() as session:\n    # 3. Generate samples for training\n    for sample in training_samples:\n        result = await session.slime_generate(\n            args=training_args,\n            sample=sample,\n            sampling_params=sampling_params\n        )\n        # Process result...\n</code></pre>"},{"location":"RL-Integration/#session-lifecycle","title":"Session Lifecycle","text":"<ol> <li>Session Creation: <code>init_session()</code> creates a new AigiseSession</li> <li>Agent Loading: Agent is loaded and configured</li> <li>Sandbox Initialization: Required sandboxes are launched and initialized</li> <li>Sample Generation: Framework-specific generate methods execute agents</li> <li>Session Cleanup: Session and resources are cleaned up on exit</li> </ol>"},{"location":"RL-Integration/#integration-points","title":"Integration Points","text":"<p>The RL integration automatically handles:</p> <ul> <li>Agent Configuration: Loads agent from <code>examples/agents/</code></li> <li>Model Setup: Configures LLM models from agent configuration</li> <li>Session Management: Creates and manages AigiseSession lifecycle</li> <li>Sandbox Management: Launches and initializes required sandboxes</li> <li>Benchmark Integration: Loads benchmark interface and evaluation instances</li> <li>Framework Adapters: Provides framework-specific sample handling</li> </ul>"},{"location":"RL-Integration/#see-also","title":"See Also","text":"<ul> <li>Entry Points - Overview of all entry points</li> <li>Core Concepts - Understanding sessions and agents</li> <li>Architecture - System architecture</li> </ul>"},{"location":"Sandboxes/","title":"Sandbox System Guide","text":""},{"location":"Sandboxes/#overview","title":"Overview","text":"<p>The AIgiSE sandbox system provides isolated execution environments through a pluggable backend architecture. This guide covers:</p> <ul> <li>Sandbox Backends: Execution engines (Native Docker, Remote Docker, Kubernetes)</li> <li>Sandbox Initializers: Functional types (main, neo4j, joern, gdb_mcp, etc.)</li> </ul>"},{"location":"Sandboxes/#sandbox-backends","title":"Sandbox Backends","text":"<p>Backends determine where and how containers are executed.</p>"},{"location":"Sandboxes/#available-backends","title":"Available Backends","text":"Backend Description Use Case native Local Docker daemon Development, testing remotedocker Remote Docker via SSH/TCP Remote execution, GPU servers k8s Kubernetes cluster Production, multi-node local No containers (direct execution) Debugging"},{"location":"Sandboxes/#selecting-a-backend","title":"Selecting a Backend","text":"<p>In configuration file:</p> <pre><code>[sandbox]\nbackend = \"native\"  # or \"remotedocker\", \"k8s\", \"local\"\n</code></pre>"},{"location":"Sandboxes/#remote-docker-backend","title":"Remote Docker Backend","text":"<p>Execute sandboxes on remote Docker daemons (e.g., GPU servers, cloud VMs).</p>"},{"location":"Sandboxes/#prerequisites","title":"Prerequisites","text":"<p>Local Machine: - SSH client</p> <p>Remote Machine: - Docker Engine 20.10+ - SSH server - User in docker group</p>"},{"location":"Sandboxes/#ssh-setup","title":"SSH Setup","text":"<ol> <li> <p>Generate SSH key (if needed):    <pre><code>ssh-keygen -t ed25519\n</code></pre></p> </li> <li> <p>Copy key to remote:    <pre><code>ssh-copy-id username@remote-host\n</code></pre></p> </li> <li> <p>Configure SSH (<code>~/.ssh/config</code>):    <pre><code>Host my-remote-server\n    HostName remote-host.example.com\n    User username\n    IdentityFile ~/.ssh/id_ed25519\n</code></pre></p> </li> <li> <p>Verify:    <pre><code>ssh my-remote-server \"docker ps\"\n</code></pre></p> </li> </ol>"},{"location":"Sandboxes/#configuration","title":"Configuration","text":"<pre><code>[sandbox]\nbackend = \"remotedocker\"\ndocker_host = \"ssh://my-remote-server\"\ndocker_remote_host = \"192.0.2.100\"  # optional, auto-parsed if not set\n\n[sandbox.sandboxes.main]\nimage = \"ubuntu:22.04\"\n# Same as native backend\n</code></pre>"},{"location":"Sandboxes/#how-it-works","title":"How It Works","text":"<ul> <li>Image operations: Build/pull on remote Docker</li> <li>Volume creation: Data transferred via Docker API (put_archive)</li> <li>Port allocation: Dynamic (Docker assigns random ports)</li> <li>Service access: Local connects to <code>remote_host:dynamic_port</code></li> <li>Container execution: All containers run on remote host</li> </ul>"},{"location":"Sandboxes/#differences-from-native-backend","title":"Differences from Native Backend","text":"Feature Native Remote Docker Container location Local machine Remote machine Volume creation Instant (bind mount) Slower (data upload) Image build Local Remote (with context upload) Port allocation Loopback IP (127.0.0.x) Dynamic ports Concurrent tasks ~250 (IP limit) 1000+ (port-based)"},{"location":"Sandboxes/#adding-a-new-sandbox-initializer","title":"Adding a New Sandbox Initializer","text":"<p>Initializers add specific functionality to sandboxes (e.g., Neo4j, Joern, debugging tools).</p>"},{"location":"Sandboxes/#steps","title":"Steps","text":"<ol> <li>Create initializer in <code>src/&lt;package&gt;/sandbox/initializers/</code></li> <li>Implement <code>SandboxInitializer</code> interface</li> <li>Add configuration in <code>config_dataclass.py</code></li> <li>Update default config template</li> </ol>"},{"location":"Sandboxes/#python-dependencies-in-sandbox-images","title":"Python Dependencies in Sandbox Images","text":"<p>If your sandbox initializer or tools need Python packages, install them in the sandbox Docker image (not at runtime via <code>pip install</code> inside the running container).</p> <p>Recommended pattern (used by <code>main</code>, <code>joern</code>, <code>gdb_mcp</code>, <code>pdb_mcp</code>):</p> <ol> <li>Install <code>uv</code> in the Dockerfile:</li> </ol> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <ol> <li>Create a venv under <code>/app</code>:</li> </ol> <pre><code>uv venv --python 3.12\n</code></pre> <ol> <li>Install Python deps into the venv:</li> </ol> <pre><code>uv pip install &lt;deps...&gt;\n</code></pre> <p>Note: sandbox command execution is non-persistent (each command is a fresh process). Do not rely on <code>source /app/.venv/bin/activate</code> carrying over between commands. Prefer <code>/app/.venv/bin/python ...</code>.</p>"},{"location":"Sandboxes/#example","title":"Example","text":"<pre><code># src/&lt;package&gt;/sandbox/initializers/my_sandbox.py\nfrom .base import SandboxInitializer\n\nclass MySandboxInitializer(SandboxInitializer):\n    async def async_initialize(self) -&gt; None:\n        # Initialize sandbox-specific resources\n        # Access session via self if needed\n        pass\n</code></pre>"},{"location":"Sandboxes/#configuration_1","title":"Configuration","text":"<p>Add sandbox configuration in TOML:</p> <pre><code>[sandbox.sandboxes.my_sandbox]\nimage = \"my_image:tag\"\n# ... other config options\n</code></pre>"},{"location":"Sandboxes/#initialization-flow","title":"Initialization Flow","text":"<ol> <li>Sandbox container is created</li> <li><code>async_initialize()</code> is called</li> <li>Resources are set up</li> <li>Sandbox is ready for use</li> </ol>"},{"location":"Sandboxes/#see-also","title":"See Also","text":"<ul> <li>Core Components - Sandbox system details</li> <li>Core Concepts - Sandbox lifecycle</li> <li>Development Guides - Other development guides</li> </ul>"},{"location":"Testing-Debugging/","title":"Testing &amp; Debugging","text":""},{"location":"Testing-Debugging/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest tests/\n\n# Run specific test file\nuv run pytest tests/unit/test_session.py\n\n# Run with coverage\nuv run pytest --cov=src/aigise tests/\n</code></pre>"},{"location":"Testing-Debugging/#debugging-with-web-ui","title":"Debugging with Web UI","text":"<p>The web UI is the primary debugging tool:</p> <pre><code>uv run opensage web \\\n  --config /path/to/config.toml \\\n  --agent /path/to/agent_dir \\\n  --port 8080 \\\n  --neo4j_logging  # optional\n</code></pre>"},{"location":"Testing-Debugging/#debugging-sandboxes","title":"Debugging Sandboxes","text":"<pre><code># In your code\nsandbox = session.sandboxes.get_sandbox(\"main\")\nresult, exit_code = sandbox.run_command_in_container(\"pwd\")\nprint(f\"Working dir: {result}\")\n</code></pre>"},{"location":"Testing-Debugging/#logging","title":"Logging","text":"<p>OpenSage uses structured logging:</p> <pre><code>import logging\nlogger = logging.getLogger(__name__)\nlogger.info(\"Operation started\", extra={\"session_id\": session_id})\n</code></pre>"},{"location":"Testing-Debugging/#common-debugging-tasks","title":"Common Debugging Tasks","text":"<ul> <li>Check session logs</li> <li>Verify sandbox container status</li> <li>Check configuration values</li> <li>Verify tool imports</li> <li>Check ADK compatibility</li> </ul>"},{"location":"Testing-Debugging/#see-also","title":"See Also","text":"<ul> <li>Best Practices - Development best practices</li> </ul>"},{"location":"_Sidebar/","title":"Sidebar","text":""},{"location":"_Sidebar/#navigation","title":"Navigation","text":""},{"location":"_Sidebar/#home","title":"Home","text":"<ul> <li>Home</li> </ul>"},{"location":"_Sidebar/#getting-started","title":"Getting Started","text":"<ul> <li>Introduction</li> <li>Getting Started</li> <li>Project Structure</li> </ul>"},{"location":"_Sidebar/#entry-points","title":"Entry Points","text":"<ul> <li>Entry Points</li> <li>OpenSage Web Entry</li> <li>Evaluation Entry</li> <li>RL Integration</li> </ul>"},{"location":"_Sidebar/#architecture","title":"Architecture","text":"<ul> <li>Architecture</li> <li>Core Components</li> <li>Core Concepts</li> </ul>"},{"location":"_Sidebar/#development","title":"Development","text":"<ul> <li>Development Guides</li> <li>Adding Tools</li> <li>Sandboxes</li> <li>Adding Evaluations</li> </ul>"},{"location":"_Sidebar/#practices","title":"Practices","text":"<ul> <li>Best Practices</li> <li>Common Patterns</li> <li>Testing Debugging</li> </ul>"},{"location":"_Sidebar/#reference","title":"Reference","text":"<ul> <li>Configuration</li> <li>Contributing</li> </ul>"},{"location":"generated/api/cli/","title":"CLI","text":""},{"location":"generated/api/cli/#aigise.cli.aigise_cli","title":"<code>aigise.cli.aigise_cli</code>","text":""},{"location":"generated/api/cli/#aigise.cli.aigise_cli.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/cli/#aigise.cli.aigise_cli.AigiseInMemorySessionService","title":"<code>AigiseInMemorySessionService</code>","text":"<p>               Bases: <code>BaseSessionService</code></p> <p>In-memory SessionService without deepcopy and without app/user state.</p> <p>Differences vs google.adk.sessions.in_memory_session_service.InMemorySessionService: - No deepcopy on reads; callers receive and mutate the live Session object. - No app_state/user_state accumulation or merging; only per-session state. - GetSessionConfig is ignored (we do not slice events on get). - One live Session object instance per (app_name, user_id, session_id).</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.AigiseWebServer","title":"<code>AigiseWebServer</code>","text":"<p>Single-agent FastAPI server reusing provided agent and services.</p> <ul> <li>Binds to a single app_name and prebuilt <code>root_agent</code></li> <li>Does not reload agent or auto-discover agents</li> <li>Uses provided services (session/artifact/memory/credentials)</li> <li>Exposes rich endpoints: run, SSE, live, session CRUD, artifacts, dev-UI</li> </ul>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli._load_mk_agent_from_dir","title":"<code>_load_mk_agent_from_dir(agent_dir: str)</code>","text":"<p>Load mk_agent callable from an agent folder.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli._prepare_environment_async","title":"<code>_prepare_environment_async(config_path: str, agent_dir: str) -&gt; str</code>  <code>async</code>","text":"<p>Prepare AIgiSE environment: create session and initialize sandboxes.</p> <p>Returns:</p> Type Description <code>str</code> <p>The created AIgiSE session_id (used to bind agent state).</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli._verify_agent_module","title":"<code>_verify_agent_module(agent_dir: str) -&gt; None</code>","text":"<p>Best-effort precheck to load agent module early.</p> <p>This surfaces import errors before starting the server.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.cli_dependency_check","title":"<code>cli_dependency_check()</code>","text":"<p>Check AIgiSE external dependencies.</p> <p>Checks for manually installed dependencies: - CodeQL: Required for CodeQL static analysis features - Docker: Required for native Docker sandbox backend - kubectl: Required for Kubernetes sandbox backend</p> <p>All dependencies are optional unless you plan to use the corresponding features.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.cli_web","title":"<code>cli_web(config_path: str, agent_dir: str, host: str, port: int, reload: bool, log_level: str, neo4j_logging: bool)</code>","text":"<p>Starts an AIgiSE-flavored Web UI: prepare environment then serve agents.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.collect_sandbox_dependencies","title":"<code>collect_sandbox_dependencies(agent) -&gt; set[str]</code>","text":"<p>Collect all sandbox dependencies from an agent and its tools.</p> <p>This function performs static analysis on an agent's tools to determine which sandboxes are required. It checks for <code>__sandbox_requirements__</code> metadata on: - Direct tool functions (decorated with @requires_sandbox) - Toolset instances (including MCP toolsets, returned by get_toolset() functions decorated with @requires_sandbox) - AgentTools (agents wrapped as tools, recursively) - Sub-agents (recursively)</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <p>An agent instance (LlmAgent, SequentialAgent, AigiseAgent, etc.)</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of sandbox type names required by the agent and all its sub-agents and mcp toolsets.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.get_aigise_session","title":"<code>get_aigise_session(aigise_session_id: str, config_path: Optional[str] = None) -&gt; AigiseSession</code>","text":"<p>Get or create an AigiseSession for the given session ID.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.load_plugins","title":"<code>load_plugins(enabled: Iterable[str] | None) -&gt; List[BasePlugin]</code>","text":"<p>Instantiate plugins in the order provided by <code>enabled</code>.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.main","title":"<code>main()</code>","text":"<p>AIgiSE CLI tools.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.verify_codeql","title":"<code>verify_codeql() -&gt; VerificationResult</code>","text":"<p>Verify CodeQL installation.</p> <p>Returns:</p> Type Description <code>VerificationResult</code> <p>VerificationResult indicating if CodeQL is ready.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.verify_docker","title":"<code>verify_docker() -&gt; VerificationResult</code>","text":"<p>Verify Docker installation and daemon availability.</p> <p>Returns:</p> Type Description <code>VerificationResult</code> <p>VerificationResult indicating if Docker is available.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_cli.verify_kubectl","title":"<code>verify_kubectl() -&gt; VerificationResult</code>","text":"<p>Verify kubectl installation and Kubernetes cluster connectivity.</p> <p>Returns:</p> Type Description <code>VerificationResult</code> <p>VerificationResult indicating if kubectl is available.</p>"},{"location":"generated/api/cli/#aigise.cli.aigise_web_app","title":"<code>aigise.cli.aigise_web_app</code>","text":""},{"location":"generated/api/cli/#aigise.cli.aigise_web_app.logger","title":"<code>logger = logging.getLogger('aigise.' + __name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/cli/#aigise.cli.aigise_web_app.AigiseWebServer","title":"<code>AigiseWebServer</code>","text":"<p>Single-agent FastAPI server reusing provided agent and services.</p> <ul> <li>Binds to a single app_name and prebuilt <code>root_agent</code></li> <li>Does not reload agent or auto-discover agents</li> <li>Uses provided services (session/artifact/memory/credentials)</li> <li>Exposes rich endpoints: run, SSE, live, session CRUD, artifacts, dev-UI</li> </ul>"},{"location":"generated/api/cli/#aigise.cli.aigise_web_app._InMemoryExporter","title":"<code>_InMemoryExporter</code>","text":"<p>               Bases: <code>SpanExporter</code></p>"},{"location":"generated/api/memory/","title":"Memory","text":""},{"location":"generated/api/memory/#aigise.memory.search.search_controller","title":"<code>aigise.memory.search.search_controller</code>","text":"<p>Search controller for orchestrating memory searches.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.STRATEGY_REGISTRY","title":"<code>STRATEGY_REGISTRY = {'embedding_search': EmbeddingSearchStrategy, 'keyword_search': KeywordSearchStrategy, 'title_browse': TitleBrowseStrategy}</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/memory/#aigise.memory.search.search_controller.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig","title":"<code>DomainConfig</code>  <code>dataclass</code>","text":"<p>Configuration for a knowledge domain in the memory system.</p> <p>A domain defines a coherent set of node types, relationships, and search strategies for a particular area of knowledge (e.g., code, Q&amp;A pairs, documentation).</p> <p>Multiple domains can be combined to create a rich knowledge graph.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.default_strategy","title":"<code>default_strategy: str = 'embedding_search'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default search strategy if LLM doesn't select one.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.description","title":"<code>description: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Human-readable description of the domain.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.embedding_dimension","title":"<code>embedding_dimension: int = 3072</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default embedding dimension for this domain (Gemini default).</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Unique identifier for this domain.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.node_types","title":"<code>node_types: Dict[str, NodeTypeConfig] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Node type configurations keyed by label.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.relationships","title":"<code>relationships: Dict[str, RelationshipConfig] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Relationship configurations keyed by type name.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.search_strategies","title":"<code>search_strategies: List[str] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Ordered list of search strategy names to try.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate and register the domain configuration.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.get_node_labels","title":"<code>get_node_labels() -&gt; List[str]</code>","text":"<p>Get all node labels in this domain.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.get_node_type","title":"<code>get_node_type(label: str) -&gt; Optional[NodeTypeConfig]</code>","text":"<p>Get a node type configuration by label.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.get_relationship","title":"<code>get_relationship(type_name: str) -&gt; Optional[RelationshipConfig]</code>","text":"<p>Get a relationship configuration by type name.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.get_relationship_types","title":"<code>get_relationship_types() -&gt; List[str]</code>","text":"<p>Get all relationship types in this domain.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.get_similarity_searchable_types","title":"<code>get_similarity_searchable_types() -&gt; List[str]</code>","text":"<p>Get node types that support similarity search.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.merge_with","title":"<code>merge_with(other: 'DomainConfig') -&gt; 'DomainConfig'</code>","text":"<p>Merge this domain with another, creating a combined configuration.</p> <p>The other domain's configurations take precedence on conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'DomainConfig'</code> <p>Another domain configuration to merge with.</p> required <p>Returns:</p> Type Description <code>'DomainConfig'</code> <p>New merged DomainConfig.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.DomainConfig.validate","title":"<code>validate() -&gt; List[str]</code>","text":"<p>Validate the domain configuration.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of validation error messages (empty if valid).</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.MemorySearchController","title":"<code>MemorySearchController</code>","text":"<p>Controller for orchestrating memory search operations.</p> <p>This controller: 1. Selects appropriate search strategies (LLM-driven or heuristic) 2. Executes searches with multi-round refinement 3. Evaluates result sufficiency 4. Combines results from multiple strategies if needed</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.MemorySearchController.__init__","title":"<code>__init__(domain_config: Optional['DomainConfig'] = None, max_iterations: int = 3, sufficiency_threshold: int = 1, use_llm_selection: bool = True)</code>","text":"<p>Initialize the search controller.</p> <p>Parameters:</p> Name Type Description Default <code>domain_config</code> <code>Optional['DomainConfig']</code> <p>Domain configuration defining available strategies.</p> <code>None</code> <code>max_iterations</code> <code>int</code> <p>Maximum number of refinement iterations.</p> <code>3</code> <code>sufficiency_threshold</code> <code>int</code> <p>Minimum results needed to consider sufficient.</p> <code>1</code> <code>use_llm_selection</code> <code>bool</code> <p>Whether to use LLM for strategy selection.</p> <code>True</code>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.MemorySearchController.add_strategy","title":"<code>add_strategy(name: str, strategy: SearchStrategy) -&gt; None</code>","text":"<p>Add a custom search strategy.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.MemorySearchController.get_available_strategies","title":"<code>get_available_strategies() -&gt; List[str]</code>","text":"<p>Get names of available strategies.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.MemorySearchController.search","title":"<code>search(query: str, node_types: Optional[List[str]] = None, client: Any = None, max_results: int = 10, min_score: float = 0.0, metadata: Optional[Dict[str, Any]] = None) -&gt; SearchResult</code>  <code>async</code>","text":"<p>Execute a memory search.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query.</p> required <code>node_types</code> <code>Optional[List[str]]</code> <p>Optional list of node types to search.</p> <code>None</code> <code>client</code> <code>Any</code> <p>Neo4j client for executing queries.</p> <code>None</code> <code>max_results</code> <code>int</code> <p>Maximum results to return.</p> <code>10</code> <code>min_score</code> <code>float</code> <p>Minimum score threshold.</p> <code>0.0</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional search context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SearchResult</code> <p>SearchResult with found items and metadata.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchContext","title":"<code>SearchContext</code>  <code>dataclass</code>","text":"<p>Context for a search operation.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchContext.domain_config","title":"<code>domain_config: Optional['DomainConfig'] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Domain configuration to use.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchContext.max_results","title":"<code>max_results: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum number of results to return.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchContext.metadata","title":"<code>metadata: Dict[str, Any] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional context metadata.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchContext.min_score","title":"<code>min_score: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Minimum score threshold.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchContext.node_types","title":"<code>node_types: Optional[List[str]] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Restrict search to specific node types (None = all).</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchContext.query","title":"<code>query: str</code>  <code>instance-attribute</code>","text":"<p>The search query.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult","title":"<code>SearchResult</code>  <code>dataclass</code>","text":"<p>Result of a memory search operation.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult.has_results","title":"<code>has_results: bool</code>  <code>property</code>","text":"<p>Check if any results were found.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult.items","title":"<code>items: List[SearchResultItem] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Search result items.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult.iterations","title":"<code>iterations: int = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of search iterations performed.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult.metadata","title":"<code>metadata: Dict[str, Any] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional search metadata.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult.strategy_used","title":"<code>strategy_used: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the strategy that found results.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult.sufficient","title":"<code>sufficient: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the results are considered sufficient.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult.total_found","title":"<code>total_found: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Total number of results found (before limiting).</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResult.get_best_result","title":"<code>get_best_result() -&gt; Optional[SearchResultItem]</code>","text":"<p>Get the highest-scoring result.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResultItem","title":"<code>SearchResultItem</code>  <code>dataclass</code>","text":"<p>A single search result item.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResultItem.highlight","title":"<code>highlight: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Highlighted match context (for keyword search).</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResultItem.match_type","title":"<code>match_type: str = 'exact'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Type of match: 'exact', 'similarity', 'keyword', 'browse'.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResultItem.node_id","title":"<code>node_id: str</code>  <code>instance-attribute</code>","text":"<p>The Neo4j element ID of the matched node.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResultItem.node_label","title":"<code>node_label: str</code>  <code>instance-attribute</code>","text":"<p>The Neo4j label of the matched node.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResultItem.properties","title":"<code>properties: Dict[str, Any]</code>  <code>instance-attribute</code>","text":"<p>Properties of the matched node.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResultItem.score","title":"<code>score: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Relevance score (0.0 to 1.0).</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchResultItem.get_display_text","title":"<code>get_display_text() -&gt; str</code>","text":"<p>Get a human-readable display text for this result.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchStrategy","title":"<code>SearchStrategy</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for search strategies.</p> <p>A search strategy defines how to search for relevant information in the memory graph. Different strategies may use vector similarity, keyword matching, graph traversal, etc.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchStrategy.can_handle_query","title":"<code>can_handle_query(query: str, context: SearchContext) -&gt; float</code>  <code>async</code>","text":"<p>Estimate how well this strategy can handle a query.</p> <p>This method helps the search controller select the best strategy. Override to provide better estimates based on query characteristics.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query.</p> required <code>context</code> <code>SearchContext</code> <p>Search context.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Confidence score from 0.0 (cannot handle) to 1.0 (ideal match).</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchStrategy.get_description","title":"<code>get_description() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Get a human-readable description of this strategy.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchStrategy.get_name","title":"<code>get_name() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Get the unique name of this strategy.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchStrategy.get_supported_node_types","title":"<code>get_supported_node_types() -&gt; Optional[List[str]]</code>","text":"<p>Get the list of node types this strategy supports.</p> <p>Returns:</p> Type Description <code>Optional[List[str]]</code> <p>List of supported node types, or None for all types.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchStrategy.search","title":"<code>search(context: SearchContext, client: Any) -&gt; List[SearchResultItem]</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Execute the search strategy.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SearchContext</code> <p>Search context with query and parameters.</p> required <code>client</code> <code>Any</code> <p>Neo4j client for executing queries.</p> required <p>Returns:</p> Type Description <code>List[SearchResultItem]</code> <p>List of search result items, ordered by relevance.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.SearchStrategy.supports_node_type","title":"<code>supports_node_type(node_type: str) -&gt; bool</code>","text":"<p>Check if this strategy supports a particular node type.</p> <p>Override in subclasses to restrict to specific node types.</p> <p>Parameters:</p> Name Type Description Default <code>node_type</code> <code>str</code> <p>Node label to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this strategy can search this node type.</p>"},{"location":"generated/api/memory/#aigise.memory.search.search_controller.get_memory_settings","title":"<code>get_memory_settings() -&gt; MemorySettings</code>","text":"<p>Get the global memory settings instance.</p> <p>Returns:</p> Name Type Description <code>MemorySettings</code> <code>MemorySettings</code> <p>The singleton settings instance.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools","title":"<code>aigise.memory.tools.memory_search_tools</code>","text":"<p>Memory search tools for agents.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools._search_controller","title":"<code>_search_controller: Optional[MemorySearchController] = None</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.MemorySearchController","title":"<code>MemorySearchController</code>","text":"<p>Controller for orchestrating memory search operations.</p> <p>This controller: 1. Selects appropriate search strategies (LLM-driven or heuristic) 2. Executes searches with multi-round refinement 3. Evaluates result sufficiency 4. Combines results from multiple strategies if needed</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.MemorySearchController.__init__","title":"<code>__init__(domain_config: Optional['DomainConfig'] = None, max_iterations: int = 3, sufficiency_threshold: int = 1, use_llm_selection: bool = True)</code>","text":"<p>Initialize the search controller.</p> <p>Parameters:</p> Name Type Description Default <code>domain_config</code> <code>Optional['DomainConfig']</code> <p>Domain configuration defining available strategies.</p> <code>None</code> <code>max_iterations</code> <code>int</code> <p>Maximum number of refinement iterations.</p> <code>3</code> <code>sufficiency_threshold</code> <code>int</code> <p>Minimum results needed to consider sufficient.</p> <code>1</code> <code>use_llm_selection</code> <code>bool</code> <p>Whether to use LLM for strategy selection.</p> <code>True</code>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.MemorySearchController.add_strategy","title":"<code>add_strategy(name: str, strategy: SearchStrategy) -&gt; None</code>","text":"<p>Add a custom search strategy.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.MemorySearchController.get_available_strategies","title":"<code>get_available_strategies() -&gt; List[str]</code>","text":"<p>Get names of available strategies.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.MemorySearchController.search","title":"<code>search(query: str, node_types: Optional[List[str]] = None, client: Any = None, max_results: int = 10, min_score: float = 0.0, metadata: Optional[Dict[str, Any]] = None) -&gt; SearchResult</code>  <code>async</code>","text":"<p>Execute a memory search.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query.</p> required <code>node_types</code> <code>Optional[List[str]]</code> <p>Optional list of node types to search.</p> <code>None</code> <code>client</code> <code>Any</code> <p>Neo4j client for executing queries.</p> <code>None</code> <code>max_results</code> <code>int</code> <p>Maximum results to return.</p> <code>10</code> <code>min_score</code> <code>float</code> <p>Minimum score threshold.</p> <code>0.0</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional search context.</p> <code>None</code> <p>Returns:</p> Type Description <code>SearchResult</code> <p>SearchResult with found items and metadata.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools._get_search_controller","title":"<code>_get_search_controller() -&gt; MemorySearchController</code>","text":"<p>Get or create the search controller singleton.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.get_entity_by_id","title":"<code>get_entity_by_id(node_label: str, node_key: Dict[str, Any], *, include_relationships: bool = False, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Get a specific entity from memory by its identifier.</p> <p>Parameters:</p> Name Type Description Default <code>node_label</code> <code>str</code> <p>Label of the node (e.g., \"Question\", \"Answer\").</p> required <code>node_key</code> <code>Dict[str, Any]</code> <p>Properties to identify the node (e.g., {\"answer_id\": \"...\"}).</p> required <code>include_relationships</code> <code>bool</code> <p>Whether to include connected entities.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if query completed</li> </ul> <code>Dict[str, Any]</code> <ul> <li>found: True if the entity exists</li> </ul> <code>Dict[str, Any]</code> <ul> <li>entity: The entity properties (if found)</li> </ul> <code>Dict[str, Any]</code> <ul> <li>relationships: Related entities (if include_relationships=True)</li> </ul>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.get_merged_domain","title":"<code>get_merged_domain(*domain_names: str) -&gt; DomainConfig</code>","text":"<p>Get a merged domain from multiple registered domains.</p> <p>Parameters:</p> Name Type Description Default <code>*domain_names</code> <code>str</code> <p>Names of domains to merge.</p> <code>()</code> <p>Returns:</p> Type Description <code>DomainConfig</code> <p>Merged domain configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any domain name is not found.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.get_related_entities","title":"<code>get_related_entities(node_label: str, node_key: Dict[str, Any], *, relationship_types: Optional[List[str]] = None, direction: str = 'both', max_results: int = 10, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Get entities related to a specific node in the memory graph.</p> <p>Use this to explore connections between cached knowledge, such as finding all topics related to a question or all content that references a specific topic.</p> <p>Parameters:</p> Name Type Description Default <code>node_label</code> <code>str</code> <p>Label of the node to find relations for (e.g., \"Topic\").</p> required <code>node_key</code> <code>Dict[str, Any]</code> <p>Properties to identify the node (e.g., {\"name\": \"authentication\"}).</p> required <code>relationship_types</code> <code>Optional[List[str]]</code> <p>Optional list of relationship types to follow.                Options: \"ABOUT\", \"HAS_ANSWER\", \"HAS_TOPIC\", \"RELATED_TO\", \"MENTIONS\".</p> <code>None</code> <code>direction</code> <code>str</code> <p>Direction to traverse relationships:       - \"outgoing\": source -&gt; target (what this node points to)       - \"incoming\": source &lt;- target (what points to this node)       - \"both\": both directions (default)</p> <code>'both'</code> <code>max_results</code> <code>int</code> <p>Maximum number of results. Default is 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if query completed</li> </ul> <code>Dict[str, Any]</code> <ul> <li>source_found: True if the source node exists</li> </ul> <code>Dict[str, Any]</code> <ul> <li>relationships: Dict mapping relationship type to list of related nodes</li> </ul> Example"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.get_related_entities--find-all-textquestion-nodes-that-have-the-authentication-topic","title":"Find all Text/Question nodes that have the \"authentication\" topic","text":"<p>get_related_entities(     node_label=\"Topic\",     node_key={\"name\": \"authentication\"},     relationship_types=[\"HAS_TOPIC\"],     direction=\"incoming\",  # Text --[HAS_TOPIC]--&gt; Topic )</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.list_memory_contents","title":"<code>list_memory_contents(*, node_types: Optional[List[str]] = None, limit: int = 20, offset: int = 0, order_by: str = 'created_at', tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>List contents of the memory graph by node type.</p> <p>Use this to browse what's in memory without a specific search query. Useful for exploring available cached knowledge.</p> <p>Parameters:</p> Name Type Description Default <code>node_types</code> <code>Optional[List[str]]</code> <p>Node types to list. Defaults to [\"Question\", \"Topic\"].</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum items per type. Default is 20.</p> <code>20</code> <code>offset</code> <code>int</code> <p>Number of items to skip (for pagination). Default is 0.</p> <code>0</code> <code>order_by</code> <code>str</code> <p>Property to order by. Default is \"created_at\".</p> <code>'created_at'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if query completed</li> </ul> <code>Dict[str, Any]</code> <ul> <li>contents: Dict mapping node type to list of items</li> </ul> <code>Dict[str, Any]</code> <ul> <li>totals: Dict mapping node type to total count</li> </ul>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.requires_sandbox","title":"<code>requires_sandbox(*sandbox_types: str) -&gt; Callable[[F], F]</code>","text":"<p>Universal decorator for declaring sandbox dependencies.</p> <p>This decorator works for both: - Tool functions: Only marks the function with metadata - Toolset factories: Marks function AND injects metadata into returned instance</p> <p>The decorator is purely declarative - it does not create or fetch sandboxes. It only adds <code>__sandbox_requirements__</code> metadata for static analysis via <code>collect_sandbox_dependencies()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*sandbox_types</code> <code>str</code> <p>Variable number of sandbox type names that the tool or toolset depends on (e.g., \"main\", \"gdb_mcp\", \"neo4j\").</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>A decorator function that adds sandbox_requirements metadata.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.safe_tool_execution","title":"<code>safe_tool_execution(func: F) -&gt; F</code>","text":"<p>Decorator to wrap tool functions with error handling.</p> <p>Catches all exceptions and returns a formatted error message with backtrace. Works for both sync and async functions.</p> <p>Returns:</p> Type Description <code>F</code> <p>dict with \"error\" key containing failure message and backtrace</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_search_tools.search_memory","title":"<code>search_memory(query: str, *, node_types: Optional[List[str]] = None, max_results: int = 5, min_score: float = 0.5, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Search the memory graph for relevant cached knowledge.</p> <p>Use this tool to find cached Q&amp;A pairs, topics, or code entities that are semantically similar to your query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query - describe what you're looking for.</p> required <code>node_types</code> <code>Optional[List[str]]</code> <p>Optional list of node types to search. Defaults to        [\"Question\", \"Topic\"]. Other options: \"Answer\", \"Function\",        \"Class\", \"File\".</p> <code>None</code> <code>max_results</code> <code>int</code> <p>Maximum number of results to return. Default is 5.</p> <code>5</code> <code>min_score</code> <code>float</code> <p>Minimum similarity score (0-1). Default is 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if search completed</li> </ul> <code>Dict[str, Any]</code> <ul> <li>found: True if any results were found</li> </ul> <code>Dict[str, Any]</code> <ul> <li>results: List of matching items with scores</li> </ul> <code>Dict[str, Any]</code> <ul> <li>best_match: The highest scoring result (if any)</li> </ul> <code>Dict[str, Any]</code> <ul> <li>strategy_used: Which search strategy found results</li> </ul>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools","title":"<code>aigise.memory.tools.memory_update_tools</code>","text":"<p>Memory update tools for agents.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools._update_controller","title":"<code>_update_controller: Optional[MemoryUpdateController] = None</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations","title":"<code>GraphOperations</code>","text":"<p>Executes graph operations for adding, updating, and deleting nodes/relationships.</p> <p>This class handles: - Creating new nodes with proper MERGE handling - Updating existing nodes - Creating relationships between nodes - Ensuring indexes exist</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations.__init__","title":"<code>__init__(domain_config: Optional['DomainConfig'] = None)</code>","text":"<p>Initialize graph operations.</p> <p>Parameters:</p> Name Type Description Default <code>domain_config</code> <code>Optional['DomainConfig']</code> <p>Domain configuration for node/relationship schemas.</p> <code>None</code>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations.add_entities_batch","title":"<code>add_entities_batch(entities: List[ExtractedEntity], client: Any, aigise_session_id: Optional[str] = None) -&gt; List[OperationResult]</code>  <code>async</code>","text":"<p>Add multiple entities to the graph.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>List[ExtractedEntity]</code> <p>Entities to add.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <code>aigise_session_id</code> <code>Optional[str]</code> <p>Optional session ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[OperationResult]</code> <p>List of operation results.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations.add_entity","title":"<code>add_entity(entity: ExtractedEntity, client: Any, aigise_session_id: Optional[str] = None) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Add an entity to the graph.</p> <p>Uses MERGE to avoid duplicates based on unique keys.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>ExtractedEntity</code> <p>Entity to add.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <code>aigise_session_id</code> <code>Optional[str]</code> <p>Optional session ID for tracking.</p> <code>None</code> <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations.add_relationship","title":"<code>add_relationship(relationship: DiscoveredRelationship, client: Any) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Add a relationship to the graph.</p> <p>Parameters:</p> Name Type Description Default <code>relationship</code> <code>DiscoveredRelationship</code> <p>Relationship to add.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations.add_relationships_batch","title":"<code>add_relationships_batch(relationships: List[DiscoveredRelationship], client: Any) -&gt; List[OperationResult]</code>  <code>async</code>","text":"<p>Add multiple relationships to the graph.</p> <p>Parameters:</p> Name Type Description Default <code>relationships</code> <code>List[DiscoveredRelationship]</code> <p>Relationships to add.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>List[OperationResult]</code> <p>List of operation results.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations.delete_entity","title":"<code>delete_entity(label: str, match_key: Dict[str, Any], client: Any) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Delete a node from the graph.</p> <p>Uses DETACH DELETE to remove the node and all its relationships.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Node label (e.g., \"Question\", \"Topic\").</p> required <code>match_key</code> <code>Dict[str, Any]</code> <p>Properties to identify the node to delete.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations.delete_relationship","title":"<code>delete_relationship(rel_type: str, source_label: str, source_key: Dict[str, Any], target_label: str, target_key: Dict[str, Any], client: Any) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Delete a relationship from the graph.</p> <p>Parameters:</p> Name Type Description Default <code>rel_type</code> <code>str</code> <p>Type of relationship to delete.</p> required <code>source_label</code> <code>str</code> <p>Label of source node.</p> required <code>source_key</code> <code>Dict[str, Any]</code> <p>Properties to identify source node.</p> required <code>target_label</code> <code>str</code> <p>Label of target node.</p> required <code>target_key</code> <code>Dict[str, Any]</code> <p>Properties to identify target node.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.GraphOperations.ensure_indexes","title":"<code>ensure_indexes(client: Any) -&gt; bool</code>  <code>async</code>","text":"<p>Ensure required indexes exist.</p> <p>Creates both regular and vector indexes for memory nodes.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if indexes were created/verified successfully.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.MemoryUpdateController","title":"<code>MemoryUpdateController</code>","text":"<p>Controller for orchestrating memory update operations.</p> <p>This controller: 1. Extracts entities from content (using EntityExtractor) 2. Discovers relationships between entities (using RelationshipDiscoverer) 3. Decides operation type for each entity (using LLMOperationDecider) 4. Executes graph operations (using GraphOperations)</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.MemoryUpdateController.__init__","title":"<code>__init__(domain_config: Optional['DomainConfig'] = None, use_llm_extraction: bool = True, generate_embeddings: bool = True, similarity_threshold: float = 0.7, use_llm_decision: bool = False)</code>","text":"<p>Initialize the update controller.</p> <p>Parameters:</p> Name Type Description Default <code>domain_config</code> <code>Optional['DomainConfig']</code> <p>Domain configuration defining entity types.</p> <code>None</code> <code>use_llm_extraction</code> <code>bool</code> <p>Whether to use LLM for semantic extraction.</p> <code>True</code> <code>generate_embeddings</code> <code>bool</code> <p>Whether to generate embeddings for entities.</p> <code>True</code> <code>similarity_threshold</code> <code>float</code> <p>Threshold for similarity-based relationships.</p> <code>0.7</code> <code>use_llm_decision</code> <code>bool</code> <p>Whether to use LLM for operation type decisions.</p> <code>False</code>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.MemoryUpdateController.delete_entity","title":"<code>delete_entity(label: str, match_key: Dict[str, Any], client: Any) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Delete an entity from the memory graph.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Node label (e.g., \"Question\", \"Topic\").</p> required <code>match_key</code> <code>Dict[str, Any]</code> <p>Properties to identify the node.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.MemoryUpdateController.delete_relationship","title":"<code>delete_relationship(rel_type: str, source_label: str, source_key: Dict[str, Any], target_label: str, target_key: Dict[str, Any], client: Any) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Delete a relationship from the memory graph.</p> <p>Parameters:</p> Name Type Description Default <code>rel_type</code> <code>str</code> <p>Relationship type.</p> required <code>source_label</code> <code>str</code> <p>Label of source node.</p> required <code>source_key</code> <code>Dict[str, Any]</code> <p>Properties to identify source node.</p> required <code>target_label</code> <code>str</code> <p>Label of target node.</p> required <code>target_key</code> <code>Dict[str, Any]</code> <p>Properties to identify target node.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.MemoryUpdateController.link_entities","title":"<code>link_entities(source_label: str, source_key: Dict[str, Any], target_label: str, target_key: Dict[str, Any], relationship_type: str, client: Any, properties: Optional[Dict[str, Any]] = None) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Create a relationship between two existing entities.</p> <p>Parameters:</p> Name Type Description Default <code>source_label</code> <code>str</code> <p>Label of source node.</p> required <code>source_key</code> <code>Dict[str, Any]</code> <p>Properties to identify source node.</p> required <code>target_label</code> <code>str</code> <p>Label of target node.</p> required <code>target_key</code> <code>Dict[str, Any]</code> <p>Properties to identify target node.</p> required <code>relationship_type</code> <code>str</code> <p>Type of relationship to create.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <code>properties</code> <code>Optional[Dict[str, Any]]</code> <p>Optional relationship properties.</p> <code>None</code> <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult for the relationship creation.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.MemoryUpdateController.store_knowledge","title":"<code>store_knowledge(content: str, content_type: str = 'text', client: Any = None, aigise_session_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -&gt; UpdateResult</code>  <code>async</code>","text":"<p>Store knowledge in the memory graph.</p> <p>Generic method for storing any type of content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Content to store.</p> required <code>content_type</code> <code>str</code> <p>Type of content ('text', 'code', 'question', 'answer').</p> <code>'text'</code> <code>client</code> <code>Any</code> <p>Neo4j client.</p> <code>None</code> <code>aigise_session_id</code> <code>Optional[str]</code> <p>Optional session ID.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional metadata.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>UpdateResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.MemoryUpdateController.store_knowledge_with_decision","title":"<code>store_knowledge_with_decision(content: str, content_type: str = 'text', client: Any = None, aigise_session_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -&gt; UpdateResult</code>  <code>async</code>","text":"<p>Store knowledge using LLM to decide operation type for each entity.</p> <p>This method uses the LLMOperationDecider to intelligently decide whether to ADD, UPDATE, DELETE, or skip each extracted entity based on what already exists in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Content to store.</p> required <code>content_type</code> <code>str</code> <p>Type of content.</p> <code>'text'</code> <code>client</code> <code>Any</code> <p>Neo4j client.</p> <code>None</code> <code>aigise_session_id</code> <code>Optional[str]</code> <p>Optional session ID.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional metadata.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>UpdateResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.MemoryUpdateController.store_qa_pair","title":"<code>store_qa_pair(question: str, answer: str, answering_agent: str, answering_model: str, client: Any, aigise_session_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -&gt; UpdateResult</code>  <code>async</code>","text":"<p>Store a question-answer pair in the memory graph.</p> <p>This is the main entry point for storing Q&amp;A knowledge. It extracts entities, discovers relationships, and persists to Neo4j.</p> <p>Parameters:</p> Name Type Description Default <code>question</code> <code>str</code> <p>The question text.</p> required <code>answer</code> <code>str</code> <p>The answer text.</p> required <code>answering_agent</code> <code>str</code> <p>Name of the agent that generated the answer.</p> required <code>answering_model</code> <code>str</code> <p>Model used to generate the answer.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <code>aigise_session_id</code> <code>Optional[str]</code> <p>Optional session ID for tracking.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional metadata to store.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>UpdateResult with operation details.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools._get_update_controller","title":"<code>_get_update_controller() -&gt; MemoryUpdateController</code>","text":"<p>Get or create the update controller singleton.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.cache_qa_pair","title":"<code>cache_qa_pair(question: str, answer: str, answering_agent: str, answering_model: str, *, metadata: Optional[Dict[str, Any]] = None, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Cache a question-answer pair in the memory graph.</p> <p>Use this tool AFTER successfully answering a question to store it for future retrieval. This enables the agent to quickly answer similar questions in the future.</p> <p>The system automatically: - Generates embeddings for similarity search - Extracts topics and code references - Creates relationships to related entities - Finds connections to existing cached questions</p> <p>Parameters:</p> Name Type Description Default <code>question</code> <code>str</code> <p>The question text that was asked.</p> required <code>answer</code> <code>str</code> <p>The answer text that was generated.</p> required <code>answering_agent</code> <code>str</code> <p>Name of the agent that generated the answer.</p> required <code>answering_model</code> <code>str</code> <p>Model identifier used to generate the answer.</p> required <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional additional metadata to store.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if caching succeeded</li> </ul> <code>Dict[str, Any]</code> <ul> <li>question_hash: Hash of the question for lookup</li> </ul> <code>Dict[str, Any]</code> <ul> <li>answer_id: Unique ID of the stored answer</li> </ul> <code>Dict[str, Any]</code> <ul> <li>entities_added: Number of entities created</li> </ul> <code>Dict[str, Any]</code> <ul> <li>relationships_added: Number of relationships created</li> </ul> <code>Dict[str, Any]</code> <ul> <li>topics_identified: Topics extracted from the Q&amp;A</li> </ul> <code>Dict[str, Any]</code> <ul> <li>related_questions: Number of similar questions found</li> </ul>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.delete_from_memory","title":"<code>delete_from_memory(node_label: str, node_key: Dict[str, Any], *, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Delete an entity from the memory graph.</p> <p>Use this to remove outdated or incorrect cached knowledge. This will also remove all relationships connected to the node.</p> <p>Parameters:</p> Name Type Description Default <code>node_label</code> <code>str</code> <p>Label of the node to delete. Options:        - \"Question\": A cached question        - \"Answer\": A cached answer        - \"Topic\": A topic/concept        - \"Function\": A function entity        - \"Class\": A class entity        - \"File\": A file entity</p> required <code>node_key</code> <code>Dict[str, Any]</code> <p>Properties to identify the node. Examples:      - {\"question_hash\": \"...\"} for Question      - {\"name\": \"...\"} for Topic      - {\"name\": \"...\", \"file_path\": \"...\"} for Function/Class      - {\"path\": \"...\"} for File</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if entity was deleted</li> </ul> <code>Dict[str, Any]</code> <ul> <li>message: Description of what was deleted</li> </ul> <code>Dict[str, Any]</code> <ul> <li>error: Error message if deletion failed</li> </ul>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.delete_relationship_from_memory","title":"<code>delete_relationship_from_memory(relationship_type: str, source_label: str, source_key: Dict[str, Any], target_label: str, target_key: Dict[str, Any], *, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Delete a relationship from the memory graph.</p> <p>Use this to remove incorrect or outdated connections between entities.</p> <p>Parameters:</p> Name Type Description Default <code>relationship_type</code> <code>str</code> <p>Type of relationship to delete. Options:               - \"ABOUT\": What something is about               - \"HAS_ANSWER\": Question to answer link               - \"HAS_TOPIC\": Content to topic link               - \"RELATED_TO\": General relation               - \"MENTIONS\": Content mentions code entity</p> required <code>source_label</code> <code>str</code> <p>Label of the source node.</p> required <code>source_key</code> <code>Dict[str, Any]</code> <p>Properties to identify the source node.</p> required <code>target_label</code> <code>str</code> <p>Label of the target node.</p> required <code>target_key</code> <code>Dict[str, Any]</code> <p>Properties to identify the target node.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if relationship was deleted</li> </ul> <code>Dict[str, Any]</code> <ul> <li>message: Description of what was deleted</li> </ul>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.ensure_memory_indexes","title":"<code>ensure_memory_indexes(*, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Ensure memory graph indexes are created.</p> <p>This tool creates the necessary indexes for efficient querying: - Regular indexes for exact match lookups - Vector indexes for similarity search</p> <p>You typically don't need to call this manually as it's called automatically during the first cache operation.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if indexes were created/verified</li> </ul> <code>Dict[str, Any]</code> <ul> <li>message: Description of indexes created</li> </ul>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.get_merged_domain","title":"<code>get_merged_domain(*domain_names: str) -&gt; DomainConfig</code>","text":"<p>Get a merged domain from multiple registered domains.</p> <p>Parameters:</p> Name Type Description Default <code>*domain_names</code> <code>str</code> <p>Names of domains to merge.</p> <code>()</code> <p>Returns:</p> Type Description <code>DomainConfig</code> <p>Merged domain configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any domain name is not found.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.link_entities","title":"<code>link_entities(source_label: str, source_key: Dict[str, Any], target_label: str, target_key: Dict[str, Any], relationship_type: str, *, properties: Optional[Dict[str, Any]] = None, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Create a relationship between two entities in the memory graph.</p> <p>Use this to manually connect related knowledge that the automatic extraction might have missed.</p> <p>Parameters:</p> Name Type Description Default <code>source_label</code> <code>str</code> <p>Label of the source node (e.g., \"Question\").</p> required <code>source_key</code> <code>Dict[str, Any]</code> <p>Properties to identify source (e.g., {\"question_hash\": \"...\"}).</p> required <code>target_label</code> <code>str</code> <p>Label of the target node (e.g., \"Topic\").</p> required <code>target_key</code> <code>Dict[str, Any]</code> <p>Properties to identify target (e.g., {\"name\": \"...\"}).</p> required <code>relationship_type</code> <code>str</code> <p>Type of relationship. Options:               - \"ABOUT\": What something is about               - \"HAS_ANSWER\": Question to answer link               - \"HAS_TOPIC\": Content to topic link               - \"RELATED_TO\": General relation               - \"MENTIONS\": Content mentions code entity</p> required <code>properties</code> <code>Optional[Dict[str, Any]]</code> <p>Optional properties for the relationship.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if relationship was created</li> </ul> <code>Dict[str, Any]</code> <ul> <li>relationship_type: The type of relationship created</li> </ul> <code>Dict[str, Any]</code> <ul> <li>message: Description of what was linked</li> </ul>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.requires_sandbox","title":"<code>requires_sandbox(*sandbox_types: str) -&gt; Callable[[F], F]</code>","text":"<p>Universal decorator for declaring sandbox dependencies.</p> <p>This decorator works for both: - Tool functions: Only marks the function with metadata - Toolset factories: Marks function AND injects metadata into returned instance</p> <p>The decorator is purely declarative - it does not create or fetch sandboxes. It only adds <code>__sandbox_requirements__</code> metadata for static analysis via <code>collect_sandbox_dependencies()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*sandbox_types</code> <code>str</code> <p>Variable number of sandbox type names that the tool or toolset depends on (e.g., \"main\", \"gdb_mcp\", \"neo4j\").</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>A decorator function that adds sandbox_requirements metadata.</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.safe_tool_execution","title":"<code>safe_tool_execution(func: F) -&gt; F</code>","text":"<p>Decorator to wrap tool functions with error handling.</p> <p>Catches all exceptions and returns a formatted error message with backtrace. Works for both sync and async functions.</p> <p>Returns:</p> Type Description <code>F</code> <p>dict with \"error\" key containing failure message and backtrace</p>"},{"location":"generated/api/memory/#aigise.memory.tools.memory_update_tools.store_knowledge","title":"<code>store_knowledge(content: str, content_type: str = 'text', *, metadata: Optional[Dict[str, Any]] = None, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Store knowledge in the memory graph.</p> <p>Use this tool to persist any kind of knowledge for future retrieval. The system will automatically extract entities, topics, and relationships from the content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content to store.</p> required <code>content_type</code> <code>str</code> <p>Type of content. Options:          - \"text\": Generic text content          - \"code\": Code content (will extract functions/classes)          - \"question\": A question to cache          - \"answer\": An answer to cache</p> <code>'text'</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional additional metadata to store.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with:</p> <code>Dict[str, Any]</code> <ul> <li>success: True if storage succeeded</li> </ul> <code>Dict[str, Any]</code> <ul> <li>entities_added: Number of entities created</li> </ul> <code>Dict[str, Any]</code> <ul> <li>entities_updated: Number of existing entities updated</li> </ul> <code>Dict[str, Any]</code> <ul> <li>relationships_added: Number of relationships created</li> </ul> <code>Dict[str, Any]</code> <ul> <li>message: Summary of what was stored</li> </ul>"},{"location":"generated/api/plugins/","title":"Plugins","text":""},{"location":"generated/api/plugins/#aigise.plugins.build_verifier_plugin","title":"<code>aigise.plugins.build_verifier_plugin</code>","text":"<p>Plugin to verify code builds before allowing finish_task to complete.</p> <p>For known project types (Go, Python), automatically runs build verification. For unknown project types, prompts agent on first attempt; allows on second.</p>"},{"location":"generated/api/plugins/#aigise.plugins.build_verifier_plugin.STATE_KEY_FINISH_TASK_ATTEMPTS","title":"<code>STATE_KEY_FINISH_TASK_ATTEMPTS = '_build_verifier_finish_attempts'</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/plugins/#aigise.plugins.build_verifier_plugin.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/plugins/#aigise.plugins.build_verifier_plugin.BuildVerifierPlugin","title":"<code>BuildVerifierPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Plugin to verify build passes before allowing task completion.</p>"},{"location":"generated/api/plugins/#aigise.plugins.build_verifier_plugin.BuildVerifierPlugin.after_tool_callback","title":"<code>after_tool_callback(*, tool: BaseTool, tool_args: dict, tool_context: ToolContext, result: dict) -&gt; Optional[Dict[str, Any]]</code>  <code>async</code>","text":"<p>Intercept finish_task and verify build passes first.</p>"},{"location":"generated/api/plugins/#aigise.plugins.validator_plugin","title":"<code>aigise.plugins.validator_plugin</code>","text":"<p>Plugin to detect and warn about common test execution pitfalls.</p> <p>This plugin is designed with high precision in mind: - Prefers false negatives over false positives - Only warns when patterns are unambiguous - Uses strict pattern matching</p>"},{"location":"generated/api/plugins/#aigise.plugins.validator_plugin.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/plugins/#aigise.plugins.validator_plugin.ValidatorPlugin","title":"<code>ValidatorPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Plugin to validate test commands and provide actionable warnings.</p>"},{"location":"generated/api/plugins/#aigise.plugins.validator_plugin.ValidatorPlugin.after_tool_callback","title":"<code>after_tool_callback(*, tool: BaseTool, tool_args: dict, tool_context: ToolContext, result: dict) -&gt; Optional[Dict[str, Any]]</code>  <code>async</code>","text":"<p>Analyze test command results and add warnings if issues detected.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin","title":"<code>aigise.plugins.memory_observer_plugin</code>","text":"<p>Memory observer plugin for async tool result storage.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryObserverPlugin","title":"<code>MemoryObserverPlugin</code>","text":"<p>               Bases: <code>BasePlugin</code></p> <p>Plugin that observes tool results and stores valuable information in memory.</p> <p>This plugin monitors each tool execution's result and uses an LLM-based StorageDecider to determine whether the result contains valuable information worth persisting to the memory graph. Storage happens asynchronously to avoid blocking agent execution.</p> Example configuration in TOML <p>[plugins] enabled = [\"memory_observer_plugin\"]</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryObserverPlugin.memory_controller","title":"<code>memory_controller: MemoryUpdateController</code>  <code>property</code>","text":"<p>Lazily initialize the memory controller.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryObserverPlugin.__init__","title":"<code>__init__(enable_llm_decision: bool = True, fire_and_forget: bool = True, decider_model: Optional[str] = None) -&gt; None</code>","text":"<p>Initialize the memory observer plugin.</p> <p>Parameters:</p> Name Type Description Default <code>enable_llm_decision</code> <code>bool</code> <p>Whether to use LLM for storage decisions. If False, stores all non-excluded tool results above MIN_RESULT_LENGTH.</p> <code>True</code> <code>fire_and_forget</code> <code>bool</code> <p>Whether to run storage in background without waiting. If True, tool execution is not blocked by storage operations.</p> <code>True</code> <code>decider_model</code> <code>Optional[str]</code> <p>LiteLLM model identifier for the storage decider. If None, reads from [memory].llm_model in config.</p> <code>None</code>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryObserverPlugin.after_tool_callback","title":"<code>after_tool_callback(*, tool: BaseTool, tool_args: dict, tool_context: ToolContext, result: dict) -&gt; None</code>  <code>async</code>","text":"<p>Observe tool results and potentially store valuable information.</p> <p>This callback is invoked after each tool execution. It evaluates the result and, if deemed valuable, stores it in the memory graph.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>BaseTool</code> <p>The tool that was executed.</p> required <code>tool_args</code> <code>dict</code> <p>Arguments passed to the tool.</p> required <code>tool_context</code> <code>ToolContext</code> <p>Tool execution context.</p> required <code>result</code> <code>dict</code> <p>The tool's result dictionary.</p> required"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryObserverPlugin.cleanup","title":"<code>cleanup() -&gt; None</code>  <code>async</code>","text":"<p>Wait for all pending storage tasks to complete.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryUpdateController","title":"<code>MemoryUpdateController</code>","text":"<p>Controller for orchestrating memory update operations.</p> <p>This controller: 1. Extracts entities from content (using EntityExtractor) 2. Discovers relationships between entities (using RelationshipDiscoverer) 3. Decides operation type for each entity (using LLMOperationDecider) 4. Executes graph operations (using GraphOperations)</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryUpdateController.__init__","title":"<code>__init__(domain_config: Optional['DomainConfig'] = None, use_llm_extraction: bool = True, generate_embeddings: bool = True, similarity_threshold: float = 0.7, use_llm_decision: bool = False)</code>","text":"<p>Initialize the update controller.</p> <p>Parameters:</p> Name Type Description Default <code>domain_config</code> <code>Optional['DomainConfig']</code> <p>Domain configuration defining entity types.</p> <code>None</code> <code>use_llm_extraction</code> <code>bool</code> <p>Whether to use LLM for semantic extraction.</p> <code>True</code> <code>generate_embeddings</code> <code>bool</code> <p>Whether to generate embeddings for entities.</p> <code>True</code> <code>similarity_threshold</code> <code>float</code> <p>Threshold for similarity-based relationships.</p> <code>0.7</code> <code>use_llm_decision</code> <code>bool</code> <p>Whether to use LLM for operation type decisions.</p> <code>False</code>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryUpdateController.delete_entity","title":"<code>delete_entity(label: str, match_key: Dict[str, Any], client: Any) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Delete an entity from the memory graph.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>Node label (e.g., \"Question\", \"Topic\").</p> required <code>match_key</code> <code>Dict[str, Any]</code> <p>Properties to identify the node.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult with operation details.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryUpdateController.delete_relationship","title":"<code>delete_relationship(rel_type: str, source_label: str, source_key: Dict[str, Any], target_label: str, target_key: Dict[str, Any], client: Any) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Delete a relationship from the memory graph.</p> <p>Parameters:</p> Name Type Description Default <code>rel_type</code> <code>str</code> <p>Relationship type.</p> required <code>source_label</code> <code>str</code> <p>Label of source node.</p> required <code>source_key</code> <code>Dict[str, Any]</code> <p>Properties to identify source node.</p> required <code>target_label</code> <code>str</code> <p>Label of target node.</p> required <code>target_key</code> <code>Dict[str, Any]</code> <p>Properties to identify target node.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult with operation details.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryUpdateController.link_entities","title":"<code>link_entities(source_label: str, source_key: Dict[str, Any], target_label: str, target_key: Dict[str, Any], relationship_type: str, client: Any, properties: Optional[Dict[str, Any]] = None) -&gt; OperationResult</code>  <code>async</code>","text":"<p>Create a relationship between two existing entities.</p> <p>Parameters:</p> Name Type Description Default <code>source_label</code> <code>str</code> <p>Label of source node.</p> required <code>source_key</code> <code>Dict[str, Any]</code> <p>Properties to identify source node.</p> required <code>target_label</code> <code>str</code> <p>Label of target node.</p> required <code>target_key</code> <code>Dict[str, Any]</code> <p>Properties to identify target node.</p> required <code>relationship_type</code> <code>str</code> <p>Type of relationship to create.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <code>properties</code> <code>Optional[Dict[str, Any]]</code> <p>Optional relationship properties.</p> <code>None</code> <p>Returns:</p> Type Description <code>OperationResult</code> <p>OperationResult for the relationship creation.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryUpdateController.store_knowledge","title":"<code>store_knowledge(content: str, content_type: str = 'text', client: Any = None, aigise_session_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -&gt; UpdateResult</code>  <code>async</code>","text":"<p>Store knowledge in the memory graph.</p> <p>Generic method for storing any type of content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Content to store.</p> required <code>content_type</code> <code>str</code> <p>Type of content ('text', 'code', 'question', 'answer').</p> <code>'text'</code> <code>client</code> <code>Any</code> <p>Neo4j client.</p> <code>None</code> <code>aigise_session_id</code> <code>Optional[str]</code> <p>Optional session ID.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional metadata.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>UpdateResult with operation details.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryUpdateController.store_knowledge_with_decision","title":"<code>store_knowledge_with_decision(content: str, content_type: str = 'text', client: Any = None, aigise_session_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -&gt; UpdateResult</code>  <code>async</code>","text":"<p>Store knowledge using LLM to decide operation type for each entity.</p> <p>This method uses the LLMOperationDecider to intelligently decide whether to ADD, UPDATE, DELETE, or skip each extracted entity based on what already exists in the graph.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Content to store.</p> required <code>content_type</code> <code>str</code> <p>Type of content.</p> <code>'text'</code> <code>client</code> <code>Any</code> <p>Neo4j client.</p> <code>None</code> <code>aigise_session_id</code> <code>Optional[str]</code> <p>Optional session ID.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional metadata.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>UpdateResult with operation details.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.MemoryUpdateController.store_qa_pair","title":"<code>store_qa_pair(question: str, answer: str, answering_agent: str, answering_model: str, client: Any, aigise_session_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -&gt; UpdateResult</code>  <code>async</code>","text":"<p>Store a question-answer pair in the memory graph.</p> <p>This is the main entry point for storing Q&amp;A knowledge. It extracts entities, discovers relationships, and persists to Neo4j.</p> <p>Parameters:</p> Name Type Description Default <code>question</code> <code>str</code> <p>The question text.</p> required <code>answer</code> <code>str</code> <p>The answer text.</p> required <code>answering_agent</code> <code>str</code> <p>Name of the agent that generated the answer.</p> required <code>answering_model</code> <code>str</code> <p>Model used to generate the answer.</p> required <code>client</code> <code>Any</code> <p>Neo4j client.</p> required <code>aigise_session_id</code> <code>Optional[str]</code> <p>Optional session ID for tracking.</p> <code>None</code> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Additional metadata to store.</p> <code>None</code> <p>Returns:</p> Type Description <code>UpdateResult</code> <p>UpdateResult with operation details.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecider","title":"<code>StorageDecider</code>","text":"<p>LLM-based decision maker that evaluates whether tool results should be stored.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecider.__init__","title":"<code>__init__(model_name: str = 'gemini/gemini-2.5-flash-lite', temperature: float = 1.0, max_result_preview: int = 2000)</code>","text":"<p>Initialize the storage decider.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>LiteLLM model identifier for decision making.</p> <code>'gemini/gemini-2.5-flash-lite'</code> <code>temperature</code> <code>float</code> <p>LLM temperature for decisions (lower = more consistent).</p> <code>1.0</code> <code>max_result_preview</code> <code>int</code> <p>Maximum characters of tool result to include in prompt.</p> <code>2000</code>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecider.should_store","title":"<code>should_store(tool_name: str, tool_args: dict, tool_result: Any, full_output_file: Optional[str] = None) -&gt; StorageDecision</code>  <code>async</code>","text":"<p>Decide whether a tool result should be stored in memory.</p> <p>Parameters:</p> Name Type Description Default <code>tool_name</code> <code>str</code> <p>Name of the tool that produced the result.</p> required <code>tool_args</code> <code>dict</code> <p>Arguments passed to the tool.</p> required <code>tool_result</code> <code>Any</code> <p>The result returned by the tool.</p> required <code>full_output_file</code> <code>Optional[str]</code> <p>Path to file containing full output if truncated.</p> <code>None</code> <p>Returns:</p> Type Description <code>StorageDecision</code> <p>StorageDecision indicating whether and how to store the content.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecision","title":"<code>StorageDecision</code>  <code>dataclass</code>","text":"<p>Result of storage decision analysis.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecision.confidence","title":"<code>confidence: float = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Confidence score (0.0 to 1.0) for the decision.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecision.content_type","title":"<code>content_type: str</code>  <code>instance-attribute</code>","text":"<p>Type of content: 'code', 'text', 'finding', 'error', 'search_result', etc.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecision.reason","title":"<code>reason: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Explanation of why the decision was made.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecision.should_store","title":"<code>should_store: bool</code>  <code>instance-attribute</code>","text":"<p>Whether the content should be stored in memory.</p>"},{"location":"generated/api/plugins/#aigise.plugins.memory_observer_plugin.StorageDecision.summary","title":"<code>summary: Optional[str] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional condensed version of the content for storage.</p>"},{"location":"generated/api/sandbox/","title":"Sandbox","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox","title":"<code>aigise.sandbox.base_sandbox</code>","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox","title":"<code>BaseSandbox</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all sandbox implementations.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Cache sandbox states and shared volume content.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict</code> <p>Dictionary mapping sandbox types to sandbox instances</p> required <code>shared_volume_id</code> <code>str</code> <p>Shared volume identifier to backup</p> required <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>task_name</code> <code>str</code> <p>Task name for cache naming</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with cache results including backup paths and cached images</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from local filesystem to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; Exception</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance asynchronously.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Delete shared volumes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.get_work_dir","title":"<code>get_work_dir()</code>  <code>abstractmethod</code>","text":"<p>Get the current working directory in the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances for a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>sandbox_configs</code> <code>dict</code> <p>Dictionary of sandbox_type -&gt; ContainerConfig</p> required <code>shared_volume_id</code> <code>str</code> <p>Optional shared volume to mount to all sandboxes</p> <code>None</code> <code>scripts_volume_id</code> <code>str</code> <p>Optional scripts volume to mount to all sandboxes</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>Optional tools volume to mount to all sandboxes</p> <code>None</code> <p>Returns:     Dictionary mapping sandbox_type to sandbox instance or connection info</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>  <code>abstractmethod</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.BaseSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.ContainerConfig","title":"<code>ContainerConfig</code>  <code>dataclass</code>","text":"<p>Lightweight config for Docker-backed sandboxes.</p> <p>This is an internal convenience type to keep sandbox code tidy and typed. It intentionally mirrors common docker SDK/run options that we may support. Any unsupported fields can be kept in extra for forward-compat.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.base_sandbox.SandboxState","title":"<code>SandboxState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Sandbox initialization states.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory","title":"<code>aigise.sandbox.factory</code>","text":"<p>Sandbox factory for creating typed sandbox instances.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.SANDBOX_BACKENDS","title":"<code>SANDBOX_BACKENDS = {'native': NativeDockerSandbox, 'k8s': K8sSandbox, 'remotedocker': RemoteDockerSandbox, 'local': LocalSandbox}</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.factory.SANDBOX_INITIALIZERS","title":"<code>SANDBOX_INITIALIZERS = {'main': MainInitializer, 'codeql': CodeQLInitializer, 'joern': JoernInitializer, 'fuzz': FuzzInitializer, 'neo4j': Neo4jInitializer, 'coverage': CoverageInitializer, 'debugger': DebuggerInitializer}</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox","title":"<code>BaseSandbox</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all sandbox implementations.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Cache sandbox states and shared volume content.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict</code> <p>Dictionary mapping sandbox types to sandbox instances</p> required <code>shared_volume_id</code> <code>str</code> <p>Shared volume identifier to backup</p> required <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>task_name</code> <code>str</code> <p>Task name for cache naming</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with cache results including backup paths and cached images</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from local filesystem to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; Exception</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance asynchronously.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Delete shared volumes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.get_work_dir","title":"<code>get_work_dir()</code>  <code>abstractmethod</code>","text":"<p>Get the current working directory in the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances for a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>sandbox_configs</code> <code>dict</code> <p>Dictionary of sandbox_type -&gt; ContainerConfig</p> required <code>shared_volume_id</code> <code>str</code> <p>Optional shared volume to mount to all sandboxes</p> <code>None</code> <code>scripts_volume_id</code> <code>str</code> <p>Optional scripts volume to mount to all sandboxes</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>Optional tools volume to mount to all sandboxes</p> <code>None</code> <p>Returns:     Dictionary mapping sandbox_type to sandbox instance or connection info</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>  <code>abstractmethod</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.BaseSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.CodeQLInitializer","title":"<code>CodeQLInitializer</code>","text":"<p>               Bases: <code>SandboxInitializer</code></p> <p>Initializer that initializes CodeQL static analysis capabilities to sandboxes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.CodeQLInitializer.async_initialize","title":"<code>async_initialize(all_sandboxes: dict[str, BaseSandbox]) -&gt; None</code>  <code>async</code>","text":"<p>Initialize sandbox initializer (async version).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.CoverageInitializer","title":"<code>CoverageInitializer</code>","text":"<p>               Bases: <code>SandboxInitializer</code></p> <p>Initializer that initializes coverage capabilities to sandboxes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.CoverageInitializer.async_initialize","title":"<code>async_initialize(all_sandboxes: dict[str, BaseSandbox]) -&gt; None</code>  <code>async</code>","text":"<p>Initialize sandbox initializer (async version).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.DebuggerInitializer","title":"<code>DebuggerInitializer</code>","text":"<p>               Bases: <code>SandboxInitializer</code></p> <p>Initializer for debugger sandboxes to compile debug binaries.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.DebuggerInitializer.async_initialize","title":"<code>async_initialize(all_sandboxes: dict[str, BaseSandbox]) -&gt; None</code>  <code>async</code>","text":"<p>Initialize sandbox initializer (async version).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.FuzzInitializer","title":"<code>FuzzInitializer</code>","text":"<p>               Bases: <code>SandboxInitializer</code></p> <p>Initializer that initializes fuzzing capabilities to sandboxes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.FuzzInitializer.async_initialize","title":"<code>async_initialize(all_sandboxes: dict[str, BaseSandbox]) -&gt; None</code>  <code>async</code>","text":"<p>Initialize sandbox initializer (async version).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.JoernInitializer","title":"<code>JoernInitializer</code>","text":"<p>               Bases: <code>SandboxInitializer</code></p> <p>Initializer that initializes Joern code analysis capabilities to sandboxes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.JoernInitializer.async_initialize","title":"<code>async_initialize(all_sandboxes: dict[str, BaseSandbox]) -&gt; None</code>  <code>async</code>","text":"<p>Initialize sandbox initializer (async version).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.K8sSandbox","title":"<code>K8sSandbox</code>","text":"<p>               Bases: <code>BaseSandbox</code></p> <p>K8s sandbox representing a specific container within a Pod.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.K8sSandbox.__init__","title":"<code>__init__(container_config: ContainerConfig, session_id: str = None, backend_type: str = None, sandbox_type: str = None, pod_name: str = None, container_name: str = None)</code>","text":"<p>Initialize K8sSandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.K8sSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.K8sSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>classmethod</code>","text":"<p>Create and initialize three shared PVCs.</p> <p>Creates three PVCs: 1. Read-only PVC with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write PVC with user data (mapped to /shared) 3. Read-write PVC with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for PVC names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw PVC (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools (built-in + plugins).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_pvc_name, data_pvc_name, tools_pvc_name)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.K8sSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Delete shared PVCs.</p> <p>Parameters:</p> Name Type Description Default <code>scripts_volume_id</code> <code>str</code> <p>ID of the scripts PVC to delete (with or without pvc/ prefix)</p> <code>None</code> <code>data_volume_id</code> <code>str</code> <p>ID of the data PVC to delete (with or without pvc/ prefix)</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>ID of the tools PVC to delete (with or without pvc/ prefix)</p> <code>None</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.K8sSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.K8sSandbox.initialize_all_sandboxes","title":"<code>initialize_all_sandboxes(sandbox_instances: dict, *, continue_on_error: bool = False) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Initialize all sandbox instances concurrently.</p> <p>This should be called after launch_all_sandboxes() and after registering any hooks.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict</code> <p>Dict of sandbox_type -&gt; K8sSandbox instance</p> required <code>continue_on_error</code> <code>bool</code> <p>If True, continue on failures and return a map of sandbox_type -&gt; Exception | None. If False, propagate errors.</p> <code>False</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.K8sSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.LocalSandbox","title":"<code>LocalSandbox</code>","text":"<p>               Bases: <code>BaseSandbox</code></p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.LocalSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.LocalSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.LocalSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.MainInitializer","title":"<code>MainInitializer</code>","text":"<p>               Bases: <code>SandboxInitializer</code></p> <p>Initializer that initializes main sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.MainInitializer.async_initialize","title":"<code>async_initialize(all_sandboxes: dict[str, BaseSandbox]) -&gt; None</code>  <code>async</code>","text":"<p>Initialize sandbox initializer (async version).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox","title":"<code>NativeDockerSandbox</code>","text":"<p>               Bases: <code>BaseSandbox</code></p> <p>Native Docker sandbox implementation using direct Docker API.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.__init__","title":"<code>__init__(container_config: ContainerConfig, session_id: str = None, backend_type: str = None, sandbox_type: str = None)</code>","text":"<p>Initialize NativeDockerSandbox.</p> <p>Parameters:</p> Name Type Description Default <code>container_config</code> <code>ContainerConfig</code> <p>ContainerConfig options controlling container launch (must include image or container_id)</p> required"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>classmethod</code>","text":"<p>Cache Docker containers and shared volume content.</p> <p>This method will: 1. Backup shared volume content to a tar.gz file 2. Commit each running container to a new image</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <p>Session identifier</p> required <code>sandbox_instances</code> <code>dict</code> <p>Dictionary mapping sandbox types to NativeDockerSandbox instances</p> required <code>shared_volume_id</code> <code>str</code> <p>Docker volume name to backup</p> required <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>task_name</code> <code>str</code> <p>Task name for naming cached resources</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with cache results</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.copy_directory_from_container","title":"<code>copy_directory_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.copy_directory_to_container","title":"<code>copy_directory_to_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the host to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>","text":"<p>Copy a single file to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools (built-in + plugins).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; tuple[str, NativeDockerSandbox]</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance without initialization.</p> <p>This method only creates the Docker container and sandbox instance. Call initialize_all_sandboxes() afterwards to initialize.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.create_tar_bytes","title":"<code>create_tar_bytes(file_content: str, arcname: str) -&gt; bytes</code>","text":"<p>Pack the given file content into a tar archive.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.delete_container","title":"<code>delete_container(max_wait: int = 10)</code>","text":"<p>Delete the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Delete shared volumes.</p> <p>Parameters:</p> Name Type Description Default <code>scripts_volume_id</code> <code>str</code> <p>ID of the scripts volume to delete</p> <code>None</code> <code>data_volume_id</code> <code>str</code> <p>ID of the data volume to delete</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>ID of the tools volume to delete</p> <code>None</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>","text":"<p>Extract the content of the specified file from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>","text":"<p>Extract the content of the specified file from the container as bytes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.get_file_content","title":"<code>get_file_content(filepath: str) -&gt; str</code>","text":"<p>Retrieve the content of a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.get_function_content","title":"<code>get_function_content(key: str, lang: str = 'c', line_in_func: int = -1) -&gt; tuple[str, int, int]</code>","text":"<p>Retrieve the content of a specific function from a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.get_work_dir","title":"<code>get_work_dir() -&gt; str</code>","text":"<p>Get the working directory of the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.initialize_all_sandboxes","title":"<code>initialize_all_sandboxes(sandbox_instances: dict[str, BaseSandbox], *, continue_on_error: bool = False) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Initialize all sandbox instances concurrently.</p> <p>This should be called after launch_all_sandboxes() and after registering any hooks.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict[str, BaseSandbox]</code> <p>Dict of sandbox_type -&gt; NativeDockerSandbox instance</p> required <code>continue_on_error</code> <code>bool</code> <p>If True, continue initializing other sandboxes when one fails, and return a map of sandbox_type -&gt; Exception | None instead of raising. If False, propagate errors.</p> <code>False</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances as separate Docker containers.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>sandbox_configs</code> <code>dict</code> <p>Dictionary of sandbox_type -&gt; ContainerConfig</p> required <code>shared_volume_id</code> <code>str</code> <p>Optional shared volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <code>scripts_volume_id</code> <code>str</code> <p>Optional scripts volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>Optional tools volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary mapping sandbox_type to NativeDockerSandbox instance</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.patch_file_func","title":"<code>patch_file_func(files_func_to_content: dict[str, str], lang: str = 'c')</code>","text":"<p>Replace a function in a file inside the container with new content.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.patch_search_replace","title":"<code>patch_search_replace(file: str, search: str, replace: str)</code>","text":"<p>Replace all occurrences of 'search' with 'replace' in the specified file.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.NativeDockerSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.Neo4jInitializer","title":"<code>Neo4jInitializer</code>","text":"<p>               Bases: <code>SandboxInitializer</code></p> <p>Initializer that initializes Neo4j code analysis capabilities to sandboxes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.Neo4jInitializer.async_initialize","title":"<code>async_initialize(all_sandboxes: dict[str, BaseSandbox]) -&gt; None</code>  <code>async</code>","text":"<p>Initialize sandbox initializer (async version).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox","title":"<code>RemoteDockerSandbox</code>","text":"<p>               Bases: <code>NativeDockerSandbox</code></p> <p>Remote Docker sandbox implementation using Docker API over SSH/TCP.</p> <p>This backend extends NativeDockerSandbox to support remote Docker daemons, enabling execution on remote machines while maintaining the same interface.</p> <p>Key differences from NativeDockerSandbox: - Docker client connects to remote daemon (requires docker_host config) - Volume population uses put_archive instead of bind mounts - Network configuration uses remote host IP instead of loopback - Image operations use Docker SDK instead of subprocess - All operations performed via Docker API (no local dependencies)</p> Configuration <p>[sandbox] backend = \"remotedocker\" docker_host = \"ssh://user@remote-host\"  # or tcp://host:2376 docker_remote_host = \"192.168.1.100\"    # optional, auto-parsed if not set</p> <p>Environment Variables (fallback):     DOCKER_HOST: Remote Docker daemon URL     DOCKER_REMOTE_HOST: Remote host IP for service connections     DOCKER_TLS_CERTDIR: TLS certificate directory for TCP</p> Usage <p>export DOCKER_HOST=\"ssh://user@gpu-server\" python -m aigise.evaluations ...</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.__init__","title":"<code>__init__(container_config, session_id: str = None, backend_type: str = None, sandbox_type: str = None)</code>","text":"<p>Initialize remote Docker sandbox.</p> <p>Overrides parent to use remote Docker client instead of docker.from_env().</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.build_image_from_dockerfile","title":"<code>build_image_from_dockerfile(config) -&gt; Optional[DockerBuildResult]</code>  <code>classmethod</code>","text":"<p>Build image using Docker SDK (remote-compatible).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>classmethod</code>","text":"<p>Cache containers on remote Docker.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.can_pull_image","title":"<code>can_pull_image(image_name: str) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Pull image on remote Docker daemon.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.copy_directory_from_container","title":"<code>copy_directory_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.copy_directory_to_container","title":"<code>copy_directory_to_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the host to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>","text":"<p>Copy a single file to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools (built-in + plugins).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; tuple[str, NativeDockerSandbox]</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance without initialization.</p> <p>This method only creates the Docker container and sandbox instance. Call initialize_all_sandboxes() afterwards to initialize.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.create_tar_bytes","title":"<code>create_tar_bytes(file_content: str, arcname: str) -&gt; bytes</code>","text":"<p>Pack the given file content into a tar archive.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.delete_container","title":"<code>delete_container(max_wait: int = 10)</code>","text":"<p>Delete the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Delete shared volumes using Docker API.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.ensure_docker_image","title":"<code>ensure_docker_image(config) -&gt; tuple[bool, Optional[str]]</code>  <code>classmethod</code>","text":"<p>Ensure image is available on remote daemon.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>","text":"<p>Extract the content of the specified file from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>","text":"<p>Extract the content of the specified file from the container as bytes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.get_file_content","title":"<code>get_file_content(filepath: str) -&gt; str</code>","text":"<p>Retrieve the content of a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.get_function_content","title":"<code>get_function_content(key: str, lang: str = 'c', line_in_func: int = -1) -&gt; tuple[str, int, int]</code>","text":"<p>Retrieve the content of a specific function from a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.get_work_dir","title":"<code>get_work_dir() -&gt; str</code>","text":"<p>Get the working directory of the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.image_exists_locally","title":"<code>image_exists_locally(image_name: str) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if image exists on remote Docker daemon.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.initialize_all_sandboxes","title":"<code>initialize_all_sandboxes(sandbox_instances: dict[str, BaseSandbox], *, continue_on_error: bool = False) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Initialize all sandbox instances concurrently.</p> <p>This should be called after launch_all_sandboxes() and after registering any hooks.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict[str, BaseSandbox]</code> <p>Dict of sandbox_type -&gt; NativeDockerSandbox instance</p> required <code>continue_on_error</code> <code>bool</code> <p>If True, continue initializing other sandboxes when one fails, and return a map of sandbox_type -&gt; Exception | None instead of raising. If False, propagate errors.</p> <code>False</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances on remote Docker daemon.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.patch_file_func","title":"<code>patch_file_func(files_func_to_content: dict[str, str], lang: str = 'c')</code>","text":"<p>Replace a function in a file inside the container with new content.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.patch_search_replace","title":"<code>patch_search_replace(file: str, search: str, replace: str)</code>","text":"<p>Replace all occurrences of 'search' with 'replace' in the specified file.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.set_config","title":"<code>set_config(config) -&gt; None</code>  <code>classmethod</code>","text":"<p>Inject config into the backend class.</p> <p>Called by factory before backend methods are invoked.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.RemoteDockerSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.SandboxInitializer","title":"<code>SandboxInitializer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for sandbox functionality initializers.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.SandboxInitializer.async_initialize","title":"<code>async_initialize(all_sandboxes: dict[str, BaseSandbox]) -&gt; None</code>  <code>async</code>","text":"<p>Initialize sandbox initializer (async version).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.create_sandbox_class","title":"<code>create_sandbox_class(backend_class: Type[BaseSandbox], initializer_class: Type) -&gt; Type[BaseSandbox]</code>","text":"<p>Create a sandbox class by combining a backend with a initializer.</p> <p>Parameters:</p> Name Type Description Default <code>backend_class</code> <code>Type[BaseSandbox]</code> <p>The backend sandbox class (e.g., NativeDockerSandbox)</p> required <code>initializer_class</code> <code>Type</code> <p>Initializer class to add functionality</p> required <p>Returns:</p> Type Description <code>Type[BaseSandbox]</code> <p>A new class that combines the backend and initializer</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.get_backend_class","title":"<code>get_backend_class(backend_type: str, config=None) -&gt; Type[BaseSandbox]</code>","text":"<p>Get the backend class for a given backend type.</p> <p>Parameters:</p> Name Type Description Default <code>backend_type</code> <code>str</code> <p>The type of backend needed (e.g., 'native', 'k8s')</p> required <code>config</code> <p>Optional config to inject into backend (for remotedocker)</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[BaseSandbox]</code> <p>The backend class</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If backend type is not supported</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.factory.get_initializer_class","title":"<code>get_initializer_class(sandbox_type: str) -&gt; Type</code>","text":"<p>Get the initializer class for a given sandbox type.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_type</code> <code>str</code> <p>The type of sandbox functionality needed</p> required <p>Returns:</p> Type Description <code>Type</code> <p>The initializer class, or the base SandboxInitializer if not found</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox","title":"<code>aigise.sandbox.native_docker_sandbox</code>","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox","title":"<code>BaseSandbox</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all sandbox implementations.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Cache sandbox states and shared volume content.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict</code> <p>Dictionary mapping sandbox types to sandbox instances</p> required <code>shared_volume_id</code> <code>str</code> <p>Shared volume identifier to backup</p> required <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>task_name</code> <code>str</code> <p>Task name for cache naming</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with cache results including backup paths and cached images</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from local filesystem to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; Exception</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance asynchronously.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Delete shared volumes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.get_work_dir","title":"<code>get_work_dir()</code>  <code>abstractmethod</code>","text":"<p>Get the current working directory in the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances for a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>sandbox_configs</code> <code>dict</code> <p>Dictionary of sandbox_type -&gt; ContainerConfig</p> required <code>shared_volume_id</code> <code>str</code> <p>Optional shared volume to mount to all sandboxes</p> <code>None</code> <code>scripts_volume_id</code> <code>str</code> <p>Optional scripts volume to mount to all sandboxes</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>Optional tools volume to mount to all sandboxes</p> <code>None</code> <p>Returns:     Dictionary mapping sandbox_type to sandbox instance or connection info</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>  <code>abstractmethod</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.BaseSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.ContainerConfig","title":"<code>ContainerConfig</code>  <code>dataclass</code>","text":"<p>Lightweight config for Docker-backed sandboxes.</p> <p>This is an internal convenience type to keep sandbox code tidy and typed. It intentionally mirrors common docker SDK/run options that we may support. Any unsupported fields can be kept in extra for forward-compat.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.DockerBuildResult","title":"<code>DockerBuildResult</code>  <code>dataclass</code>","text":"<p>Result of a Docker image build operation.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox","title":"<code>NativeDockerSandbox</code>","text":"<p>               Bases: <code>BaseSandbox</code></p> <p>Native Docker sandbox implementation using direct Docker API.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.__init__","title":"<code>__init__(container_config: ContainerConfig, session_id: str = None, backend_type: str = None, sandbox_type: str = None)</code>","text":"<p>Initialize NativeDockerSandbox.</p> <p>Parameters:</p> Name Type Description Default <code>container_config</code> <code>ContainerConfig</code> <p>ContainerConfig options controlling container launch (must include image or container_id)</p> required"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>classmethod</code>","text":"<p>Cache Docker containers and shared volume content.</p> <p>This method will: 1. Backup shared volume content to a tar.gz file 2. Commit each running container to a new image</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <p>Session identifier</p> required <code>sandbox_instances</code> <code>dict</code> <p>Dictionary mapping sandbox types to NativeDockerSandbox instances</p> required <code>shared_volume_id</code> <code>str</code> <p>Docker volume name to backup</p> required <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>task_name</code> <code>str</code> <p>Task name for naming cached resources</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with cache results</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.copy_directory_from_container","title":"<code>copy_directory_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.copy_directory_to_container","title":"<code>copy_directory_to_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the host to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>","text":"<p>Copy a single file to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools (built-in + plugins).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; tuple[str, NativeDockerSandbox]</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance without initialization.</p> <p>This method only creates the Docker container and sandbox instance. Call initialize_all_sandboxes() afterwards to initialize.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.create_tar_bytes","title":"<code>create_tar_bytes(file_content: str, arcname: str) -&gt; bytes</code>","text":"<p>Pack the given file content into a tar archive.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.delete_container","title":"<code>delete_container(max_wait: int = 10)</code>","text":"<p>Delete the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Delete shared volumes.</p> <p>Parameters:</p> Name Type Description Default <code>scripts_volume_id</code> <code>str</code> <p>ID of the scripts volume to delete</p> <code>None</code> <code>data_volume_id</code> <code>str</code> <p>ID of the data volume to delete</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>ID of the tools volume to delete</p> <code>None</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>","text":"<p>Extract the content of the specified file from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>","text":"<p>Extract the content of the specified file from the container as bytes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.get_file_content","title":"<code>get_file_content(filepath: str) -&gt; str</code>","text":"<p>Retrieve the content of a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.get_function_content","title":"<code>get_function_content(key: str, lang: str = 'c', line_in_func: int = -1) -&gt; tuple[str, int, int]</code>","text":"<p>Retrieve the content of a specific function from a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.get_work_dir","title":"<code>get_work_dir() -&gt; str</code>","text":"<p>Get the working directory of the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.initialize_all_sandboxes","title":"<code>initialize_all_sandboxes(sandbox_instances: dict[str, BaseSandbox], *, continue_on_error: bool = False) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Initialize all sandbox instances concurrently.</p> <p>This should be called after launch_all_sandboxes() and after registering any hooks.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict[str, BaseSandbox]</code> <p>Dict of sandbox_type -&gt; NativeDockerSandbox instance</p> required <code>continue_on_error</code> <code>bool</code> <p>If True, continue initializing other sandboxes when one fails, and return a map of sandbox_type -&gt; Exception | None instead of raising. If False, propagate errors.</p> <code>False</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances as separate Docker containers.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>sandbox_configs</code> <code>dict</code> <p>Dictionary of sandbox_type -&gt; ContainerConfig</p> required <code>shared_volume_id</code> <code>str</code> <p>Optional shared volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <code>scripts_volume_id</code> <code>str</code> <p>Optional scripts volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>Optional tools volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary mapping sandbox_type to NativeDockerSandbox instance</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.patch_file_func","title":"<code>patch_file_func(files_func_to_content: dict[str, str], lang: str = 'c')</code>","text":"<p>Replace a function in a file inside the container with new content.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.patch_search_replace","title":"<code>patch_search_replace(file: str, search: str, replace: str)</code>","text":"<p>Replace all occurrences of 'search' with 'replace' in the specified file.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.NativeDockerSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.SandboxState","title":"<code>SandboxState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Sandbox initialization states.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.build_image_from_dockerfile","title":"<code>build_image_from_dockerfile(config: ContainerConfig) -&gt; DockerBuildResult</code>","text":"<p>Build Docker image from a direct Dockerfile.</p> <p>Parameters:</p> Name Type Description Default <code>dockerfile_path</code> <p>Path to the Dockerfile</p> required <code>image_name</code> <p>Name and tag for the built image (e.g., 'myapp:latest')</p> required <code>build_context</code> <p>Directory to use as build context. If None, uses dockerfile directory</p> required <code>build_args</code> <p>Build-time variables for Docker build (--build-arg)</p> required <p>Returns:</p> Type Description <code>DockerBuildResult</code> <p>DockerBuildResult with build status and details</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.can_pull_image","title":"<code>can_pull_image(image_name: str) -&gt; bool</code>","text":"<p>Try to pull Docker image and return success status.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.ensure_docker_image","title":"<code>ensure_docker_image(config: ContainerConfig) -&gt; tuple[bool, Optional[str]]</code>","text":"<p>Ensure Docker image is available, using dockerfile fallback if needed.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ContainerConfig</code> <p>ContainerConfig with image name and optional dockerfile config</p> required <p>Returns:</p> Type Description <code>tuple[bool, Optional[str]]</code> <p>Tuple of (success, error_message). If success is False, error_message explains why.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.native_docker_sandbox.image_exists_locally","title":"<code>image_exists_locally(image_name: str) -&gt; bool</code>","text":"<p>Check if Docker image exists locally.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox","title":"<code>aigise.sandbox.remote_docker_sandbox</code>","text":"<p>Remote Docker Sandbox implementation.</p> <p>This module provides a sandbox backend that connects to remote Docker daemons via SSH or TCP, enabling distributed execution across multiple machines.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.DockerBuildResult","title":"<code>DockerBuildResult</code>  <code>dataclass</code>","text":"<p>Result of a Docker image build operation.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox","title":"<code>NativeDockerSandbox</code>","text":"<p>               Bases: <code>BaseSandbox</code></p> <p>Native Docker sandbox implementation using direct Docker API.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.__init__","title":"<code>__init__(container_config: ContainerConfig, session_id: str = None, backend_type: str = None, sandbox_type: str = None)</code>","text":"<p>Initialize NativeDockerSandbox.</p> <p>Parameters:</p> Name Type Description Default <code>container_config</code> <code>ContainerConfig</code> <p>ContainerConfig options controlling container launch (must include image or container_id)</p> required"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>classmethod</code>","text":"<p>Cache Docker containers and shared volume content.</p> <p>This method will: 1. Backup shared volume content to a tar.gz file 2. Commit each running container to a new image</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <p>Session identifier</p> required <code>sandbox_instances</code> <code>dict</code> <p>Dictionary mapping sandbox types to NativeDockerSandbox instances</p> required <code>shared_volume_id</code> <code>str</code> <p>Docker volume name to backup</p> required <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>task_name</code> <code>str</code> <p>Task name for naming cached resources</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with cache results</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.copy_directory_from_container","title":"<code>copy_directory_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.copy_directory_to_container","title":"<code>copy_directory_to_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the host to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>","text":"<p>Copy a single file to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools (built-in + plugins).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; tuple[str, NativeDockerSandbox]</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance without initialization.</p> <p>This method only creates the Docker container and sandbox instance. Call initialize_all_sandboxes() afterwards to initialize.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.create_tar_bytes","title":"<code>create_tar_bytes(file_content: str, arcname: str) -&gt; bytes</code>","text":"<p>Pack the given file content into a tar archive.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.delete_container","title":"<code>delete_container(max_wait: int = 10)</code>","text":"<p>Delete the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Delete shared volumes.</p> <p>Parameters:</p> Name Type Description Default <code>scripts_volume_id</code> <code>str</code> <p>ID of the scripts volume to delete</p> <code>None</code> <code>data_volume_id</code> <code>str</code> <p>ID of the data volume to delete</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>ID of the tools volume to delete</p> <code>None</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>","text":"<p>Extract the content of the specified file from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>","text":"<p>Extract the content of the specified file from the container as bytes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.get_file_content","title":"<code>get_file_content(filepath: str) -&gt; str</code>","text":"<p>Retrieve the content of a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.get_function_content","title":"<code>get_function_content(key: str, lang: str = 'c', line_in_func: int = -1) -&gt; tuple[str, int, int]</code>","text":"<p>Retrieve the content of a specific function from a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.get_work_dir","title":"<code>get_work_dir() -&gt; str</code>","text":"<p>Get the working directory of the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.initialize_all_sandboxes","title":"<code>initialize_all_sandboxes(sandbox_instances: dict[str, BaseSandbox], *, continue_on_error: bool = False) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Initialize all sandbox instances concurrently.</p> <p>This should be called after launch_all_sandboxes() and after registering any hooks.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict[str, BaseSandbox]</code> <p>Dict of sandbox_type -&gt; NativeDockerSandbox instance</p> required <code>continue_on_error</code> <code>bool</code> <p>If True, continue initializing other sandboxes when one fails, and return a map of sandbox_type -&gt; Exception | None instead of raising. If False, propagate errors.</p> <code>False</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances as separate Docker containers.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>sandbox_configs</code> <code>dict</code> <p>Dictionary of sandbox_type -&gt; ContainerConfig</p> required <code>shared_volume_id</code> <code>str</code> <p>Optional shared volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <code>scripts_volume_id</code> <code>str</code> <p>Optional scripts volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>Optional tools volume to mount to all sandboxes (unused, configs already updated)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary mapping sandbox_type to NativeDockerSandbox instance</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.patch_file_func","title":"<code>patch_file_func(files_func_to_content: dict[str, str], lang: str = 'c')</code>","text":"<p>Replace a function in a file inside the container with new content.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.patch_search_replace","title":"<code>patch_search_replace(file: str, search: str, replace: str)</code>","text":"<p>Replace all occurrences of 'search' with 'replace' in the specified file.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.NativeDockerSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox","title":"<code>RemoteDockerSandbox</code>","text":"<p>               Bases: <code>NativeDockerSandbox</code></p> <p>Remote Docker sandbox implementation using Docker API over SSH/TCP.</p> <p>This backend extends NativeDockerSandbox to support remote Docker daemons, enabling execution on remote machines while maintaining the same interface.</p> <p>Key differences from NativeDockerSandbox: - Docker client connects to remote daemon (requires docker_host config) - Volume population uses put_archive instead of bind mounts - Network configuration uses remote host IP instead of loopback - Image operations use Docker SDK instead of subprocess - All operations performed via Docker API (no local dependencies)</p> Configuration <p>[sandbox] backend = \"remotedocker\" docker_host = \"ssh://user@remote-host\"  # or tcp://host:2376 docker_remote_host = \"192.168.1.100\"    # optional, auto-parsed if not set</p> <p>Environment Variables (fallback):     DOCKER_HOST: Remote Docker daemon URL     DOCKER_REMOTE_HOST: Remote host IP for service connections     DOCKER_TLS_CERTDIR: TLS certificate directory for TCP</p> Usage <p>export DOCKER_HOST=\"ssh://user@gpu-server\" python -m aigise.evaluations ...</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.__init__","title":"<code>__init__(container_config, session_id: str = None, backend_type: str = None, sandbox_type: str = None)</code>","text":"<p>Initialize remote Docker sandbox.</p> <p>Overrides parent to use remote Docker client instead of docker.from_env().</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.build_image_from_dockerfile","title":"<code>build_image_from_dockerfile(config) -&gt; Optional[DockerBuildResult]</code>  <code>classmethod</code>","text":"<p>Build image using Docker SDK (remote-compatible).</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>classmethod</code>","text":"<p>Cache containers on remote Docker.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.can_pull_image","title":"<code>can_pull_image(image_name: str) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Pull image on remote Docker daemon.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.copy_directory_from_container","title":"<code>copy_directory_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.copy_directory_to_container","title":"<code>copy_directory_to_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a directory from the host to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>","text":"<p>Copy a single file to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools (built-in + plugins).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; tuple[str, NativeDockerSandbox]</code>  <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance without initialization.</p> <p>This method only creates the Docker container and sandbox instance. Call initialize_all_sandboxes() afterwards to initialize.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.create_tar_bytes","title":"<code>create_tar_bytes(file_content: str, arcname: str) -&gt; bytes</code>","text":"<p>Pack the given file content into a tar archive.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.delete_container","title":"<code>delete_container(max_wait: int = 10)</code>","text":"<p>Delete the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Delete shared volumes using Docker API.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.ensure_docker_image","title":"<code>ensure_docker_image(config) -&gt; tuple[bool, Optional[str]]</code>  <code>classmethod</code>","text":"<p>Ensure image is available on remote daemon.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>","text":"<p>Extract the content of the specified file from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>","text":"<p>Extract the content of the specified file from the container as bytes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.get_file_content","title":"<code>get_file_content(filepath: str) -&gt; str</code>","text":"<p>Retrieve the content of a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.get_function_content","title":"<code>get_function_content(key: str, lang: str = 'c', line_in_func: int = -1) -&gt; tuple[str, int, int]</code>","text":"<p>Retrieve the content of a specific function from a file inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.get_work_dir","title":"<code>get_work_dir() -&gt; str</code>","text":"<p>Get the working directory of the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.image_exists_locally","title":"<code>image_exists_locally(image_name: str) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if image exists on remote Docker daemon.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.initialize_all_sandboxes","title":"<code>initialize_all_sandboxes(sandbox_instances: dict[str, BaseSandbox], *, continue_on_error: bool = False) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Initialize all sandbox instances concurrently.</p> <p>This should be called after launch_all_sandboxes() and after registering any hooks.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict[str, BaseSandbox]</code> <p>Dict of sandbox_type -&gt; NativeDockerSandbox instance</p> required <code>continue_on_error</code> <code>bool</code> <p>If True, continue initializing other sandboxes when one fails, and return a map of sandbox_type -&gt; Exception | None instead of raising. If False, propagate errors.</p> <code>False</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances on remote Docker daemon.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.patch_file_func","title":"<code>patch_file_func(files_func_to_content: dict[str, str], lang: str = 'c')</code>","text":"<p>Replace a function in a file inside the container with new content.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.patch_search_replace","title":"<code>patch_search_replace(file: str, search: str, replace: str)</code>","text":"<p>Replace all occurrences of 'search' with 'replace' in the specified file.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.set_config","title":"<code>set_config(config) -&gt; None</code>  <code>classmethod</code>","text":"<p>Inject config into the backend class.</p> <p>Called by factory before backend methods are invoked.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.remote_docker_sandbox.RemoteDockerSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox","title":"<code>aigise.sandbox.k8s_sandbox</code>","text":"<p>K8s sandbox implementation using kubectl and K8s Python client.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox","title":"<code>BaseSandbox</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all sandbox implementations.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Cache sandbox states and shared volume content.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict</code> <p>Dictionary mapping sandbox types to sandbox instances</p> required <code>shared_volume_id</code> <code>str</code> <p>Shared volume identifier to backup</p> required <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>task_name</code> <code>str</code> <p>Task name for cache naming</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with cache results including backup paths and cached images</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from local filesystem to the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; Exception</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance asynchronously.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Delete shared volumes.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.get_work_dir","title":"<code>get_work_dir()</code>  <code>abstractmethod</code>","text":"<p>Get the current working directory in the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances for a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>sandbox_configs</code> <code>dict</code> <p>Dictionary of sandbox_type -&gt; ContainerConfig</p> required <code>shared_volume_id</code> <code>str</code> <p>Optional shared volume to mount to all sandboxes</p> <code>None</code> <code>scripts_volume_id</code> <code>str</code> <p>Optional scripts volume to mount to all sandboxes</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>Optional tools volume to mount to all sandboxes</p> <code>None</code> <p>Returns:     Dictionary mapping sandbox_type to sandbox instance or connection info</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>  <code>abstractmethod</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.BaseSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.ContainerConfig","title":"<code>ContainerConfig</code>  <code>dataclass</code>","text":"<p>Lightweight config for Docker-backed sandboxes.</p> <p>This is an internal convenience type to keep sandbox code tidy and typed. It intentionally mirrors common docker SDK/run options that we may support. Any unsupported fields can be kept in extra for forward-compat.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.K8sSandbox","title":"<code>K8sSandbox</code>","text":"<p>               Bases: <code>BaseSandbox</code></p> <p>K8s sandbox representing a specific container within a Pod.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.K8sSandbox.__init__","title":"<code>__init__(container_config: ContainerConfig, session_id: str = None, backend_type: str = None, sandbox_type: str = None, pod_name: str = None, container_name: str = None)</code>","text":"<p>Initialize K8sSandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.K8sSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.K8sSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>classmethod</code>","text":"<p>Create and initialize three shared PVCs.</p> <p>Creates three PVCs: 1. Read-only PVC with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write PVC with user data (mapped to /shared) 3. Read-write PVC with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for PVC names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw PVC (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools (built-in + plugins).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_pvc_name, data_pvc_name, tools_pvc_name)</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.K8sSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Delete shared PVCs.</p> <p>Parameters:</p> Name Type Description Default <code>scripts_volume_id</code> <code>str</code> <p>ID of the scripts PVC to delete (with or without pvc/ prefix)</p> <code>None</code> <code>data_volume_id</code> <code>str</code> <p>ID of the data PVC to delete (with or without pvc/ prefix)</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>ID of the tools PVC to delete (with or without pvc/ prefix)</p> <code>None</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.K8sSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.K8sSandbox.initialize_all_sandboxes","title":"<code>initialize_all_sandboxes(sandbox_instances: dict, *, continue_on_error: bool = False) -&gt; dict</code>  <code>async</code> <code>classmethod</code>","text":"<p>Initialize all sandbox instances concurrently.</p> <p>This should be called after launch_all_sandboxes() and after registering any hooks.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict</code> <p>Dict of sandbox_type -&gt; K8sSandbox instance</p> required <code>continue_on_error</code> <code>bool</code> <p>If True, continue on failures and return a map of sandbox_type -&gt; Exception | None. If False, propagate errors.</p> <code>False</code>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.K8sSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/sandbox/#aigise.sandbox.k8s_sandbox.SandboxState","title":"<code>SandboxState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Sandbox initialization states.</p>"},{"location":"generated/api/session/","title":"Session","text":""},{"location":"generated/api/session/#aigise.session.aigise_session","title":"<code>aigise.session.aigise_session</code>","text":"<p>AigiseSession: Unified session management for AigiseAgent Framework</p> <p>This module provides the primary session management architecture that consolidates all session-specific managers (config, agents, sandboxes) under a unified interface.</p> <p>Each AigiseSession instance represents a single session and manages all resources for that session without relying on global singletons.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseConfig","title":"<code>AigiseConfig</code>  <code>dataclass</code>","text":"<p>Complete SecAgentFramework configuration.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseConfig.copy","title":"<code>copy() -&gt; AigiseConfig</code>","text":"<p>Create a deep copy of this configuration.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseConfig.create_default","title":"<code>create_default() -&gt; AigiseConfig</code>  <code>classmethod</code>","text":"<p>Create a default configuration from TOML file with environment variable overrides.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseConfig.from_toml","title":"<code>from_toml(config_path: Optional[str] = None) -&gt; AigiseConfig</code>  <code>classmethod</code>","text":"<p>Create configuration from TOML file with template variable expansion.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseConfig.get_llm_config","title":"<code>get_llm_config(model_name: str)</code>","text":"<p>Get LLM configuration for a specific model.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>Name of the model configuration to get</p> required <p>Returns:</p> Type Description <p>ModelConfig for the specified model, or None if not found</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseConfig.get_sandbox_config","title":"<code>get_sandbox_config(sandbox_type: str)</code>","text":"<p>Get sandbox configuration for a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_type</code> <code>str</code> <p>Type of sandbox configuration to get</p> required <p>Returns:</p> Type Description <p>ContainerConfig for the specified sandbox type, or None if not found</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseConfig.save_to_toml","title":"<code>save_to_toml(toml_path: str) -&gt; None</code>","text":"<p>Save configuration to TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>toml_path</code> <code>str</code> <p>Path to save TOML file</p> required"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSession","title":"<code>AigiseSession</code>","text":"<p>Unified session manager for AigiseAgent Framework.</p> <p>Each instance manages all resources for a specific session, including: - Configuration management (TOML loading, env overrides) - Agent lifecycle management (creation, persistence, cleanup) - Sandbox management (Docker containers, resource isolation) - Agent ensemble management (thread-safe tools, agent discovery)</p> <p>This replaces the previous singleton-based architecture with a clear session-bound resource management model.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSession.__init__","title":"<code>__init__(aigise_session_id: str, config_path: Optional[str] = None)</code>","text":"<p>Initialize AigiseSession for a specific session.</p> <p>Parameters:</p> Name Type Description Default <code>aigise_session_id</code> <code>str</code> <p>Unique identifier for this session</p> required <code>config_path</code> <code>Optional[str]</code> <p>Optional path to TOML configuration file</p> <code>None</code>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSession.cleanup","title":"<code>cleanup() -&gt; None</code>","text":"<p>Cleanup all resources for this session.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSession.get_session_info","title":"<code>get_session_info() -&gt; Dict</code>","text":"<p>Get comprehensive information about this session.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary containing session information</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSession.load_config_from_toml","title":"<code>load_config_from_toml(toml_path: str) -&gt; None</code>","text":"<p>Load configuration from TOML file for this session.</p> <p>Parameters:</p> Name Type Description Default <code>toml_path</code> <code>str</code> <p>Path to TOML configuration file</p> required"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSession.save_config_to_toml","title":"<code>save_config_to_toml(toml_path: str) -&gt; None</code>","text":"<p>Save current configuration to TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>toml_path</code> <code>str</code> <p>Path to save TOML file</p> required"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSession.update_config_from_env","title":"<code>update_config_from_env() -&gt; None</code>","text":"<p>Update configuration from environment variables.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSessionRegistry","title":"<code>AigiseSessionRegistry</code>","text":"<p>Global registry for managing AigiseSession instances.</p> <p>This is the only global singleton in the new architecture, responsible for: - Creating and tracking session managers - Preventing duplicate sessions - Coordinating session cleanup - Managing global signal handlers for graceful shutdown</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSessionRegistry.cleanup_all_sessions","title":"<code>cleanup_all_sessions() -&gt; None</code>  <code>classmethod</code>","text":"<p>Cleanup all active sessions.</p> <p>This should be called during application shutdown to ensure all resources are properly cleaned up.</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSessionRegistry.get_aigise_session","title":"<code>get_aigise_session(aigise_session_id: str, config_path: Optional[str] = None) -&gt; AigiseSession</code>  <code>classmethod</code>","text":"<p>Get or create a session manager for the given session ID.</p> <p>Parameters:</p> Name Type Description Default <code>aigise_session_id</code> <code>str</code> <p>Unique session identifier</p> required <p>Returns:</p> Type Description <code>AigiseSession</code> <p>AigiseSession instance for the session</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSessionRegistry.list_sessions","title":"<code>list_sessions() -&gt; list[str]</code>  <code>classmethod</code>","text":"<p>Get list of all active session IDs.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of active session IDs</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.AigiseSessionRegistry.remove_session","title":"<code>remove_session(aigise_session_id: str) -&gt; bool</code>  <code>classmethod</code>","text":"<p>Remove and cleanup a session.</p> <p>Parameters:</p> Name Type Description Default <code>aigise_session_id</code> <code>str</code> <p>Session ID to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if removed, False if not found</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.cleanup_aigise_session","title":"<code>cleanup_aigise_session(aigise_session_id: str) -&gt; bool</code>","text":"<p>Cleanup and remove an AigiseSession.</p> <p>Parameters:</p> Name Type Description Default <code>aigise_session_id</code> <code>str</code> <p>Session ID to cleanup</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if cleaned up, False if not found</p> Example <p>cleanup_aigise_session(\"user_123_task_456\")</p>"},{"location":"generated/api/session/#aigise.session.aigise_session.get_aigise_session","title":"<code>get_aigise_session(aigise_session_id: str, config_path: Optional[str] = None) -&gt; AigiseSession</code>","text":"<p>Get or create an AigiseSession for the given session ID.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager","title":"<code>aigise.session.aigise_sandbox_manager</code>","text":"<p>AigiseSandboxManager: Session-specific sandbox management</p> <p>This module provides session-bound sandbox management, replacing the global SandboxManager with session-isolated sandbox handling.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseConfig","title":"<code>AigiseConfig</code>  <code>dataclass</code>","text":"<p>Complete SecAgentFramework configuration.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseConfig.copy","title":"<code>copy() -&gt; AigiseConfig</code>","text":"<p>Create a deep copy of this configuration.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseConfig.create_default","title":"<code>create_default() -&gt; AigiseConfig</code>  <code>classmethod</code>","text":"<p>Create a default configuration from TOML file with environment variable overrides.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseConfig.from_toml","title":"<code>from_toml(config_path: Optional[str] = None) -&gt; AigiseConfig</code>  <code>classmethod</code>","text":"<p>Create configuration from TOML file with template variable expansion.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseConfig.get_llm_config","title":"<code>get_llm_config(model_name: str)</code>","text":"<p>Get LLM configuration for a specific model.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str</code> <p>Name of the model configuration to get</p> required <p>Returns:</p> Type Description <p>ModelConfig for the specified model, or None if not found</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseConfig.get_sandbox_config","title":"<code>get_sandbox_config(sandbox_type: str)</code>","text":"<p>Get sandbox configuration for a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_type</code> <code>str</code> <p>Type of sandbox configuration to get</p> required <p>Returns:</p> Type Description <p>ContainerConfig for the specified sandbox type, or None if not found</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseConfig.save_to_toml","title":"<code>save_to_toml(toml_path: str) -&gt; None</code>","text":"<p>Save configuration to TOML file.</p> <p>Parameters:</p> Name Type Description Default <code>toml_path</code> <code>str</code> <p>Path to save TOML file</p> required"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager","title":"<code>AigiseSandboxManager</code>","text":"<p>Session-specific sandbox manager.</p> <p>Each AigiseSession gets its own AigiseSandboxManager instance, ensuring complete sandbox isolation between sessions.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.config","title":"<code>config: AigiseConfig</code>  <code>property</code>","text":"<p>Get latest config from session dynamically.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.__init__","title":"<code>__init__(session)</code>","text":"<p>Initialize AigiseSandboxManager.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <p>AigiseSession instance (stores reference, not copied)</p> required"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.attach_sandbox","title":"<code>attach_sandbox(sandbox_type: str, *, container_id: Optional[str] = None, pod_name: Optional[str] = None, container_name: Optional[str] = None) -&gt; None</code>  <code>async</code>","text":"<p>Attach to an existing container/Pod and register it to this session, then call ensure_ready.</p> <ul> <li>native (Docker): requires container_id</li> <li>k8s: requires pod_name + container_name</li> </ul>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.cache_sandboxes","title":"<code>cache_sandboxes(cache_dir: Optional[str] = None) -&gt; Dict[str, Any]</code>","text":"<p>Cache current sandbox states and shared volume content.</p> <p>Parameters:</p> Name Type Description Default <code>cache_dir</code> <code>Optional[str]</code> <p>Directory to store cache files (default: ./sandbox_cache/{task_name})</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with cache results including backup paths and cached images</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.cleanup","title":"<code>cleanup() -&gt; None</code>","text":"<p>Cleanup all sandboxes for this session.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.get_sandbox","title":"<code>get_sandbox(sandbox_type: str) -&gt; BaseSandbox</code>","text":"<p>Get the sandbox instance for the given sandbox type.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_type</code> <code>str</code> <p>Type of sandbox to get or create</p> required <p>Returns:</p> Type Description <code>BaseSandbox</code> <p>BaseSandbox instance for the session and type</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.get_session_statistics","title":"<code>get_session_statistics() -&gt; Dict</code>","text":"<p>Get statistics for this session's sandboxes.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with session statistics</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.get_shared_volume","title":"<code>get_shared_volume() -&gt; Optional[str]</code>","text":"<p>Get the shared volume ID for this session.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Volume ID or None if no shared volume exists</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.initialize_all_sandboxes","title":"<code>initialize_all_sandboxes(*, continue_on_error: bool = False) -&gt; None</code>  <code>async</code>","text":"<p>Initialize all created sandboxes.</p> <p>This should be called after launch_all_sandboxes() and after registering any hooks.</p> Example"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.initialize_all_sandboxes--create-sandboxes","title":"Create sandboxes","text":"<p>await aigise_session.sandboxes.launch_all_sandboxes()</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.initialize_all_sandboxes--initialize","title":"Initialize","text":"<p>await aigise_session.sandboxes.initialize_all_sandboxes()</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.initialize_shared_volumes","title":"<code>initialize_shared_volumes(*, tools_top_roots: set[str] | None = None, enabled_skills: Any = None) -&gt; None</code>","text":"<p>Initialize shared volumes (scripts/shared-data/tools).</p> <p>Parameters:</p> Name Type Description Default <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage into the tools volume/PVC. If None, stage all tools.</p> <code>None</code> <code>enabled_skills</code> <code>Any</code> <p>enabled_skills setting from the root agent (None, \"all\", or List[str]). Stored for sandbox initializers to conditionally run skill dependency installers.</p> <code>None</code>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.launch_all_sandboxes","title":"<code>launch_all_sandboxes(sandbox_types: Optional[Set[str]] = None) -&gt; None</code>  <code>async</code>","text":"<p>Launch configured sandbox instances based on backend type.</p> <p>This method should be called during session initialization. If sandboxes already exist, this method will skip to avoid conflicts.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_types</code> <code>Optional[Set[str]]</code> <p>Optional set of sandbox types to launch. If None, launches all configured sandboxes. If provided, only launches sandboxes of the specified types. Use collect_sandbox_dependencies() to get this from an agent.</p> <code>None</code> <p>Example::</p> <pre><code># Launch only required sandboxes\nfrom aigise.toolbox.decorators import collect_sandbox_dependencies\n\ndeps = collect_sandbox_dependencies(root_agent)  # {'main', 'gdb_mcp'}\nawait session.sandboxes.launch_all_sandboxes(sandbox_types=deps)\n\n# Or launch all configured sandboxes\nawait session.sandboxes.launch_all_sandboxes()\n</code></pre>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.list_sandboxes","title":"<code>list_sandboxes() -&gt; Dict[str, BaseSandbox]</code>","text":"<p>List all sandboxes for this session.</p> <p>Returns:</p> Type Description <code>Dict[str, BaseSandbox]</code> <p>Dictionary mapping sandbox types to sandbox instances</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.load_sandbox_caches_to_config","title":"<code>load_sandbox_caches_to_config() -&gt; list[str]</code>","text":"<p>Load cached sandbox images and update sandbox configurations.</p> <p>This method looks for cached images with the naming pattern: {normalized_task_name}sandbox:cached</p> <p>For each found cached image, it updates the corresponding sandbox configuration to use the cached image instead of the original.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of sandbox types that don't have cached images available</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.AigiseSandboxManager.remove_sandbox","title":"<code>remove_sandbox(sandbox_type: str) -&gt; bool</code>","text":"<p>Remove and cleanup a specific sandbox.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_type</code> <code>str</code> <p>Type of sandbox to remove</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if removed, False if not found</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox","title":"<code>BaseSandbox</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all sandbox implementations.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.async_initialize","title":"<code>async_initialize() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the sandbox.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.cache_sandboxes","title":"<code>cache_sandboxes(sandbox_instances: dict, shared_volume_id: str, cache_dir: str, task_name: str) -&gt; dict</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Cache sandbox states and shared volume content.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_instances</code> <code>dict</code> <p>Dictionary mapping sandbox types to sandbox instances</p> required <code>shared_volume_id</code> <code>str</code> <p>Shared volume identifier to backup</p> required <code>cache_dir</code> <code>str</code> <p>Directory to store cache files</p> required <code>task_name</code> <code>str</code> <p>Task name for cache naming</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with cache results including backup paths and cached images</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.copy_file_from_container","title":"<code>copy_file_from_container(src_path: str, dst_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from the container to local filesystem.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.copy_file_to_container","title":"<code>copy_file_to_container(local_path: str, container_path: str)</code>  <code>abstractmethod</code>","text":"<p>Copy a file from local filesystem to the container.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.create_shared_volume","title":"<code>create_shared_volume(volume_name_prefix: str, init_data_path: Path = None, tools_top_roots: set[str] | None = None) -&gt; tuple[str, str, str]</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create and initialize three shared volumes.</p> <p>Creates three volumes: 1. Read-only volume with sandbox scripts (mapped to /sandbox_scripts) 2. Read-write volume with user data (mapped to /shared) 3. Read-write volume with bash tools (mapped to /bash_tools)</p> <p>Parameters:</p> Name Type Description Default <code>volume_name_prefix</code> <code>str</code> <p>Prefix for volume names (e.g., session_id)</p> required <code>init_data_path</code> <code>Path</code> <p>Path to initial data to copy into the rw volume (optional)</p> <code>None</code> <code>tools_top_roots</code> <code>set[str] | None</code> <p>Optional set of top-level bash_tools roots to stage. If None, stage all bash tools.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>Tuple of (scripts_volume_id, data_volume_id, tools_volume_id)</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.create_single_sandbox","title":"<code>create_single_sandbox(session_id: str, sandbox_type: str, container_config) -&gt; Exception</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Create a single sandbox instance asynchronously.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.delete_shared_volumes","title":"<code>delete_shared_volumes(scripts_volume_id: str = None, data_volume_id: str = None, tools_volume_id: str = None) -&gt; None</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Delete shared volumes.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.ensure_ready","title":"<code>ensure_ready() -&gt; None</code>  <code>async</code>","text":"<p>Ensure the sandbox is ready.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.extract_file_from_container","title":"<code>extract_file_from_container(filepath: str) -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.extract_file_from_container_bytes","title":"<code>extract_file_from_container_bytes(filepath: str) -&gt; bytes</code>  <code>abstractmethod</code>","text":"<p>Extract file content from the container.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.get_work_dir","title":"<code>get_work_dir()</code>  <code>abstractmethod</code>","text":"<p>Get the current working directory in the container.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.launch_all_sandboxes","title":"<code>launch_all_sandboxes(session_id: str, sandbox_configs: dict, shared_volume_id: str = None, scripts_volume_id: str = None, tools_volume_id: str = None) -&gt; dict</code>  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<p>Launch all sandbox instances for a session.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>str</code> <p>Session identifier</p> required <code>sandbox_configs</code> <code>dict</code> <p>Dictionary of sandbox_type -&gt; ContainerConfig</p> required <code>shared_volume_id</code> <code>str</code> <p>Optional shared volume to mount to all sandboxes</p> <code>None</code> <code>scripts_volume_id</code> <code>str</code> <p>Optional scripts volume to mount to all sandboxes</p> <code>None</code> <code>tools_volume_id</code> <code>str</code> <p>Optional tools volume to mount to all sandboxes</p> <code>None</code> <p>Returns:     Dictionary mapping sandbox_type to sandbox instance or connection info</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.run_command_in_container","title":"<code>run_command_in_container(command: str | list[str], timeout: int | None = None) -&gt; tuple[str, int]</code>  <code>abstractmethod</code>","text":"<p>Run a command inside the container.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.BaseSandbox.wait_for_ready_or_error","title":"<code>wait_for_ready_or_error() -&gt; bool</code>  <code>async</code>","text":"<p>Wait for a specific sandbox to be ready or error.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.SandboxState","title":"<code>SandboxState</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Sandbox initialization states.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.can_pull_image","title":"<code>can_pull_image(image_name: str) -&gt; bool</code>","text":"<p>Try to pull Docker image and return success status.</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.create_sandbox_class","title":"<code>create_sandbox_class(backend_class: Type[BaseSandbox], initializer_class: Type) -&gt; Type[BaseSandbox]</code>","text":"<p>Create a sandbox class by combining a backend with a initializer.</p> <p>Parameters:</p> Name Type Description Default <code>backend_class</code> <code>Type[BaseSandbox]</code> <p>The backend sandbox class (e.g., NativeDockerSandbox)</p> required <code>initializer_class</code> <code>Type</code> <p>Initializer class to add functionality</p> required <p>Returns:</p> Type Description <code>Type[BaseSandbox]</code> <p>A new class that combines the backend and initializer</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.get_backend_class","title":"<code>get_backend_class(backend_type: str, config=None) -&gt; Type[BaseSandbox]</code>","text":"<p>Get the backend class for a given backend type.</p> <p>Parameters:</p> Name Type Description Default <code>backend_type</code> <code>str</code> <p>The type of backend needed (e.g., 'native', 'k8s')</p> required <code>config</code> <p>Optional config to inject into backend (for remotedocker)</p> <code>None</code> <p>Returns:</p> Type Description <code>Type[BaseSandbox]</code> <p>The backend class</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If backend type is not supported</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.get_initializer_class","title":"<code>get_initializer_class(sandbox_type: str) -&gt; Type</code>","text":"<p>Get the initializer class for a given sandbox type.</p> <p>Parameters:</p> Name Type Description Default <code>sandbox_type</code> <code>str</code> <p>The type of sandbox functionality needed</p> required <p>Returns:</p> Type Description <code>Type</code> <p>The initializer class, or the base SandboxInitializer if not found</p>"},{"location":"generated/api/session/#aigise.session.aigise_sandbox_manager.image_exists_locally","title":"<code>image_exists_locally(image_name: str) -&gt; bool</code>","text":"<p>Check if Docker image exists locally.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager","title":"<code>aigise.session.aigise_dynamic_agent_manager</code>","text":"<p>DynamicAgentManager: Session-specific agent lifecycle management</p> <p>This module provides session-bound agent management, replacing the global DynamicAgentManager with session-isolated agent handling.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.AgentMetadata","title":"<code>AgentMetadata</code>  <code>dataclass</code>","text":"<p>Metadata for dynamically created agents.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.AgentStatus","title":"<code>AgentStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Agent lifecycle status.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.AigiseAgent","title":"<code>AigiseAgent</code>","text":"<p>               Bases: <code>LlmAgent</code></p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.AigiseAgent.update_enabled_skills","title":"<code>update_enabled_skills(enabled_skills: Optional[Union[List[str], str]]) -&gt; None</code>","text":"<p>Update enabled_skills and regenerate system prompt with new bash tools.</p> <p>This method: 1. Updates the _enabled_skills attribute 2. Removes the old bash tools section from instruction 3. Generates new tool prompt based on new enabled_skills 4. Appends the new tool prompt to instruction</p> <p>Parameters:</p> Name Type Description Default <code>enabled_skills</code> <code>Optional[Union[List[str], str]]</code> <p>New enabled_skills value (None, \"all\", or List[str])</p> required"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager","title":"<code>DynamicAgentManager</code>","text":"<p>Session-specific manager for dynamic agent creation, lifecycle, and persistence.</p> <p>Each AigiseSession gets its own DynamicAgentManager instance, ensuring complete agent isolation between sessions.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.config","title":"<code>config</code>  <code>property</code>","text":"<p>Get latest config from session dynamically.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.__init__","title":"<code>__init__(session)</code>","text":"<p>Initialize DynamicAgentManager.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <p>AigiseSession instance (stores reference, not copied)</p> required"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.cleanup","title":"<code>cleanup() -&gt; None</code>","text":"<p>Cleanup all agents and resources for this session.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.create_agent","title":"<code>create_agent(config: Dict[str, Any], creator: Optional[str] = None, persist: bool = True) -&gt; tuple[str, AigiseAgent]</code>  <code>async</code>","text":"<p>Create a new agent dynamically for this session.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict[str, Any]</code> <p>Agent configuration dictionary</p> required <code>creator</code> <code>Optional[str]</code> <p>Optional creator identifier</p> <code>None</code> <code>persist</code> <code>bool</code> <p>Whether to persist agent metadata</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[str, AigiseAgent]</code> <p>Tuple of (agent_id, agent_instance)</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.get_agent","title":"<code>get_agent(agent_id: str) -&gt; Optional[BaseAgent]</code>","text":"<p>Get an agent by ID for this session.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.get_agent_metadata","title":"<code>get_agent_metadata(agent_id: str) -&gt; Optional[AgentMetadata]</code>","text":"<p>Get agent metadata by ID for this session.</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.get_session_statistics","title":"<code>get_session_statistics() -&gt; Dict</code>","text":"<p>Get statistics for this session's agents.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with session statistics</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.list_agents","title":"<code>list_agents(status: Optional[AgentStatus] = None, creator: Optional[str] = None) -&gt; List[AgentMetadata]</code>","text":"<p>List agents with optional filtering for this session.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Optional[AgentStatus]</code> <p>Optional status filter</p> <code>None</code> <code>creator</code> <code>Optional[str]</code> <p>Optional creator filter</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AgentMetadata]</code> <p>List of agent metadata matching the filters</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.remove_agent","title":"<code>remove_agent(agent_id: str, cascade: bool = False) -&gt; bool</code>  <code>async</code>","text":"<p>Remove an agent from this session.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>ID of the agent to remove</p> required <code>cascade</code> <code>bool</code> <p>Whether to remove child agents as well</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if removed successfully, False if not found</p>"},{"location":"generated/api/session/#aigise.session.aigise_dynamic_agent_manager.DynamicAgentManager.update_agent_status","title":"<code>update_agent_status(agent_id: str, status: AgentStatus) -&gt; bool</code>  <code>async</code>","text":"<p>Update agent status and trigger lifecycle hooks.</p> <p>Parameters:</p> Name Type Description Default <code>agent_id</code> <code>str</code> <p>ID of the agent to update</p> required <code>status</code> <code>AgentStatus</code> <p>New status to set</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if updated successfully, False if agent not found</p>"},{"location":"generated/api/toolbox/","title":"Toolbox","text":""},{"location":"generated/api/toolbox/#aigise.toolbox.decorators","title":"<code>aigise.toolbox.decorators</code>","text":"<p>Decorators for declaring sandbox dependencies in AIgiSE tools and toolsets.</p> <p>This module provides a unified decorator system for declaring which sandboxes are required by tools and toolsets. This enables static dependency analysis before actually creating any sandboxes.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.decorators.F","title":"<code>F = TypeVar('F', bound=Callable)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/toolbox/#aigise.toolbox.decorators.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/toolbox/#aigise.toolbox.decorators._collect_dynamic_skill_dependencies","title":"<code>_collect_dynamic_skill_dependencies(enabled_skills: Optional[Union[List[str], str]] = None) -&gt; set[str]</code>","text":"<p>Scan all available bash skills for sandbox requirements defined in SKILL.md.</p> <p>This manually scans the search paths (mirroring ToolLoader defaults) and parses the '## Requires Sandbox' section from SKILL.md files.</p> <p>Parameters:</p> Name Type Description Default <code>enabled_skills</code> <code>Optional[Union[List[str], str]]</code> <p>Optional filter to only collect dependencies from enabled tools.            - None: Collect from no tools (returns empty set)            - \"all\": Collect from all tools            - List[str]: Only collect from specified tools</p> <code>None</code>"},{"location":"generated/api/toolbox/#aigise.toolbox.decorators.collect_sandbox_dependencies","title":"<code>collect_sandbox_dependencies(agent) -&gt; set[str]</code>","text":"<p>Collect all sandbox dependencies from an agent and its tools.</p> <p>This function performs static analysis on an agent's tools to determine which sandboxes are required. It checks for <code>__sandbox_requirements__</code> metadata on: - Direct tool functions (decorated with @requires_sandbox) - Toolset instances (including MCP toolsets, returned by get_toolset() functions decorated with @requires_sandbox) - AgentTools (agents wrapped as tools, recursively) - Sub-agents (recursively)</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <p>An agent instance (LlmAgent, SequentialAgent, AigiseAgent, etc.)</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of sandbox type names required by the agent and all its sub-agents and mcp toolsets.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.decorators.requires_sandbox","title":"<code>requires_sandbox(*sandbox_types: str) -&gt; Callable[[F], F]</code>","text":"<p>Universal decorator for declaring sandbox dependencies.</p> <p>This decorator works for both: - Tool functions: Only marks the function with metadata - Toolset factories: Marks function AND injects metadata into returned instance</p> <p>The decorator is purely declarative - it does not create or fetch sandboxes. It only adds <code>__sandbox_requirements__</code> metadata for static analysis via <code>collect_sandbox_dependencies()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*sandbox_types</code> <code>str</code> <p>Variable number of sandbox type names that the tool or toolset depends on (e.g., \"main\", \"gdb_mcp\", \"neo4j\").</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>A decorator function that adds sandbox_requirements metadata.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.decorators.safe_tool_execution","title":"<code>safe_tool_execution(func: F) -&gt; F</code>","text":"<p>Decorator to wrap tool functions with error handling.</p> <p>Catches all exceptions and returns a formatted error message with backtrace. Works for both sync and async functions.</p> <p>Returns:</p> Type Description <code>F</code> <p>dict with \"error\" key containing failure message and backtrace</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools","title":"<code>aigise.toolbox.general.agent_tools</code>","text":""},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools._build_full_instruction","title":"<code>_build_full_instruction(instruction: str, include_history: bool, tool_context: ToolContext) -&gt; str</code>","text":"<p>Build complete instruction with optional conversation history.</p> <p>Parameters:</p> Name Type Description Default <code>instruction</code> <code>str</code> <p>The base instruction</p> required <code>include_history</code> <code>bool</code> <p>Whether to include conversation history</p> required <code>tool_context</code> <code>ToolContext</code> <p>Tool context containing session events</p> required <p>Returns:</p> Type Description <code>str</code> <p>Complete instruction string with optional history context</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.agent_ensemble","title":"<code>agent_ensemble(instruction: str, agent_name: str, model_name_to_count: dict[str, int], history_passed_in: bool, tool_context: ToolContext)</code>  <code>async</code>","text":"<p>Agent ensemble is a tool that allows launching multiple agents, each with a different model, to perform a task. The agent will then aggregate the results from the agents and return the final result.</p> <p>Before calling this tool, you must call get_available_agents_for_ensemble and get_available_models FIRST to get the allowed agents and models, as the allowed agents and models may change over time.</p> IMPORTANT <ul> <li>\"inherit\" is a special model name meaning: reuse the current/root   agent's model object from context.</li> <li>If get_available_models returns only [\"inherit\"], then you MUST pass   model_name_to_count={\"inherit\": N}. This will run N ensemble agents   using the same model object as the current/root agent.</li> </ul> <p>Args:     instruction: The specific instruction/task you want all agents to execute     agent_name: The name of the agent to launch (must be in safe agents list)     model_name_to_count: A dictionary of model names and the number of agents to launch with that model, where the key is the model name and the value is the number of agents to launch with that model, the total number of agents to launch is the sum of the values in the dictionary, it should be at least 2.     history_passed_in: Whether to pass conversation history to agents for additional context     tool_context: The tool context</p> <p>Returns:     The aggregated final result from all agents</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.agent_ensemble_pairwise","title":"<code>agent_ensemble_pairwise(instructions: list[str], agent_name: str, model_names: list[str], history_passed_in: bool, tool_context: ToolContext)</code>  <code>async</code>","text":"<p>Launch multiple agents in parallel, each with its own instruction and model. call this tool when you have multiple tasks to complete, for example, you have different approaches to solve the task, you can use this tool to try different approaches in parallel. - instructions: list of per-agent instructions - model_names: list of per-agent model names (same length as instructions) - agent_name: target agent to launch (must be in safe agents list) - history_passed_in: whether to include folded history in each instruction</p> <p>Examples:</p> <p>1) Two tasks on the same model    instructions = [      \"Summarize repo READMEs\",      \"Extract CVEs from logs\",    ]    model_names = [      \"openai/gpt-5\",      \"openai/gpt-5\",    ]</p> <p>2) Three tasks with mixed models    instructions = [      \"Generate remediation plan\",      \"List risky endpoints from code\",      \"Draft incident report\",    ]    model_names = [      \"anthropic/claude-sonnet-4-20250514\",      \"openai/gpt-5\",      \"openai/gpt-5\",    ]</p> <p>real instructions should be more specific and detailed, not just a general task description.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.complain","title":"<code>complain(complaint: str, tool_context: ToolContext)</code>  <code>async</code>","text":"<p>If you have a complaint, you should call this tool to complain about it. E.g., if a tool is hard to use, if a file or folder is supposed to be there but is not, etc. We will take your complaint into consideration and improve the tooling. If there is a description that contradicts with the reality, you should call this tool to complain about it. Note that the task description is always correct, and there is definitely a way to complete it,you should not complain about it.</p> <p>Returns:</p> Type Description <p>\"Complained, we will take your complaint into consideration and improve the tooling.\"</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.critique","title":"<code>critique(tool_context: ToolContext)</code>  <code>async</code>","text":"<p>Call this to query another model as a consultant to help you solve the task, you should call this frequently to get an idea of how to solve the task.</p> <p>Returns:</p> Type Description <p>dict with 'idea' containing the other model's suggestion</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.flag_unjustified_claims","title":"<code>flag_unjustified_claims(tool_context: ToolContext)</code>  <code>async</code>","text":"<p>Flag the unjustified claims in the history, this is done by another model</p> <p>Returns:</p> Type Description <p>A natural language analysis of unjustified claims found in the conversation</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.get_aigise_session","title":"<code>get_aigise_session(aigise_session_id: str, config_path: Optional[str] = None) -&gt; AigiseSession</code>","text":"<p>Get or create an AigiseSession for the given session ID.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.get_available_agents_for_ensemble","title":"<code>get_available_agents_for_ensemble(tool_context: ToolContext)</code>  <code>async</code>","text":"<p>Get the available agents for the ensemble. Uses AgentEnsembleManager to discover static subagents, agent tools, and dynamic agents. Only agents whose tools are all covered by THREAD_SAFE_TOOLS are considered safe for ensemble.</p> <p>Note that maybe there are no agents that are suitable for the current task, you should create a dynamic subagent that is suitable for the current task and then call it by agent_ensemble tool. Pick up thread-safe tools for dynamic agents if you want to create one for the current task.</p> <p>Returns:</p> Type Description <p>Dictionary with safe_agents list, summary, and agent counts</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.get_available_models","title":"<code>get_available_models(tool_context: ToolContext)</code>  <code>async</code>","text":"<p>Get the available models configured for ensemble use.</p> Notes <ul> <li>The special model name \"inherit\" means: reuse the current agent's model   object from context (i.e., the root/current agent model).</li> </ul> <p>Returns:</p> Type Description <p>Dictionary with available_models list and count</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.note_suspicious_things","title":"<code>note_suspicious_things(suspicious_things: str, tool_context: ToolContext)</code>  <code>async</code>","text":"<p>If you have multiple intereting points or suspicious things to explore, you can call this tool to note them down so that you don't forget them.</p> <p>Returns:</p> Type Description <p>\"Noted\"</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.plan","title":"<code>plan(plan: str, tool_context: ToolContext)</code>  <code>async</code>","text":"<p>If you have want to do some planning, do not output the plan in plain text, call this tool to do the planning.</p> <p>Returns:</p> Type Description <p>\"Planning done\"</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.safe_tool_execution","title":"<code>safe_tool_execution(func: F) -&gt; F</code>","text":"<p>Decorator to wrap tool functions with error handling.</p> <p>Catches all exceptions and returns a formatted error message with backtrace. Works for both sync and async functions.</p> <p>Returns:</p> Type Description <code>F</code> <p>dict with \"error\" key containing failure message and backtrace</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.agent_tools.think","title":"<code>think(thinking: str, tool_context: ToolContext)</code>  <code>async</code>","text":"<p>If you have want to do some reasoning, do not output the reasoning in plain text, call this tool to do the reasoning.</p> <p>Returns:</p> Type Description <p>\"Thinking done\"</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent","title":"<code>aigise.toolbox.general.dynamic_subagent</code>","text":""},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent._DEFAULT_SEARCH_LIMIT","title":"<code>_DEFAULT_SEARCH_LIMIT = 10</code>  <code>module-attribute</code>","text":""},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.AgentStatus","title":"<code>AgentStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Agent lifecycle status.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent._extract_tool_names_from_agent","title":"<code>_extract_tool_names_from_agent(agent_instance) -&gt; List[str]</code>","text":"<p>Extract tool names from agent instance</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent._extract_tool_names_from_metadata","title":"<code>_extract_tool_names_from_metadata(metadata: Any) -&gt; List[str]</code>","text":"<p>Extract tool names from agent metadata config</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent._keyword_score","title":"<code>_keyword_score(*, keywords: List[str], name: str, description: str, match_all: bool) -&gt; tuple[bool, int, List[str], List[str]]</code>","text":"<p>Return (matched, score, matched_keywords, matched_fields).</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent._normalize_keywords","title":"<code>_normalize_keywords(keywords: Union[List[str], str]) -&gt; List[str]</code>","text":"<p>Normalize keyword input into a list of non-empty strings.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.call_subagent_as_tool","title":"<code>call_subagent_as_tool(agent_name: str, task_message: str, tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Call a sub-agent as a tool - Agent as a Tool pattern. You should first list the existing sub-agents before trying to call one.</p> <p>This supports both dynamic agents and the current agent's subagents (only LlmAgent types).</p> <p>This treats the sub-agent as a specialized tool that can process natural language requests and return structured results.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>Name of the sub-agent to call</p> required <code>task_message</code> <code>str</code> <p>Natural language task description</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Result from the sub-agent execution</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.complain","title":"<code>complain(complaint: str, tool_context: ToolContext)</code>  <code>async</code>","text":"<p>If you have a complaint, you should call this tool to complain about it. E.g., if a tool is hard to use, if a file or folder is supposed to be there but is not, etc. We will take your complaint into consideration and improve the tooling. If there is a description that contradicts with the reality, you should call this tool to complain about it. Note that the task description is always correct, and there is definitely a way to complete it,you should not complain about it.</p> <p>Returns:</p> Type Description <p>\"Complained, we will take your complaint into consideration and improve the tooling.\"</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.create_subagent","title":"<code>create_subagent(agent_name: str, instruction: str, model_name: str, tools_list: List[str], tool_context: ToolContext, enabled_skills: Optional[List[str]] = None, description: Optional[str] = None) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Dynamically create a sub-agent with specified tools and instructions. You should first list the existing sub-agents before creating a new one.</p> <p>IMPORTANT: - A subagent's capabilities come from two sources:   1) Python tools/toolsets: determined by <code>tools_list</code> (plus a small set of      default baseline tools injected automatically, see below).   2) Bash tools: determined by <code>enabled_skills</code> (which controls which      <code>bash_tools/*</code> skills are loaded for the subagent). - <code>enabled_skills</code> can be empty. If it is empty/None, the subagent may not   have any bash tools available. Choose it carefully based on what the   subagent needs to do. - <code>tools_list</code> must NOT be empty. If it is empty, this tool will return an   error and no subagent will be created. - Default baseline tools (always injected):   <code>run_terminal_command</code>, <code>list_background_tasks</code>, <code>get_background_task_output</code>, <code>wait_for_background</code>,   <code>complain</code>.</p> <p>Parameters:</p> Name Type Description Default <code>agent_name</code> <code>str</code> <p>Custom name for the agent</p> required <code>instruction</code> <code>str</code> <p>Custom instruction for the agent, this will be the system prompt for the agent, it should be a comprehensive instruction for the agent to follow and not task-specific.</p> required <code>model_name</code> <code>str</code> <p>Model to use for the agent (e.g., \"anthropic/claude-sonnet-4\", \"openai/gpt-5\", or \"inherit\" to reuse the current agent's model)</p> required <code>tools_list</code> <code>List[str]</code> <p>List of Python tool names to assign to the agent. This may also include toolset names (e.g. \"gdb_mcp\", \"pdb_mcp\") if the caller agent exposes a toolset instance with a stable <code>name</code>. Passing a toolset name injects the entire toolset into the subagent.</p> required <code>enabled_skills</code> <code>Optional[List[str]]</code> <p>Controls which bash tools are loaded.           - None: Load NO bash tools.           - [\"all\"]: Load ONLY top-level skills: <code>&lt;root&gt;/*/SKILL.md</code>.           - List[str]: Load skills by relative path/prefix under the             skill root (e.g. [\"fuzz\"] or [\"fuzz/simplified-python-fuzzer\"]).</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional description for the agent</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with creation result and agent details</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.get_aigise_session","title":"<code>get_aigise_session(aigise_session_id: str, config_path: Optional[str] = None) -&gt; AigiseSession</code>","text":"<p>Get or create an AigiseSession for the given session ID.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.get_background_task_output","title":"<code>get_background_task_output(task_id: str, *, tool_context: ToolContext) -&gt; Dict[str, Any]</code>","text":"<p>Retrieve the output and exit code from a specific background task.</p> <p>Use this tool after launching a command with <code>background=True</code> or a command has been sent to the background. If the command already finished the helper returns the full logs and cleans up the underlying temp files; otherwise, it streams the current log buffer without interrupting the running process.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task (from list_background_tasks)</p> required <code>tool_context</code> <code>ToolContext</code> <p>Tool context from the agent</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>Dictionary containing: - task_id: The task ID - status: Current status of the task - output: The output from the task - exit_code: The exit code (0 for success, non-zero for failure) - error: Error message if task not found - cleaned_up: Boolean indicating if cleanup was performed</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.list_active_agents","title":"<code>list_active_agents(tool_context: ToolContext) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>List all active sub-agents, loading persistent agents on demand.</p> <p>This function: 1. Loads persisted agents on demand using caller's tools 2. Returns information about all dynamically created agents (both in-memory and restored)</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.list_background_tasks","title":"<code>list_background_tasks(tool_context: ToolContext) -&gt; Dict[str, Any]</code>","text":"<p>List all background tasks and their current status.</p> <p>This tool allows the agent to check the status of background tasks before making the next decision. It's particularly useful for: - Checking if fuzzing campaigns have completed - Monitoring long-running compilation or build processes - Verifying any task started with background=True parameter</p> <p>Parameters:</p> Name Type Description Default <code>tool_context</code> <code>ToolContext</code> <p>Tool context from the agent</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Any]</code> <p>Dictionary containing: - tasks: List of task information dictionaries, each with:     - id: Task ID     - pid: Process ID     - command: The command that was run     - status: Current status (running/completed/failed/completed/unknown)     - sandbox: The sandbox where the task is running - summary: Human-readable summary of task counts by status</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.run_terminal_command","title":"<code>run_terminal_command(command: str, background: bool = False, timeout: int = 60, execution_timeout: Optional[int] = None, sandbox_name: str = 'main', *, tool_context: ToolContext) -&gt; Dict[str, Any]</code>","text":"<p>Execute arbitrary bash inside the specified sandbox.</p> <p>This behaves like a one-off terminal session: any bash syntax, pipes, or scripts listed via <code>list_available_scripts</code> can be invoked.</p> <p>Command syntax and escaping rules (what the model should assume):   - Write <code>command</code> exactly as you would type it in bash. Pipes (<code>|</code>),     redirection (<code>&gt;</code>, <code>2&gt;&amp;1</code>), chaining (<code>&amp;&amp;</code>, <code>;</code>), subshells (<code>$(...)</code>),     and quoting all work normally.   - Do NOT wrap your command in <code>bash -c</code> or <code>bash -lc</code>. The backend     already executes your command via <code>bash</code> (and sources <code>/shared/bashrc</code>     if present). Wrapping again usually adds unnecessary quoting/escaping     pitfalls.   - No extra escaping is required by the backend. The backend does NOT     wrap your string into a fragile <code>bash -c '...'</code> one-liner; instead it     writes your command verbatim into a temporary script and executes it     with <code>bash</code>. This is newline-safe and preserves quotes as-is.   - The command runs as a non-interactive process (no TTY, no persistent     shell session). If you see output like     <code>mesg: ttyname failed: Inappropriate ioctl for device</code>, it's a benign     warning from shell init logic; the command can still succeed.   - Stdout/stderr are captured and returned (and for <code>background=True</code>, you     can retrieve them later via <code>get_background_task_output</code>).</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The full command line to execute (e.g., \"python3 -c 'print(123)' | cat\").</p> required <code>background</code> <code>bool</code> <p>Whether to run the command in the background (default: False)</p> <code>False</code> <code>timeout</code> <code>int</code> <p>Timeout in seconds for foreground commands, after which they will be moved to background (default: 60)</p> <code>60</code> <code>execution_timeout</code> <code>Optional[int]</code> <p>Timeout in seconds for the command itself, after which it will be terminated (default: None, meaning no timeout)</p> <code>None</code> <code>sandbox_name</code> <code>str</code> <p>The name of the sandbox to run the command in (default: \"main\").</p> <code>'main'</code> <code>tool_context</code> <code>ToolContext</code> <p>The tool context from the agent execution</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict describing execution status. When <code>background</code> is False the</p> <code>Dict[str, Any]</code> <p>response contains <code>output</code> and <code>exit_code</code>. Otherwise, it returns the</p> <code>Dict[str, Any]</code> <p><code>task_id</code> needed to resume/inspect the background run.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.safe_tool_execution","title":"<code>safe_tool_execution(func: F) -&gt; F</code>","text":"<p>Decorator to wrap tool functions with error handling.</p> <p>Catches all exceptions and returns a formatted error message with backtrace. Works for both sync and async functions.</p> <p>Returns:</p> Type Description <code>F</code> <p>dict with \"error\" key containing failure message and backtrace</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.search_agent","title":"<code>search_agent(keywords: Union[List[str], str], tool_context: ToolContext, limit: int = _DEFAULT_SEARCH_LIMIT, match_all: bool = False) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Search sub-agent pool by keywords in name/description and return metadata.</p> <p>This searches across: - Dynamic subagents in the current AIgiSE session (including persisted metadata) - ADK subagents attached to the current caller agent via <code>sub_agents</code></p> <p>Parameters:</p> Name Type Description Default <code>keywords</code> <code>Union[List[str], str]</code> <p>Search keywords. Accepts a whitespace-separated string or a list of strings.</p> required <code>limit</code> <code>int</code> <p>Max number of results to return (sorted by relevance).</p> <code>_DEFAULT_SEARCH_LIMIT</code> <code>match_all</code> <code>bool</code> <p>If True, require all keywords to match in (name or description).</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>dict with <code>matches</code> listing matching agents and their metadata.</p>"},{"location":"generated/api/toolbox/#aigise.toolbox.general.dynamic_subagent.wait_for_background","title":"<code>wait_for_background(task_id: str, timeout: int = 300, *, tool_context: ToolContext) -&gt; Dict[str, Any]</code>","text":"<p>Block until a background task finishes or the wait times out.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>Identifier returned by <code>run_bash_tool_script</code> or <code>run_terminal_command</code> when the task was launched.</p> required <code>timeout</code> <code>int</code> <p>Seconds to wait before returning with a timeout status.</p> <code>300</code> <code>tool_context</code> <code>ToolContext</code> <p>Execution context used to locate session state.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with keys such as <code>success</code>, <code>output</code>, <code>exit_code</code>, and</p> <code>Dict[str, Any]</code> <p><code>status</code>. If the wait hits the timeout, <code>timeout=True</code> is included.</p>"},{"location":"generated/cli/opensage-dependency-check/","title":"opensage dependency-check","text":"<pre><code>Usage: opensage dependency-check [OPTIONS]\n\n  Check AIgiSE external dependencies.\n\n  Checks for manually installed dependencies: - CodeQL: Required for CodeQL\n  static analysis features - Docker: Required for native Docker sandbox\n  backend - kubectl: Required for Kubernetes sandbox backend\n\n  All dependencies are optional unless you plan to use the corresponding\n  features.\n\nOptions:\n  --help  Show this message and exit.\n</code></pre>"},{"location":"generated/cli/opensage-web/","title":"opensage web","text":"<pre><code>Usage: opensage web [OPTIONS]\n\n  Starts an AIgiSE-flavored Web UI: prepare environment then serve agents.\n\nOptions:\n  --config FILE                   Path to AIgiSE TOML config.  [required]\n  --agent DIRECTORY               Path to the agent folder (must contain agent\n                                  files).  [required]\n  --host TEXT                     Binding host for the server.  [default:\n                                  127.0.0.1]\n  --port INTEGER                  Port for the server.  [default: 8000]\n  --reload / --no-reload          Whether to enable auto reload.  [default:\n                                  reload]\n  --log_level [debug|info|warning|error|critical]\n                                  Logging level for the server.  [default:\n                                  INFO]\n  --neo4j_logging / --no-neo4j_logging\n                                  Enable Neo4j event logging via monkey\n                                  patches.  [default: no-neo4j_logging]\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"generated/cli/opensage/","title":"opensage","text":"<pre><code>Usage: opensage [OPTIONS] COMMAND [ARGS]...\n\n  AIgiSE CLI tools.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  dependency-check  Check AIgiSE external dependencies.\n  web               Starts an AIgiSE-flavored Web UI: prepare environment...\n</code></pre>"}]}